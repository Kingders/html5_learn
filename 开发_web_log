20170426
机器学习：（包含）
	supervised leaning 监督学习 ：根据 输入 预测 输出
		regression：预测结果
		classification：分类内容
	reinforcement leaning 强化学习： 做判断，决策
	unsupervised leaning 非监督学习：挖据有关输入的规律
人工智能 = 深度学习+强化学习    
强化学习 就是 训练最优大脑模型 实时训练 相当于人的最终大脑决策 判断， 
深度学习 相当于脑皮层 神经 对外部信息的处理。
	也称 supervised leaning 监督学习，
所以人工智能就是强化学习 加上深度学习 ，
比如alphaGo就是强化学习来负责决策，CNN来负责处理棋子 下棋位置的范围确定,MCTS树最后结合来搜索
这里讨论的是xxNN模型例子都是，深度学习的模型：
原理缥缈，直接学习使用 tensorflow 框架（做过alphago） 
下载安装 （只使用cpu，针对python2.7的版本）
sudo pip2 install --upgrade https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0-cp27-none-linux_x86_64.whl
教程：
https://my.oschina.net/yilian/blog/664632
教程的范例都会在tensorflow_test里示范学习一遍
1,入门，线性拟合实验，linear_fitting_test.py
2,CNN卷积神经网络： CNN_test.py 
3,自修改的卷积神经网络： CNN_test2.py
4,使用可视化界面观察训练情况tensorboard，（安装tensorflow时就已经安装了）
	tensorboard --logdir=/tmp/logs
	Starting TensorBoard 16 on port 6006
	(You can navigate to http://0.0.0.0:6006)	//浏览器打开 http://0.0.0.0:6006 就可以开始监测
	但是要使用tensorboard监测，代码里也要做相对应的设置 CNN_test3_with_tensorboard.py
	出错，是关于tensorboard的api 的调用出现了问题，以后再处理！！
5，
9，RNN/LSTM循环神经网络长短期记忆网络使用 RNN_test.py
10,最强网络 RSNN深度残差网络 平均准确率96-99% RSNN_test.py 卡死出错












20170428
从最基本的例子 CNN_test.py 深入 深度学习的 基础原理和概念
import input_data	//下载了一个例子数据包，分成两部分：60000行的训练数据集（mnist.train）和10000行的测试数据集（mnist.test）。
			//是一个 用于识别阿拉伯数字图片 的例子数据包 （0~9十个阿拉伯数字） 
			//训练数据用于训练模型，测试数据和训练数据其实是相同内容，
			//但独立出来是避免使用曾经用于训练模型的数据来检测模型，更公平得到模型的准确性
mnist = input_data.read_data_sets("/tmp/data/", one_hot=True)
			//这里是读取这个数据包的数据
			//每个数据包有两个数据集，
			//每个数据集都有两部分组成，一个是图片包，一个是对应的标签包
			//训练数据集有一个含60000张图片的图片包，和对应一个含60000行便签的标签包
			//测试数据集有一个含10000张图片的图片包，和对应一个含10000行便签的标签包		
			//每张图片对应一个 10维向量的便签，比如说：
			//图片包第200张图片显示”5“，便签包第200条10维向量对应为 ([0,0,0,0,0,1,0,0,0,0])
最基础的学习原理（矩阵乘法方程）：
使用线性回归的方法，就是通过提供的样本来训练出一个可以描述样本行为的 矩阵乘法方程，也叫训练出一种合理的特定”思维“
例子数据包每张图片是 28X28 分辨率的黑白图片，那每张图片可以表示为 28x28 = 784 维向量 x，对应的标签为 y
我们引入一个可以用于描述特征的 10×784 矩阵W， 和偏移向量量b  还引入一个特征标签10维向量 Y 
执行矩阵乘法： Y = W × x + b  （经过多样本训练，得到合理的 矩阵乘法 方程，最终W 和b稳定到一定区域，这个过程也称拟合，）
	Y1      W11x1  + W12x2  + W13x3  + ..... W1784x784  + b1
	Y2      W21x1  + W22x2  + W23x3  + ..... W2784x784  + b2
	Y3      W31x1  + W32x2  + W33x3  + ..... W3784x784  + b3
	Y4      W41x1  + W42x2  + W43x3  + ..... W4784x784  + b4
	Y5   =  W51x1  + W52x2  + W53x3  + ..... W5784x784  + b5
	Y6      W61x1  + W62x2  + W63x3  + ..... W6784x784  + b6
	Y7      W71x1  + W72x2  + W73x3  + ..... W7784x784  + b7
	Y8      W81x1  + W82x2  + W83x3  + ..... W8784x784  + b8
	Y8      W91x1  + W92x2  + W93x3  + ..... W9784x784  + b9
	Y10     W101x1 + W102x2 + W103x3 + ..... W10784x784 + b10		
即一张图片 x 通过特征矩阵 W 处理后，提取到特征便签 Y
再把特征便签归一化的预测标签 y_ = softmax（Y）
假如模型不断训练，特征矩阵 W 稳定到不需要改变，那么预测标签 y_ 与 x 对应的真实标签 y 应该一致！！！
如果不一致，y与y_就有误差，
通过统计误差，然后运用交叉熵等数学方法，得到修正量，反馈更新特征矩阵W和偏移向量b，
模型又进化成长了点，
通过不同图片 x 的训练 ，模型最终成长到一个接近完美的状态，这时，算出的y_与y极大多数一致，即表示模型基本能识别每一个图片上的数字
但仅仅y_与y一致，并不百分百认为识别对图片，
训练好的模型识别一张图片的过程是：
	得到图片的y_,y_与十中y中的一个吻合，基本确认图片数字与y对应的数字一样，
	然后模型继续取出 y 对应的那张暂存在模型里参照图片， 与正在识别的图片 执行布尔运算 （就是对俩个784维向量执行按维与运算）
	吻合程度超过75%，那么就完全确认正确图片上的数字！！！

欠拟合：训练出来的 矩阵乘法方程，与样本不能很好地吻合，不能很好形成合适的”思维“
过拟合：训练出来的的 矩阵乘法方程，只与已知的训练样本完全吻合，也不能形成合理的”思维“

加权回归：
	与线性回归的区别是，线性回归会考虑每一个样本，为训练出合适的 矩阵乘法方程 做贡献，
	而加权回归是，重视某部分样品对训练方程时的贡献，而忽略或减少某些样本对训练方程时的影响，所以训练的是变种 矩阵乘法方程

feedfroward模型神经网络:(FNN),而不是完整的CNN模型,对于CNN认识的补充有待讨论)：
	上述学习原理中，我们讲述是训练拟合一个合理的矩阵乘法方程（思维） Y = W × x + b，
		当这个 思维 被训练得相当成熟了，给机器 一个”信息：x“(这个x例如是28x28像素的整张图片)，根据 思维，机器做出一个”行为：y“
	这种思维只是一个 矩阵乘法方程，往往被视为思维简单，不管被训练得多久，最后应用时，做出的行为准确程度都不会太高！！
	如果现在改成以下方式：
	a1 = Wa1 × x + ba1，训练一个 向量乘法 方程提取抽象信息a1，即训练更新 特征向量Wa1，和偏移向量ba1
	a2 = Wa2 × x + ba2，训练一个 向量乘法 方程提取抽象信息a2，即训练更新 特征向量Wa2，和偏移向量ba2
	a3 = Wa3 × x + ba3，训练一个 向量乘法 方程提取抽象信息a3，即训练更新 特征向量Wa3，和偏移向量ba3
	a4 = Wa4 × x + ba4，训练一个 向量乘法 方程提取抽象信息a4，即训练更新 特征向量Wa4，和偏移向量ba4
	a5 = Wa5 × x + ba5，训练一个 向量乘法 方程提取抽象信息a5，即训练更新 特征向量Wa5，和偏移向量ba5
	可以看出，每个信息 x向量 都会得到 5个抽样信息组成的 a向量（a1,a2,a3,a4，a5）
	接着上述例子，一个样本信息集有60000个信息x，即60000个 x向量，就有60000个5维a向量
	然后继续：
	c1 = Wc1 × a + bc1，训练一个 向量乘法 方程提取抽象信息c1，即训练更新 特征向量Wc1，和偏移向量bc1
	c2 = Wc2 × a + bc2，训练一个 向量乘法 方程提取抽象信息c2，即训练更新 特征向量Wc2，和偏移向量bc2
	c3 = Wc3 × a + bc3，训练一个 向量乘法 方程提取抽象信息c3，即训练更新 特征向量Wc3，和偏移向量bc3
	c4 = Wc4 × a + bc4，训练一个 向量乘法 方程提取抽象信息c4，即训练更新 特征向量Wc4，和偏移向量bc4
	c5 = Wc5 × a + bc5，训练一个 向量乘法 方程提取抽象信息c5，即训练更新 特征向量Wc5，和偏移向量bc5
	c6 = Wc6 × a + bc6，训练一个 向量乘法 方程提取抽象信息c6，即训练更新 特征向量Wc6，和偏移向量bc6
	可以看出，每个a向量 都会得到 6个抽样信息组成的 c向量（c1,c2,c3,c4,c6）
	一个样本信息集有60000个信息x，就有60000个5维a向量，就有60000个6维c向量
	然后继续：
	Y = Wd × c + bd，训练一个 矩阵乘法 方程做出行为Y，即训练更新 特征矩阵Wd，和偏移向量bd
	最终通过抽象信息c做出行为Y
	比起简单的 x -> Y 思维，这里是 x -> a -> c -> Y 多层思维！
	每一个 向量乘法方程 视为一个神经元！
	那 5个 获取抽象信息a的 向量乘法方程 共同组成第一神经层
	那 6个 获取抽象信息c的 向量乘法方程 共同组成第二神经层
	每一条信息x 都处在输入层
	最后得到的行为Y 处在输出层
	那么：输入层x， 第一神经a， 第二神经层b， 输出层Y 组成的就是 一个神经网络
	发现每一层都是一个 矩阵方程组(多个向量方程组成一个矩阵方程组)
	上述是一个典型的神经网络例子，当然，实际的神经网络可以更多层，更复杂。
	一般矩阵乘法神经网络用于机械视觉，机械听觉类工作，例如识别图片内容，分析一首MP3属于什么类型音乐等等
	有一种改进的方法,可以减少计算复杂程度!!!
		就是对于上述的 所有 向量乘法方程 都加入同一个sigmond算子 或者 同一个tanh算子!!
		即都加 f(Z) = sigmond(z) 或者都加 f(z) = tanh(z)
		例如:
			a2 = f ( Wa2 × x + ba2 )
			....
			c5 = f ( Wc5 × a + bc5 )
			....
		如果是f()是tanh()这时得到的 a1,a2,....c1,c2,... 大部分要不是深度接近1,要深度接近近-1,即在[-1,1]区间
			即得到的a和c向量都偏简单比如: 向量a ={1,-0.9,1,0.8,-1},....
		如果是f()是sigmond这时得到的 a1,a2,....c1,c2,... 大部分要不是深度接近0,要深度接近近1,即在[0,1]区间
			即得到的a和c向量都偏简单比如: 向量a ={1,0.8,0,0.9,0},....
		这样再投入下一层网络的计算,计算量变得相当少,
		而且这种技巧被证明不影响模型的训练!!!
	还有一种算子叫 softmax() 与归一化相关的算子
	前向传导:就是上述的 向量x经一层层网络得到y
	反向传导:就是根据 实际推得y 和 预期y 的方差,往后修正网络中的各个W 和 b 的过程
				

卷积神经网络概念 （CNN）:
	参考:	http://blog.csdn.net/zkl99999/article/details/46805453
	   	https://www.zhihu.com/question/34681168
	现实中,的图片样品或者声音样品,如果使用传统的froward,那么就需要大量 矩阵方程,需要拟合大量的 大型W矩阵和b向量
	CNN的思想是:前期设立几层,通过卷积核提取样本特征!,最后得到多份的相互独立的特征碎片
		    后面的几层就是 统计和使用feedfroward模型等传统手段归类
	相比于feedfroward模型,
		CNN是多了一个提取出多份样本特征的过程,然后训练识别样本特征组成的输入向量.
		但是 feedfroward模型 ,直接把样本当成一个输入向量,然后训练,
		这么一比较就发现了 CNN 训练的时间成本低,而且,准确率不比feedfroward模型差!!
	一个重要的概念是 卷积核,其实就是一个nxn的小矩阵,
		卷积核用法:
			卷积核从样图片左上方开始,nxn卷积核 矩阵乘以 此刻所在nxn像素区域,
			得到的一个加权平均值,为新特征图的新的一个像素点!!
			(上述加权平均得到平均值的过程叫 池化)
			然后卷积核在样图片向右移动一个像素点,重复动作得到新特征图第二个像素点...
			卷积核移动轨迹从左到右,从上到下
		使用例子:
		例如一张300x300的样图image,通过一个 5x5的卷积核换算,得到一张296x296 的特征图map
		第一层conv为A,有10个5x5卷积核,那么这张image对应A层就有 10张296x296特征图A_map
		第二层conv为B,有6个100x100卷积核,那么A层每张map在B层又分别有 6张193x193特征图B_map,理应60张B_map
			然而事实上不一定60张B_map,可以有限定有30张B_map,这就是说随机某些A_map并没有透过某些卷积核生成B_map
		第三层conv为C,有6个100x100卷积核,那么B层每张map在C层又分别有 6张92x92特征图C_map,理应共30x6=180张C_map
			然而只取其中60张C_map
		最后一层conv为D 有5个92x92卷积核,那么C层每张map在d层又分别有 5张1x1特征图D_map,理应共60x5=3000张D_map
			最后一层,会全部使用300张1x1特征图D_map,	
			由于1x1特征图,所以直接构造成 300维的向量,所以最后一层的这种变换叫做 全连接(full connecttion)
		以上就是取特征的过程,
		最后就类似 feedfroward模型 方法训练300维的向量!!! D层相当于输入层
		layer1 有 200 个300x1 向量方程,300维向量经过layer1 得到1个200维向量
		output 层 1  个200x50矩阵方程,最终得到一个 50维向量,
			归一化后最后指出图片里是一辆汽车
		统计以下 要训练的参数!!!
		A层(10x5x5)+10=260, B层(6x100x100)+6=60006, C层(6x100x100)+6=60006, D层(5x92x92)+5=8469
		layer1 300x200+200=60200, ouput 200x50+50=10050
		共 198991 个需要训练参数
	对比 feedfroward模型的一个例子!!!
		同样一张300x300的样图image,相当于300x300=90000维向量
		layer1 有 200 个90000x1向量方程,90000维向量经过layer1 得到1个200维向量
 		output 层 1  个200x50矩阵方程,最终得到一个 50维向量,
		统计以下 要训练的参数!!!
		layer1 90000x200+200=18000200, ouput 200x50+50=10050
		共 18010250 个需要训练的参数,
		即使不要 layer1,直接转成 50维向量,也要 90000x50+50=4500050个训练参数!!
		都比 CNN 训练的参数要多!!!	


循环神经网络概念 （RNN）：
	即过去的行为可以影响此刻行为的神经网络结构，以3层feedfroward神经模型 类比讲解 简单的3层经典RNN结构
	3层CNN即：输入层，第一层神经网络（假设只有4个神经元），输出层：从上述知道：
		第一神经网络对应的矩阵乘法方程有：
		a1 = Wa1 × x + ba1，训练一个矩阵乘法方程提取抽象信息a1，即训练更新特征矩阵Wa1，和偏移向量ba1
		a2 = Wa2 × x + ba2，训练一个矩阵乘法方程提取抽象信息a2，即训练更新特征矩阵Wa2，和偏移向量ba2
		a3 = Wa3 × x + ba3，训练一个矩阵乘法方程提取抽象信息a3，即训练更新特征矩阵Wa3，和偏移向量ba3
		a4 = Wa4 × x + ba4，训练一个矩阵乘法方程提取抽象信息a4，即训练更新特征矩阵Wa4，和偏移向量ba4
		输出层对应的矩阵乘法方程有：
		Y = Wc × a + bc，训练一个矩阵乘法方程做出行为Y，即训练更新特征矩阵Wc，和偏移向量bc
		经过训练后，经过这种传递关系 由x最终得到对应Y
	而 经典RNN 除了由此刻的x外，还又之前的x，共同得到此刻的 Y 的
		因此输入层 还是 x 不变
		第一神经网络对应的方程一般是这样，
		a1 = Wa1 × |x，<a-| + ba1，训练一个矩阵乘法方程提取抽象信息a1，即训练更新特征矩阵Wa1，和偏移向量ba1
		a2 = Wa2 × |x，<a-| + ba2，训练一个矩阵乘法方程提取抽象信息a2，即训练更新特征矩阵Wa2，和偏移向量ba2
		a3 = Wa3 × |x，<a-| + ba3，训练一个矩阵乘法方程提取抽象信息a3，即训练更新特征矩阵Wa3，和偏移向量ba3
		a4 = Wa4 × |x，<a-| + ba4，训练一个矩阵乘法方程提取抽象信息a4，即训练更新特征矩阵Wa4，和偏移向量ba4
		<a- 我暂且这样表示是 上一次的 x求Y 过程中 得到的的中间量 a（a1,a2,a3,a4）
		|x，<a-| 表示 x 与上一次的 a 的组成的矩阵
		也就说，除了输入层的x参数作为输入参数外，还有上次得到的a
		输出层对应的矩阵乘法方程有：
		Y = Wc × a + bc，训练一个矩阵乘法方程做出行为Y，即训练更新特征矩阵Wc，和偏移向量bc
		输出层的形式保持不变，就是这样子，使得上一次的输入直接影响到此刻行为的结果	 
	RNN的变种非常多，上述是最简单模型也是最没有应用前景的模型
	迄今应用最为广泛是RNN模型是基于 LSTM单元的模型
	参考：http://colah.github.io/posts/2015-08-Understanding-LSTMs/
	http://blog.csdn.net/Dark_Scope/article/details/47056361
	http://blog.csdn.net/u014595019/article/details/52605693
	重点是，之前的都是一个矩阵乘法方程作为一神经元
	但是lstm 使用多个矩阵乘法方程组成特殊神经元，其中有三个矩阵乘法方程作为“门”通过归一化后得到的1后0来判断是否输入 x 和 <a- 信息
		到神经元核的矩阵乘法方程，也判断是否传递到下一次的 工作循环去，


深度神经网络概念 （DNN）：
	这个概念比较广泛，其实就是各种基础神经网络的混合，还有往往是多层网络！！


///////以上介绍了一些基本模型,以下讨论如何反向修改模型参数达到 训练学习模型的目的!!////////

logistic分类 (只是分辨是与不是)		参考:http://blog.csdn.net/u014595019/article/details/52554582
	顾名思义，逻辑分类，是一种二分类法，能将数据分成0和1两类
	几乎所有的教材都是从logistic分类开始的，因为logistic分类实在太经典，而且是神经网络的基本组成部分，
	每个神经元(cell)都可以看做是进行了一次logistic分类
	假设有一个n维的输入列向量 x，也有一个n维的参数横向量h， 还有一个偏置量b， 那么就可以线性求和得到一个数z.

		z = hx + b
	
	此时因为z的值域是 [−∞,+∞] ，是无法根据z来判断列向量 x 到底是属于0还是1的。
	我们需要一个函数，来将z的值映射到[0,1]之间，这就是激活函数。激活函数有很多种，这里把 z 代入的激活函数是sigmoid函数。

			    1
		σ(z) =	_________	即, a = σ(z) = σ( hx + b )		
			1 + e^(-z)	
	
	z在[−∞,0]时,a从0上升到0.5; z在[0,+∞]时,a从0.5上升到1
	当 a 大于0.5的时候，我们判定x应属于1类，如果小于0.5，则属于0类。这样，就完成了判断的工作
	注意这时 a值域是 [0,1],不是只有0和1两个值. 但是z域[−∞,-4]时,a几乎等于0, z域[4,+∞]时,a几乎等于1,
	所以可以有种错觉是 a 只有 0 和 1 两个值,
	可以知道,h和b的值直接关系到logistic判断的准确性,
	最开始的时候，h中的值是随机的，而b的值是0. 我们通过不断的训练来使得h和b能够尽可能的达到一个较优的值
	假设我们列向量 x 的期望判定是y,而实际得到的判定值是a, a值域是 [0,1],但是 y 一般就是 0和1两个值!!
	定义一个损失函数 C(y,a),记录y与a的差距,那么:

					∂C	∂C
	那么当参数修正量(参数的偏导数),	__ =0	__ =0	 这个最优条件达到, h和b 就得到最优解,logistic判断的准确性也达到百分百
					∂h	∂b

				    ∂C		        ∂C
	通过不断迭代,	h = h − η * __ ,    b = b − η * __		h和b无限接近最优条件,logistic判断的准确性无限接近百分百
				    ∂h	 	        ∂b

	其中 η 表示学习率, 如果损失函数 C(y,a) 为平方损失函数: 	C = 1/2 (a−y)^2 	那么:

		∂C   ∂C   ∂a	     ∂σ(z)	   ∂σ(z)  ∂z
		__ = __ * __ = (a−y) _____ = (a−y) _____ ____ = (a−y)*σ′(z)*x = (a−y)*a*(1−a)x
		∂h   ∂a   ∂h	      ∂h	    ∂z    ∂h

		∂C
		__ = (a−y)*a*(1−a)
		∂b

	最后得到每次迭代的参数更新公式     
		h = h − η * (a−y) * a * (1−a) *x , 	
		b = b − η * (a−y) * a * (1−a)
logistic扩展(多样分类)
	譬如判断 某事物 是否是 3个类型中的一个,其实就是拆分成三个logistic分类,每个logistic分类都对这个食物判断是或者不是!!
	上面讨论时, a 只是一个数
	在这里我们可以列出一个列向量:	  [x,x,x]T   来表示 a,
	自然地,     y 也是一个列向量:	  [x,x,x]T
	那么,当
		a = y = [1,0,0]T	表示事物属于第一类
		a = y = [0,1,0]T	表示事物属于第二类
		a = y = [0,0,1]T	表示事物属于第三类
		a = y = [0,0,0]T	表示事物不属于任何一类
	自然地:本来的 logistic分类模型 扩展为:	
		z=Wx+b  
		a=σ(z)
	z是一个列向量,
	a是上上面谈论到的列向量
	W是矩阵,是三列 横向量 h 的组合,
	b是3个偏置量 组合的列向量!!
			⎡σ(z1) ⎤
			⎢σ(z2) ⎥
	而:	σ(z) =	⎢ ⋮     ⎥
			⎣σ(zn) ⎦
	最后同理的到参数修正量:(注意有些向量之间是进行点乘de ".*")

		∂C
		__ = (a−y) .* a .* (1−a) * xT
		∂W

		∂C
		__ = (a−y) .* a .* (1−a)
		∂b

以一个feedfroward如何反向传导,修改学习模型参数
	假设是一个 3层 feedfroward 模型
	输入层		隐藏层		输出层
	  x1		  ha1		  ya1
	  x2		  ha2		  ya2
	  x3		  ha3		  ya3
		⋮		⋮
	输入层是 列向量X（x1,x2,x3,,,）,
	隐藏层是 列限量ha（ha1,ha2,ha3,,,）,其中每个数值量haX，
		也代表着一个神经元，代表这一个 向量乘法如 ha1 = Whx1 * x + bh1
		其中 Whx1 是一个 行向量， bh1是一个偏移数值
	输出层是 列向量ya（ya1,ya2,ya3,,,）,
	所以这个三层模型 由两重 logistic扩展分类方法 组成：
		hz = Whx * x + bh 
		ha = σ(hz) 	//sigmoid函数,注意这是激活函数，不是归一化函数
		yz = Wyh * ha + by 
		ya = σ(yz)
	Whx 输入层到隐藏层的矩阵 多个 WhxX 行向量组成 , 
	bh 偏置向量 
	Wyh 隐藏层到输出层的矩阵 多个 WyhX 行向量组成, 
	by 偏置向量
	之前讨论过 feedfroward 的前向擦传导，现在讨论如何从的到的 ya 后向反导修正 Whx，bh，Wyh，by
	这里我们 设定使用的 损失函数依然是 差平和函数：    C = 1/2 ( ya − y)^2	其中 y 是期望值向量，ya是实际输出值向量
	则第二重 logistic扩展分类方法 的 参数修正量(参数的偏导数)有：

		∂C    ∂C    ∂ya
		___ = ___ * ___ = C′(ya) * σ′(yz) = (ya−y) .* a .*(1−a)
		∂yz   ∂ya   ∂yz
	
		 ∂C    ∂C    ∂yz
		____ = ___ * ____ = C′(ya) * σ′(yz) * haT 
		∂Wyh   ∂yz   ∂Wyh

		∂C    ∂C    ∂yz
		___ = ___ * ___ = C′(ya) * σ′(yz)
		∂by   ∂yz   ∂by

	类似地，第一重 logistic扩展分类方法 的 参数修正量有：
		
		∂C    ∂C    ∂yz
		___ = ___ * ___ = WyhT * [C′(ya) * σ′(yz)] 
		∂ha   ∂yz   ∂ha

		 ∂C    ∂C    ∂ha    ∂C    ∂ha    ∂hz      ∂C
		____ = ___ * ____ = ___ * ____ * ___  = [ ___ * σ′(hz) ] * xT
		∂Whx   ∂ha   ∂Whx   ∂ha   ∂hz    ∂Whx     ∂ha

		∂C    ∂C    ∂ha     ∂C
		___ = ___ * ___ = [ ___ * σ′(hz) ]
		∂bh   ∂ha   ∂bh     ∂ha

	可以看到，在 Whx 和 bh 的计算中都用到了 ∂C/∂ha 这可以看成由输出层传递到中间层的误差。
	那么在获得了各参数的偏导数以后，就可以对参数进行修正了 

			        ∂C
		Wyh = Wyh − η * ___  
			        ∂Wyh

			      ∂C
		by = by − η * ___ 
			      ∂by

				 ∂C
		Whx = Whx − η * ____   
				∂Whx

			      ∂C
		bh = bh − η * ___
			      ∂bh
	
	就这样得到修正量 反向修正了模型参数
激活函数	http://blog.csdn.net/u014595019/article/details/52562159
	激活函数的主要作用是提供网络的非线性建模能力。
	如果没有激活函数，那么该网络仅能够表达线性映射，此时即便有再多的隐藏层，其整个网络跟单层神经网络也是等价的！！
	因此也可以认为，只有加入了激活函数之后，深度神经网络才具备了分层的非线性映射学习能力
	就是说激活函数，本来就是可以不需要的！！！！
	激活函数不是线性代数里所说的归一化算术，
	激活函数的加入，可以锐化主要特征，而把很多无关紧要的细节模糊平滑掉！！
	激活函数应该具有什么样的性质：
		可微性： 当优化方法是基于梯度的时候，这个性质是必须的。
		单调性： 当激活函数是单调的时候，单层网络能够保证是凸函数。
		输出值的范围： 当激活函数输出值是 有限 的时候，基于梯度的优化方法会更加 稳定，
			因为特征的表示受有限权值的影响更显著;当激活函数的输出是 
			无限 的时候，模型的训练会更加高效，不过在这种情况小，一般需要更小的learning rate
	以下讨论的激活函数都未涉及向量！！
	sigmoid：

				   1
			f(x) = __________	
			       1 + e^(−x)

		sigmoid 是使用范围最广的一类激活函数，具有指数函数形状，它在物理意义上最为接近生物神经元。
		此外，(0, 1) 的输出还可以被表示作概率，或用于输入的归一化，代表性的如Sigmoid交叉熵损失函数。
		（图形见网络链接）
		sigmoid也有其自身的缺陷，最明显的就是饱和性。由于两则无穷接近 0 和 1，其两侧导数逐渐趋近于0 
			lim f′(x) = 0 	
			x−>∞
			具有这种性质的称为 软饱和激活函数。具体的，饱和又可分为左饱和与右饱和
		比较地，还有一个概念叫 硬饱和，特征为：
			f′(x) = 0，当|x|>c，（其中c为常数）
		在后向传递过程中，sigmoid向下传导的梯度包含了一个 f′(x) 因子（sigmoid关于输入的导数），
			因此一旦输入落入饱和区，f′(x) 就会变得接近于0，导致了向底层传递的梯度也变得非常小。
			此时，网络参数很难得到有效训练。这种现象被称为梯度消失。
			一般来说， sigmoid 网络在 5 层之内就会产生 梯度消失 现象
		此外，提出一个 输出均值 概念 :
			输出均值 指 把整个函数的[−∞,+∞]，积分得得到的值再做平均，
			sigmoid函数的输出都大于0，输出均值就不会是0，这种情况下称为 偏移现象，
			这会导致后一层的神经元将得到上一层输出的非0均值的信号作为输入。
			即 激活函数的输出都大于或等于0，称为偏移现象，
			当然 激活函数的输出都小于或等于0，也称为偏移现象，
		此外sigmod 与softmax 是不一样的！！
			softmax是归一函数，如果转换一个向量， 转换后向量的成员和为 1
			sigmod 如果转换一个向量， 转换后向量的成员不是 约等于1就是0！！

	tanh：

		       1 − e^(−2x)
		f(x) = ___________
		       1 + e^(−2x)

		图像特性 与 sigmoid 几乎一样,
		区别在值域在 [-1,1], x=0时，y=0。
		tanh 输出均值 = 0 
			所以，加入tanh的学习模型时，学习次数少，迭代次数少的情况也能达到显著效果
		tanh一样具有软饱和性，从而造成梯度消失。
		重申，梯度消失现象：指多层学习网络，无法，很难，或者几乎不能反向传导修正底层网络的参数，
			导致学习模型很难，甚至不能收敛！！
	
	ReLU：
		      /	x, if x≥0,
		f(x) = 			又可以写成： f(x) = max(0,x)
		      \	0, if x<0
		
		当x<0时，ReLU硬饱和，而当x>0时，则不存在饱和问题
		能够在x>0时保持梯度不衰减，从而缓解梯度消失问题
		这让我们能够直接以监督的方式训练深度神经网络，而无需依赖无监督的逐层预训练（这句话不明白）
		然而，随着训练的推进，部分输入会落入硬饱和区，导致对应权重无法更新。这种现象被称为“神经元死亡”。
		与sigmoid类似，ReLU的输出均值也大于0，偏移现象和 神经元死亡会共同影响网络的收敛性。
	
	Leaky-ReLU

		      / x, if x≥0,
		f(x) = 
		      \ α * x, if x<0,	α是一个常数！！

		针对在x<0的硬饱和问题的改进！！
	
	P-ReLU
	
		      / x, if x≥0,
		f(x) = 
		      \ α * x, if x<0,	α变化的

		针对在x<0的硬饱和问题的改进！！	
		α变化的意思是，对于当前的训练来说，α是常数，到了下一次训练，α改变为另一个常数

	ELU
	

		      / x, if x≥0
		f(x) = 
		      \ α * ( e^x − 1), if x<0

		融合了sigmoid和ReLU，左侧具有软饱和性，右侧无饱和性。
		右侧线性部分使得ELU能够缓解梯度消失
		左侧软饱能够让ELU对输入变化或噪声更好
		ELU的输出均值接近于零，所以收敛速度更快
		在 ImageNet上，不加 Batch Normalization 30 层以上的 ReLU 网络会无法收敛，
		PReLU网络在MSRA的Fan-in （caffe ）初始化下会发散，
		而 ELU 网络在Fan-in/Fan-out下都能收敛

	Maxout

		f(x) = max ( w1 × x + b1, w2 × x + b2, ⋯ , wn * x + bn )
		这个激活函数有点大一统的感觉，因为maxout网络能够近似任意连续函数，
		且当w2,b2,…,wn,bn为0时，退化为ReLU。Maxout能够缓解梯度消失，
		同时又规避了ReLU神经元死亡的缺点，但增加了参数和计算量。

损失函数
	平方差函数

			C = 1/2 (a−y)^2

		y是我们期望的输出向量，a为神经元的实际输出向量 a = σ( W * x + b) 使用了sigmoid激活函数
		我们知道参数修正量是
			∂C
			__ = (a−y) .* a .* (1−a) * xT
			∂W
	
			∂C
			__ = (a−y) .* a .* (1−a)
			∂b
		因为sigmoid函数的性质，导致σ′(z)在z取大部分值时会造成饱和现象，
		从而使得参数的更新速度非常慢，甚至会造成离期望值越远，更新越慢

	交叉熵函数  //(交叉熵的讨论依然存在严重问题，特别是求导，和用于logistic分类的概念)
		一般情况
		
			H(y,a) = − ∑ ( yi * ln(ai) )
				   i
	
			这里 y，a 指的是向量，y:[y1, y2,,,yi],	a:[a1,a2,,,ai]
			所以 yi，ai指的是向量中的 第i个成员
			譬如 辨别一个交通工具属于 汽车，飞机，船 三类中那一类？
				y属于期望向量：[1,0,0]表示属于飞机，[0,1,0]表示属于汽车 [0,0,1]表示属于船！！
				一台宝马算出的实际向量a: [0.05,0.8，0.15]
				表示机器学习到：宝马有 0.05概率属于飞机，0.8概率属于汽车，0.15概率属于船，
				然而实际上：宝马是 0% 概率属于飞机，100%属于汽车，0%概率属于船，
				即机器学习到对于 一台宝马这个样本来说： y：[0,1,0] a:[0.05,0.8，0.15]
					属于飞机的 期望概率分布值是 y1=0 ，实际概率分布值是 a1=0.05
					属于汽车的 期望概率分布值是 y1=1 ，实际概率分布值是 a1=0.8
					属于船的   期望概率分布值是 y1=0 ，实际概率分布值是 a1=0.15
				则 这个样本的 H(y,a) = -（ 0*ln（0.05） + 1*ln(0.8) + 0*ln(0.15) ）
				显然只有 a2（0.8) 那项有效，当a2越接近1, ln（a2）越小，H(y,a)越小，学习结果越准确
			当然 y向量的成员不一定只有0和1两值，还有其他复杂的情况例如 y:[90,7,0.56,,,],这些示情况讨论

		如果有多个样本，则整个样本的平均交叉熵为：

				   1
			H(y,a) = − _ * ∑ ∑ ( yi,n * ln(ai,n))
				   n   n i

			其中其中 yi,n 表示第n个期望样本y向量的第i个成员
			其中其中 ai,n 表示第n个实际样本a向量的第i个成员

		关于交叉熵的 logistic分类讨论，
			logistic分类 讨论的 二选一，问题：
			比如 判断一只兔子是不是人类，对于这个样本判断，期望值当然是百分100%非人类
			比如 一张中奖彩票，对于这个样本，期望值是30% 出现，70%不出现
			我们回顾之前讨论的的 logistic 分类模型！！
			
					z = hx + b	

				n维的输入列向量 x，
				有一个n维的参数横向量h，（也叫权重向量） 
				还有一个偏置量b，
				z是一个数，z的值域是 [−∞,+∞] ，是无法根据z来判断列向量 x 到底是属于0还是1的	
				引入 sigmoid函数，将z的值映射到[0,1]之间

						    1
					σ(z) =	_________	即, a = σ(z) = σ( hx + b )		
						1 + e^(-z)	

			对于一个样本 x向量，
				他 属于   某一个类别的 期望概率分布值是 y ，实际概率分布值是 a
				他 不属于 某一个类别的 期望概率分布值是 （1-y） ，实际概率分布值是 （1-a）
			所以他的交叉熵是
		
				H(y,a) = −（ y * ln(a) + (1−y) × ln(1−a)）
			
			很多时候，我们只讨论简单的 是与不是 的问题，所以 期望值y是 1和0 两者其一
				即对于某一样本例子 y是1 则 H(1,a) = -（ln（a））
				若对于又一样本例子 y是0,则 H(0,a) = -（ln（1-a））

			如果有多个样本， logistic分类 交叉熵 公式就变成

					   1
				H(y,a) = − _ × ∑ （ y * ln(a) + (1−y) × ln(1−a) ）
					   n   n

			由于，交叉熵，我们是引入作为 损失函数的，最后需要反向传导修正学习模型的参数！！
			所以接下来要讨论 参数修正量(参数的偏导数)的问题！！
			首先我们一般使用的是 多个样本logistic分类交叉熵 公式作为 logistic分类 的损失函数。
			如果我们一次有10个样本 x向量，
				即有10个： z = hx + b  向量乘法，和 10次sigmoid激活函数修改  a = σ(z) = σ( hx + b )
			那么 H(y,a) 的 n 就是10
			每个样本都有自己 y 和 a ，y和a 是实际数字  
			对于 H(y,a)， y 和 a 是参数。即有 10对不同的（y，a）代入，求出了H(y,a)
			因为带入 y 的数字是10个不一样的值，代入a的数字也是10个不一样的值，
			所以，应该 H(y,a) 有20个参数，而不是2个，其中有10个相对独立的y，和10个相对独立的a
			所以把式子变一下方便阅读

			H( y.1, y.2, ~~ y.10, a.1, a.2, ~~,a.10) 

					   1
				       = − _ ×  ∑   （ y.j * ln(a.j) + (1−y.j) × ln(1−a.j) ）
					   n   n=10
			
			注意，虽然把每个a都看作一个独立参数 a.j 但是算法公式都一样 a = σ(z) = σ( hx + b )
			即 同 一个 h向量权重 h:[h1,h2,h3,,,,,,] 和 b 偏移！！

					∂a.j   ∂a    ∂σ
			即会了例如有：	____ = ___ = ___   hi是h的某一成员	
					∂hi    ∂hi   ∂hi
			
			还有一个特别注意的 数学特性  σ′(z)=σ(z)(1−σ(z))
			那么：


			∂C     1          ∂C    ∂a.j
			___ = −_ * ∑  [  ____ * ___  ]
			∂hi    n   n     ∂a.j   ∂hi

			       1          y     (1−y)       ∂σ
			    = −_ * ∑ [ ( ____ − _____   ) * ___ ]
			       n   n     σ(z)   1−σ(z)      ∂hi

			       1          y     (1−y)       
			    = −_ * ∑ [ ( ____ − _____   ) * σ′(z) × xi ]
			       n   n     σ(z)   1−σ(z)      

			       1         σ′(z) × xi       
			    = −_ * ∑ [  _____________    * (σ(z)−y) ]
			       n   n    σ(z) * (1−σ(z))  			

			      1               
			    = _ * ∑ [ xi * ( σ(z) − y ) ]
			      n   n     




			∂C     1          ∂C    ∂a.j
			___ = −_ * ∑  [  ____ * ___  ]
			∂b     n   n     ∂a.j   ∂b

			       1          y     (1−y)       ∂σ
			    = −_ * ∑ [ ( ____ − _____   ) * __ ]
			       n   n     σ(z)   1−σ(z)      ∂b

			      1               
			    = _ * ∑ [ σ(z) − y ]
			      n   n     

			由于这两个算子都避开了 σ′(z)，因为 σ′(z)会几乎等于0，修正参数就不能传递到底层网络，出现了梯度消失现象
			交叉熵 很好绕过反向传导梯度消失的问题！！！ 
			这里之讨论了 最简单的logistic分类问题，如何拓展到logistic扩展(多样分类)，以后在讨论！！
			
		以下是对于交叉熵的错误理解！！！
			交叉熵的重点是先分辨单样本输入，和多样本输入的概念！！！ 
			单样本输入 如 z = h × x + b ，z为 结果值 h是横向量，x是样本列向量， b为偏移量
				这里 z 表示 x 属于某输出内容的概率
			多样本输入 如 z = h1 × x1 + h2 × x2 +,,,+b，
				z为 结果值 h1,h2,，分别都是横向量，x1,x2,,都是样本列向量， b为偏移量
				也可以写成：
					z = ( ∑ (wn * xn) ) + b
					      n
				这里 z 表示 x们 都属于某输出内容范畴的概率			
	
监督学习，监督学习算法是给定一组输入和输出，学习如何关联输入和输出
	上面讲的 feedfroward 分类的例子，属于监督学习












20170512			
机器学习破解验证码(cnn模型):http://blog.topspeedsnail.com/archives/10858/comment-page-1#comment-1332
		  	http://blog.csdn.net/ljp1919/article/details/64501002
			位置:/home/kingders/other/tensorflow_study/ramdom_captcha
	整个项目使用python2
	拷下来的源码开头要加上: # -*- coding:UTF-8 -*-
	python2.7 gen_captcha.py	//验证码图片生成
		出错:
		  File "/usr/lib/python2.7/dist-packages/PIL/ImageDraw.py", line 164, in arc
		    self.draw.draw_arc(xy, start, end, ink)
		TypeError: must be sequence of length 4, not 2
		解决:sudo pip2 install -U Pillow //更新pillow -u 是upgrade的意思
	python2.7 learning_and_test.py	//不断使用gen_captcha.py里的函数,生成验证码图片然后用于训练,
					//最后当正确率大于50%后输出 训练成果文件
		出错1:
		  File "learning_and_test.py", line 164, in train_crack_captcha_cnn
		    loss = tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(logits=output, labels=Y))
		TypeError: sigmoid_cross_entropy_with_logits() got an unexpected keyword argument 'labels'
		解决,与python2.7版本有关:
		loss = tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(output, Y)) //此版本python2.7使用这种格式
		#loss = tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(logits=output, labels=Y))
		出错2:
		  File "learning_and_test.py", line 178, in train_crack_captcha_cnn
		    sess.run(tf.global_variables_initializer())
		AttributeError: 'module' object has no attribute 'global_variables_initializer'
		解决,与python2.7版本有关:
		#sess.run(tf.global_variables_initializer())
 		sess.run(tf.initialize_all_variables()) //此版本python2.7使用这种格式
	python2.7 test.py	//使用训练成果文件 验证验证码!!
		出错1:
		  File "/usr/local/lib/python2.7/dist-packages/tensorflow/python/training/saver.py", line 1087, in restore
		    if not gfile.Glob(save_path):
		  File "/usr/local/lib/python2.7/dist-packages/tensorflow/python/platform/gfile.py", line 262, in Glob
		    return _glob.glob(glob)
		  File "/usr/lib/python2.7/glob.py", line 27, in glob
		    return list(iglob(pathname))
		  File "/usr/lib/python2.7/glob.py", line 38, in iglob
		    if not has_magic(pathname):
		  File "/usr/lib/python2.7/glob.py", line 95, in has_magic
		    return magic_check.search(s) is not None
		解决,与python2.7版本有关:
		saver.restore(sess, tf.train.latest_checkpoint('.'))	//可以这样
		#saver.restore(sess, "crack_capcha.model-7000")		//或者可以这样
		saver.restore(sess, tf.train.latest_checkpoint('crack_capcha.model-7000'))	//不可以这样
		出错2
		明明使用test.py,但是就偏偏也运行上了 learning.py 不应该运行的 train_crack_captcha_cnn()
		解决:
		给 train_crack_captcha_cnn() 前加上 if __name__ == '__main__': 
		出错3:
		各种notfound 问题,
		解决,后来发现 def crack_captcha 这个函数,还是放在 learning好,test.py只调用就好了!!1	
	总结:
		gen_captcha.py	定义了验证码生成函数 gen_captcha_text_and_image 并演示了 验证码生成
		learning.py	定义了cnn模型,
			   	定义了训练函数 train_crack_captcha_cnn
				定义了使用训练模型破解验证码的函数 crack_captcha
				并执行了训练函数 train_crack_captcha_cnn 训练结束生成训练模型 crack_capcha.model-7000
		test.py		执行了使用训练模型破解验证码的函数 crack_captcha
	通过learing 掌握 tensorboard 使用方法!!
		后台运行 tensorboard :	$ tensorboard --logdir=/tmp/logs &
					Starting TensorBoard 16 on port 6006
					(You can navigate to http://0.0.0.0:6006)
		learning.py里,我们对 accuracy 和 loss
			//定义初始化好 accuracy 和 loss 变量后,才添加监控项,即:
			//loss = tf.reduce_mean(...)
			//accuracy = tf.reduce_mean(...)
			//之后,添加监控项:
			tf.scalar_summary("loss", loss)	
			tf.scalar_summary("accuracy", accuracy)
			//把所有要监控的项 打包
			merged_summary_op = tf.merge_all_summaries()
			//初始化所有变量,sess.run(tf.initialize_all_variables())
			//动态监控文档放在 /tmp/logs文件夹里
			//注意,tf.initialize_all_variables() 是初始化了所有变量
			//sess.run()又是开始了迭代计算训练
			//初始化了所有变量,又开始了迭代计算训练才能添加动态监控文档:
			summary_writer = tf.train.SummaryWriter('/tmp/logs', graph_def=sess.graph_def)
			//注意后面的,
			//acc = sess.run(accuracy, feed_dict={X: batch_x_test, Y: batch_y_test, keep_prob: 1.})
			//_, loss_ = sess.run([optimizer, loss], feed_dict={X: batch_x, Y: batch_y, keep_prob: 0.75})
			//都读取迭代训练中途得到的数据结果,然后根据结果,更改收敛条件后,重新继续迭代训练
			//也就说,自从第一次sess.run后,就开始了迭代训练的计算,
			//每当下一次sess.run指令之前,中间其实经历了多次迭代训练,而不是只计算1次
			//迭代计算的结果是离散的,只有不断更改收敛条件才可以优化下一段时间的迭代计算,
			//而关于tensorboard调用的sess.run,只是得到当前迭代计算得到的结果,并没有更改收敛条件来影响后面的迭代训练活动
			summary_str = sess.run(merged_summary_op, feed_dict={X: batch_x, Y: batch_y, keep_prob: 0.75})
			//然后,上传到监控文件
			summary_writer.add_summary(summary_str, step)
		然后浏览器输入:http://0.0.0.0:6006/
			便能看到结果,如果发现没有内容,rm -r /tmp/logs/* 		//*/清空内容
			重新打开tensorboard 试试

补充:
python的一些重要模块:
	NumPy和SciPy是开源的 Python 的科学计算模块	
		NumPy：怎么处理缺失的数字:http://blog.topspeedsnail.com/archives/866
		NumPy入门详解:http://blog.topspeedsnail.com/archives/599
	pygame
		PyGame教程一：开始:http://blog.topspeedsnail.com/archives/2155
		PyGame教程二：声音和音乐:http://blog.topspeedsnail.com/archives/2166
安全与黑客:
	系统安全：开源的5个渗透测试工具:http://blog.topspeedsnail.com/archives/2817
	Katoolin – 在Ubuntu上安装Kali Linux工具集:http://blog.topspeedsnail.com/archives/4498
						 https://github.com/tiancode/learn-hacking
python的一种调用函数时的注意点:
		假如:
		a.py:	def了aa,bb,cc函数, 
			python a.py 时,会运行a.py的全局命令行, 
		b.py:	需要调用 a.py 的 aa 和 cc 函数, 就得加两行头 from a.py import aa,  from a.py import cc
			但是python b.py 时,除了成功调用aa cc外,还会,把a.py的全局命令行也执行一遍
			如果 b.py 只想运行自己的命令行,而不想执行 a.py 的命令行,但有可以使用别人def的函数,
			那么就得在 a.py的命令行前加上 if __name__ == '__main__':
			这样子: 
				python a.py 依然能完美执行自己的所有命令行
				python b.py 只执行自己的命令行,
python完美print出中文:
		print("某某某 {}, 哈哈哈 {} {} ".format(num1,charb,textc))  # (60, 160, 3)
		效果例子: 某某某 467, 哈哈哈 g kingders
		关键使用 " .format()" 格式函数  
python虚拟环境:
	不同的项目可能需要不同的python环境，
	比如不同的解释机: python2或者python3,专属的库文件,
	如果所以库和编译器都处于同一个环境时,就可能出现库与库之间冲突,或者项目库函数指向出错等兼容问题,
	所以针对不同的项目,需要不一样的编译器软件库,可以都放在一个独立的环境里!!在独立的环境里执行项目
	安装	
	pip install virtualenv  //(我机子默认python是python3的)默认使用python3安装的virtualenv版本
	创建:
	virtualenv aaa  	//创建一个独立环境空间aaa,在当前文件夹建立一个aaa文件夹,
				//这种默认情况下,会把默认的解释机,和对应的默认软件库加入环境aaa
	virtualenv --no-site-packages bbb //创建一个独立环境空间aaa,在当前文件夹建立一个aaa文件夹,
					  //这情况下,不会把默认的软件库加入环境bbb,
	virtualenv ccc --python=python2   //创建一个独立环境空间ccc,在当前文件夹建立一个ccc文件夹,
					  //这种默认情况下,会把默认的软件库,和默认的解释机加入环境ccc
	启用虚拟环境
	cd ccc	//进入环境文件夹
	source ./bin/activate
	cd ~ //进入要执行的项目的文件夹,例如~
	查看当前状态
	(ccc) kingders@kingders-ThinkPad-T420:~$ 	//先可以直观看到(ccc)前缀,就是说现在处于 ccc 的独立python 工作环境里下
	python -V  	//python 版本自动为2.7.6版本
	Python 2.7.6	
	pip -V		//pip 版本自动为显示为python2.7 对应的!!	
	pip 9.0.1 from /home/kingders/smart210/study/tensorflow_study/ramdom_captcha/ccc/local/lib/python2.7/site-packages (python 2.7)
	添加指定软件库
	pip install numpy scipy scikit-learn pillow h5py keras	//添加的软件库只会加入到 ccc 文件夹里,只为ccc环境所用
	退出虚拟环境
	deactivate
	/////////////////////////////////////////////////////////////
	以上是一般虚拟环境的使用过程
	如果要使用管理多个 虚拟环境, 建议再添加 virtualenvwrapper 补充功能软件
	安装:
	sudo pip install virtualenvwrapper //(我机子默认python是python3的)默认使用python3安装的virtualenvwrapper版本
	mkdir $HOME/.local/virtualenvs	  //创建虚拟环境管理目录 (不要加sudo)
	sudo gedit ~/.bashrc 	//末尾添加:
		# by william
		# setting about virtualenvwrapper
		export VIRTUALENV_USE_DISTRIBUTE=1        #  总是使用 pip/distribute                                        
		export WORKON_HOME=$HOME/.local/virtualenvs       # 所有虚拟环境存储的目录
		if [ -e $HOME/.local/bin/virtualenvwrapper.sh ];then
		   source $HOME/.local/bin/virtualenvwrapper.sh                                                
		else if [ -e /usr/local/bin/virtualenvwrapper.sh ];then
		         source /usr/local/bin/virtualenvwrapper.sh
		     fi
		fi
		export PIP_VIRTUALENV_BASE=$WORKON_HOME
		export PIP_RESPECT_VIRTUALENV=true
	source ~/.bashrc	//启动 virtualenvwrapper
	出错1: 每次打开终端都有:
		/usr/bin/python: No module named virtualenvwrapper
		virtualenvwrapper.sh: There was a problem running the initialization hooks. 
		If Python could not import the module virtualenvwrapper.hook_loader,
		check that virtualenvwrapper has been installed for
		VIRTUALENVWRAPPER_PYTHON=/usr/bin/python and that PATH is
		set properly.
		解决:这时候可以将VIRTUALENVWRAPPER_PYTHON路径(python全局路径)加入到~/.bashrc中，
		sudo gedit ~/.bashrc 	//在设置virtualenvwrapper其他内容前先添加:
			export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3
		source ~/.bashrc	//由于我们安装的virtualenvwrapper是针对python3版本,所以需要使用python3开启
					//而默认的/usr/bin/python虽然指向python3,但是这里不能很好指向python3
					//所以直接改成/usr/bin/python3
		成功后,每次打开终端都会自动打开了virtualenvwrapper后台.不再有上述问题信息出现!!
python 第三方库管理
	安装 pip insatall
	查看安装了哪些包,进入python命令行终端,输入命令 help('modules');
		







20170514
机器学习分类评论:http://blog.topspeedsnail.com/archives/10420
	这里分别对比使用了两个训练模型一个是 feedfroward,另外一个是CNN
	其中使用到nltk模块,也需要下载一些nltk插件,使用nltkdownload.py
	trainingandtestdata.zip 是训练用原始数据包,解压得:
		testdata.manual.2009.06.14.csv,
		training.1600000.processed.noemoticon.csv
	整个项目使用python3
	python3 preprocess.py	//预处理数据
		需要 nltk(自然语言工具库 Natural Language Toolkit)软件包,另外nltk还需要一些库,通过使用 nltkdownload.py下载到
		需要 pandas软件包,
		最后得到预处理后的据据 
			training.csv,
			tesing.csv
	python3 feedfroward_learning.py  //如果使用feedfroward学习模型,执行此训练
		出错1
		  File "feedfroward_learning.py", line 88, in train_neural_network
    		     cost_func = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(predict, Y))
		  File "/usr/local/lib/python3.4/dist-packages/tensorflow/python/ops/nn_ops.py", line 1562, in _ensure_xent_args
		    "named arguments (labels=..., logits=..., ...)" % name)
		ValueError: Only call `softmax_cross_entropy_with_logits` with named arguments (labels=..., logits=..., ...)
		解决:
		#cost_func = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(predict, Y))	# tensor 旧版本
		cost_func = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=predict, labels=Y))	# tensor 新版本


	python3 CNN_learning.py		//如果使用CNN学习模型,执行此训练
		出错1:
		  File "CNN_learning.py", line 84, in neural_network
		    h_pool = tf.concat(3, pooled_outputs)
		.........
		  File "/usr/local/lib/python3.4/dist-packages/tensorflow/python/framework/tensor_util.py", line 302, in _AssertCompatible
		    (dtype.name, repr(mismatch), type(mismatch).__name__))
		TypeError: Expected int32, got list containing Tensors of type '_Message' instead.
		解决:tensorflow版本格式问题
		# h_pool = tf.concat(3, pooled_outputs)  tensorflow 0.x 版本写法
		h_pool = tf.concat(pooled_outputs, 3)	//正确写法
		出错2:
		  File "CNN_learning.py", line 102, in train_neural_network
		    loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(output, Y))
		解决:tensorflow版本格式问题
		# loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(output, Y)) # tensorflow 旧版本写法
		loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=output, labels=Y)) # tensorflow 旧版本写法
		另外还要添加一个输出训练模型数据的代码!!!
		(准确率暂时只收敛到50%,准确率低主要是因为数据量太小,也不知道是不是模型不完整问题)











20170516
(以下都是个人pc上的)
安装opencv依赖:
	升级系统：
	$ sudo apt-get update
	$ sudo apt-get upgrade
	安装基本编译工具：
	$ sudo apt-get install build-essential cmake pkg-config
	由于OpenCV是计算机视觉库，总需要加载一些图像文件（ JPEG, PNG, TIFF）。使用下面命令安装一些必要的图像库：
	$ sudo apt-get install libjpeg8-dev libtiff5-dev libjasper-dev libpng12-dev	
	除了图片之外，OpenCV还要处理视频文件。使用下面命令安装一些视频编解码库：
	$ sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev
	$ sudo apt-get install libxvidcore-dev libx264-dev
	OpenCV的GUI模块highgui依赖Gtk。安装gtk库：
	$ sudo apt-get install libgtk-3-dev
	下面安装一些可以提高OpenCV性能的库，如矩阵操作：
	$ sudo apt-get install libatlas-base-dev gfortran
	安装Python2和Python3的开发库：
	$ sudo apt-get install python2.7-dev python3.4-dev
编译安装opencv3.1.0
	下载opencv3.1.0源码包,并原地解压
	$ ~/other/opencv
	$ wget -O opencv.zip https://github.com/Itseez/opencv/archive/3.1.0.zip
	$ unzip opencv.zip	
	$ wget -O opencv_contrib.zip https://github.com/Itseez/opencv_contrib/archive/3.1.0.zip
	$ unzip opencv_contrib.zip	
	编译opencv
	$ cd ~/other/opencv/opencv-3.1.0
	$ mkdir build
	$ cd build
	$ cmake -D CMAKE_BUILD_TYPE=RELEASE \
 		    -D CMAKE_INSTALL_PREFIX=/usr/local \
		    -D INSTALL_PYTHON_EXAMPLES=ON \
		    -D INSTALL_C_EXAMPLES=OFF \
		    -D OPENCV_EXTRA_MODULES_PATH=/home/kingders/other/opencv/opencv_contrib-3.1.0/modules \ # opencv_contrib路径
		    -D PYTHON_EXECUTABLE=/home/kingders/.local/virtualenvs/cv3/bin/python \  # 使用cv3
		    -D BUILD_EXAMPLES=ON ..  # ".."这两点不能忽略
	$ make -j4
		出错1
		In file included from /home/kingders/other/opencv/opencv-3.1.0/modules/videoio/src/cap_gstreamer.cpp:55:0:
		/usr/include/gstreamer-1.0/gst/gst.h:27:18: fatal error: glib.h: No such file or directory
 		#include <glib.h>
	                  ^
		compilation terminated.
		make[2]: *** [modules/videoio/CMakeFiles/opencv_videoio.dir/src/cap_gstreamer.cpp.o] Error 1
		make[1]: *** [modules/videoio/CMakeFiles/opencv_videoio.dir/all] Error 2
		make[1]: *** Waiting for unfinished jobs....
		编译过程中遇到众多错误,原因都是因为不能从默认 /usr/include 找到头文件,但是明明很多模块都已经成功安装好的,
		方法一:cp对应.h文件到 /usr/include,
		方法二:.bashrc 添加对应c,c++ 头文件搜索目录!! 然后 source ~/.bashrc 例如:
		export C_INCLUDE_PATH=$C_INCLUDE_PATH:/usr/lib/x86_64-linux-gnu/glib-2.0/include:/usr/include/glib-2.0
		export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/usr/lib/x86_64-linux-gnu/glib-2.0/include:/usr/include/glib-2.0
	$ sudo make install
	$ sudo ldconfig
创建一个python3 虚拟环境cv3 配置cv3是一个python3,opencv环境!!
	mkvirtualenv cv3 -p python3
	workon cv3
	安装numpy
	pip install numpy
	添加opencv库
	//安装好的opencv对应python3.4的库安装路径和库名称为:/usr/local/lib/python3.5/site-packages/cv2.cpython-34m.so
	//建立链接文件到虚拟空间指定位置
	$ cd ~/.local/virtualenvs/cv3/lib/python3.4/site-packages/
	$ ln -s /usr/local/lib/python3.4/site-packages/cv2.cpython-34m.so cv2.so

训练一个游戏Ai: (DQN)
	目录:/home/kingders/smart210/study/tensorflow_study/AI_game
	参考:http://blog.topspeedsnail.com/archives/10459 
	这里其实是一个 决策模型!! DQN
	需要不断截取屏幕截图,所以需要opencv库!!
	workon cv3 使用cv3虚拟环境
	python3 ai_player.py		
	出错!!
	Traceback (most recent call last):
	  File "ai_player.py", line 203, in <module>
	    train_neural_network(input_image)
	  File "ai_player.py", line 179, in train_neural_network
	    minibatch = random.sample(D, BATCH)
	  File "/home/kingders/.local/virtualenvs/cv3/lib/python3.4/random.py", line 311, in sample
	    raise TypeError("Population must be a sequence or set.  For dicts, use list(d).")
	TypeError: Population must be a sequence or set.  For dicts, use list(d).
	解决:
	line179:改为 minibatch = random.sample(list(D), BATCH)

训练一个游戏Ai2: (遗传算法) http://blog.topspeedsnail.com/archives/10952
	安装图片转换工具:
	sudo apt-get install imagemagick
	转换图片到png
	mogrify -format png plane.jpeg
	mogrify -format png enemy.gif
	修改图片分辨率
	mogrify -resize 50x50 *.png
	执行游戏Ai2
	python ai_player2.py`
		//这类算法模型不需要屏幕截图,不加载需要opencv模块
		//neuro_evolution.py是支持函数库文件

自动写诗: (RNN) http://blog.topspeedsnail.com/archives/10542
	python3 training
	出错1:
	  File "training.py", line 86, in neural_network
	    cell_fun = tf.nn.rnn_cell.BasicLSTMCell
	AttributeError: 'module' object has no attribute 'rnn_cell'
	解决:
	tf.nn.rnn_cell.BasicLSTMCell变成tf.contrib.rnn.BasicLSTMCell
	后续继续出现问题:
	后来发现,并不是简单替换既可以,新版rnn的框架改变了,所以,并不能很快修改出错问题!!!
	所以这个例子搁置!!

自动写歌: (RNN) http://blog.topspeedsnail.com/archives/10508
	先安装midi播放器:
	sudo apt-get install timidity
	sudo apt-get install fluidsynth
	播放:
	timidity -Od "midi_pkg/HotelCalifornia.mid" 出错,不会用,搁置
	准备音乐包: 人手下载太慢,将为此练习爬虫!!!!!!
	所以这个例子也搁置!!

google_deepdream 网络:http://blog.topspeedsnail.com/archives/10667
	执行时出错

图像分类器 – retrain谷歌Inception模型: http://blog.topspeedsnail.com/archives/10685	












20170517
(实在太慢,所以以下都是公司pc上的)
按上述部署公司pc
练习了python3 的文件操作 python_basic
并测试生成妹子图项目:(pixcNN) http://blog.topspeedsnail.com/archives/10660
	总之先下载图片包...
docker: 
	docker用于管理和打包 集成运行环境(虚拟系统,docker容器)
	集成运行环境(docker容器):就是一个装好了各种库,能够独立运行指定软件的虚拟根文件系统镜像
		比如说 软件A 可以在一个定制好的 docker容器/虚拟系统 里运行,
		而不需要为了运行 软件A,往自己系统加装各种乱七八糟库,搞乱自己系统
	这次 open_nsfw 需要使用一个 caffe模型框架库,这个东西不常用,不需要为了运行他而折腾安装 
		替代方案是找一个 已经装好 caffe模型框架库 的docker容器就好了
	docker对系统的要求： Linux 内核3.10+, 64位系统
		cat /etc/lsb-release	//查看ubuntu版本
		uname -a		//查看内核版本
	安装docker: http://blog.topspeedsnail.com/archives/7562
	sudo apt install docker.io
	启动/关闭docker后台服务 (与参考链接有别)
	sudo service docker start
		docker start/running, process 12723
	sudo service docker stop 
		docker stop/waiting
	版本查看:
	sudo docker version
		Client version: 1.6.2
		Client API version: 1.18
		Go version (client): go1.2.1
		Git commit (client): 7c8fca2
		OS/Arch (client): linux/amd64
		Server version: 1.6.2
		Server API version: 1.18
		Go version (server): go1.2.1
		Git commit (server): 7c8fca2
		OS/Arch (server): linux/amd64

使用open_nsfw,一个基于Caffe的成人图片识别模型:
	启动 docker 服务
	sudo service docker start
	下载一个 别人做好的 装有 caffe框架的 docker容器 镜像: http://blog.csdn.net/elaine_bao/article/details/53117676
	docker pull elezar/caffe:cpu
	下载完成后，测试是否安装正确
	docker run -ti elezar/caffe:cpu caffe --version
		libdc1394 error: Failed to initialize libdc1394 
		caffe version 1.0.0-rc3
		//关于libdc1394 error不用理会,只是容器里其他内容没装完整
		//如果这条消息辣眼睛,可以禁用这个模块: ln -s /dev/null /dev/raw1394
	在generate_pic项目文件夹里下载 open_nsfw 然后 cd进去
		git clone https://github.com/yahoo/open_nsfw
		cd /home/kingders/smart210/study/tensorflow_study/generate_pic/open_nsfw
	进入 caffe框架的 docker容器,并且以当前路径为镜像系统里的工作目录!!
		sudo docker run -t -i --volume=$(pwd):/workspace elezar/caffe:cpu /bin/bash
		root@21882b4bc80c:/workspace# 		//然后命令行变这样了,并是进入成功!!
		这时/home/kingders/smart210/study/tensorflow_study/generate_pic/open_nsfw,映射到虚拟系统离去了
		ls /workspace //里面的东西与/home/kingders/smart210/study/tensorflow_study/generate_pic/open_nsfw里一模一样
	运行 open_nsfw 鉴别图片色情级别!!
	python ./classify_nsfw.py --model_def nsfw_model/deploy.prototxt --pretrained_model nsfw_model/resnet_50_1by2_nsfw.caffemodel test1.jpg	
	//成功鉴别,输出级别分数!!
	//题外话,classify_nsfw.py是 python2的脚本,python3运行会出错,上面的docker容器默认python2,但也有python3
	//	而 elezar/caffe:cpu 这个虚拟系统里,默认python是python2,所以完美执行,
	//还有 .py脚本,只能使用虚拟系统里已有的支持库,如果没有也不会去搜索实体系统的支持库
	//	例如 elezar/caffe:cpu 这个虚拟系统里 没有pygame这个模块,所以运有 import pygame 的模块时,会出错!!!
	//import PIL 出问题,安装pillow库
	//	sudo apt-get install libjpeg-dev libpng12-dev libfreetype6-dev libtiff-dev
	//	pip install -I --no-cache-dir -v Pillow
	//关于 StringIO库 python3 与python2 兼容问题
	//	http://python.jobbole.com/81091/

训练生成妹子图!!! (generate_pic项目)
	预处理:(都在open_nsfw里操作)
	解压图片包,然后都扔进 images 文件夹
	workon cv_for_py3 (个人pc是cv3)
	together_dir.py	//遍历images文件夹及所有深层子文件夹,把所有分散的.jpg都剪切到girls文件夹里
	minimize.py	//把girls里的图片都缩成统一规格小图片 存到little_girls文件夹里
	dereplication.py	//图片去重 (4万张,好慢!!!!)
	nsfw.py		//未操作此步,计划是筛选出限制级图片删掉,此步需要 在docker容器里执行
	训练并生成妹子图!!!
	gen_pic.py	//由于新版本tensor,所以会有一些格式问题,幸亏变动不大可以迅速处理
			//使用资源十分庞大,电脑无法动了!!!!











20170714
建立个人网站!!!!!!!! 用python
预备:
	pc新建项目目录 selfweb 并进入
建立独立环境:
	mkvirtualenv selfweb -p python2.7
	workon selfweb
安装环境包:
	pip install django 	//web框架
	pip install uwsgi	//服务端容器 对django友好
	小技巧:
	如果pip install 安装慢 ,可以用豆瓣的镜像!
	pip install django -i http://pypi.douban.com/simple --trusted-host pypi.douban.com
建立github仓库:
	git init			//通过git init命令把当前目录变成Git可以管理的仓库
	登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库
	在Repository name填入selfweb，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库
	git remote add origin git@github.com:Kingders/selfweb.git 
		//在本地库learngit作为当前工作目录执行此命令，关联本地与远程仓库（通过ssh协议）
	git add readme
	git commit -m "first commit"
	git push -u origin master		//提交本地仓库到远程库
	出错: (由于使用新机器,还没有与我的github账号建立ssh连接)
	/*log start*/
	(selfweb) infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/selfweb$ git commit -m "first_commit"
	
	*** Please tell me who you are.
	
	Run
	
	  git config --global user.email "you@example.com"
	  git config --global user.name "Your Name"
	
	to set your account's default identity.
	Omit --global to set the identity only in this repository.
	
	fatal: unable to auto-detect email address (got 'infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR.(none)')
	(selfweb) infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/selfweb$ git push -u origin master
	The authenticity of host 'github.com (192.30.255.113)' can't be established.
	RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.
	Are you sure you want to continue connecting (yes/no)? yes
	Warning: Permanently added 'github.com,192.30.255.113' (RSA) to the list of known hosts.
	Permission denied (publickey).
	fatal: Could not read from remote repository.
	
	Please make sure you have the correct access rights
	and the repository exists.
	(selfweb) infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/selfweb$ git push -u origin master
	Warning: Permanently added the RSA host key for IP address '192.30.255.112' to the list of known hosts.
	Permission denied (publickey).
	fatal: Could not read from remote repository.
	
	Please make sure you have the correct access rights
	and the repository exists.
	/*log end*/
	解决:建立ssh连接
	创建SSH Key
	$ ssh-keygen -t rsa -C "418128064@qq.com"	//ssh key 与机器相连，所以同一email，不同机子的ssh key 不一样
	Generating public/private rsa key pair.
	Enter file in which to save the key (/home/kl/.ssh/id_rsa):	//不填,回车直接默认
	Enter passphrase (empty for no passphrase): //不填,回车直接默认
	Enter same passphrase again: //不填,回车直接默认
	Your identification has been saved in /home/kl/ssh.	//可以不填，直接回车
	Your public key has been saved in /home/kl/ssh.pub.
	The key fingerprint is:
	36:1a:e1:5c:9d:13:7b:ce:0c:6f:72:b8:a9:b7:8a:0c 418128064@qq.com
	The key's randomart image is:
	+--[ RSA 2048]----+
	|          .      |
	|         . +     |
	|      . . * .    |
	|     o o   X     |
	|      + S o B    |
	|       + . *     |
	|    E .   o      |
	|     o . ..      |
	|      o oo..     |
	+-----------------+
	在/home/kl目录下得到ssh文件（私钥），ssh.pub文件（公钥）
	登陆GitHub，打开“Account settings”，“SSH Keys”页面
	点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的全部内容后，点“Add Key”，你就应该看到已经添加的Key	
	再次git push 出错: 
	git push -u origin master	//出错,由于没有pc端没有登陆账号!!!
	登陆账号
	git config --global user.email "418128064@qq.com"
	git config --global user.name "kingders"
	再次git push 成功!! 终于建立好 github仓库!!!
创建 django 工程
	django-admin startproject selfweb ~/selfweb
		自动创建manage.py文件(一个工具脚本，不需要修改)，
		自动创建工程总目录shareditor
			包含了配置文件settings.py、
			总路由配置urls.py、
			wsgi协议配置文件wsgi.py
在工程下创建 网站app
	django-admin startapp web
		自动创建web目录，并且自动帮我们组织了一些文件，包括：
			admin.py：数据库表的后台管理类一般定义在这里
			apps.py：这个app的配置信息，这个文件一般不动
			migrations目录：存储数据库迁移相关的临时文件，不需要动
			models.py：和数据库对应的model类一般定义在这里
			tests.py：自动化脚本
			views.py：视图层脚本，我一般会把控制逻辑写到这里
尝试执行:
	python manage.py runserver	//执行网站服务
	然后登陆 http://127.0.0.1:8000就可以访问网页了	
修改得 helloworld 例程(单进程,单线程)
	修改web/views.py (添加一个显示函数)	
		# by william 
		from django.http import HttpResponse
		
		def index(request):
		    return HttpResponse('hi my baby!')
	修改路由规则:修改selfweb/urls.py
		# by william
		from web import views
		
		urlpatterns = [
		    url(r'^admin/', admin.site.urls),
		    # by william
		    url(r'^$',views.index)
		]
	python manage.py runserver	//执行网站服务 然后登陆 http://127.0.0.1:8000测试
设置成比较专业的高并发网站:(多进程)
	建立selfweb/uwsgi.ini:
		[uwsgi]
		chdir = /home/infortech-ubuntu-1404/selfweb
		http = 127.0.0.1:8000
		http-keepalive = 1
		module = selfweb.wsgi:application
		master = ture
		processes = 5
		daemonize = /home/infortech-ubuntu-1404/selfweb/logs/uwsgi.log
		disable-logging = 1
		buffer-size = 16384
		harakiri = 5
		post-buffering = 8192
		post-buffering-bufsize = 65536
		pidfile = /home/infortech-ubuntu-1404/selfweb/logs/uwsgi.pid
		enable-threads = true
		single-interpreter = true
	上述是配置了一个web容器
	logs文件夹还没有,我们mkdir 一个
	然后执行 启动命令:
	uwsgi --ini selfweb/uwsgi.ini	//得到如下log:
	[uWSGI] getting INI configuration from selfweb/uwsgi.ini
	多进程 网站服务 已经在后台启动了!! 登陆 http://127.0.0.1:8000可测试
	ps ux|grep uwsgi 可以查看正在工作的进程
	关闭 uwsgi 启动的网站服务:
		killall -9 uwsgi
	扩展:(先不研究)
	另外为了让我们的网站具有高可用性(高可用就是挂掉一台机器不影响服务)，一台机器启动服务还不行，
	我们至少要部署两台完全对等的web服务来同时提供服务，
	那么用户在浏览器里访问时到底访问的是哪个机器呢？这里有两种实现方案，
	一种是配置DNS记录，同一个域名对应多个ip，那么当一个ip不可用时浏览器会自动尝试另外的ip，
	还有一种方法就是通过稳定的代理服务器(如nginx、apache httpd等)来配置成一个负载均衡代理，对外暴露的一个ip，对内连接到多台web服务器
	uwsg.ini 里要用绝对路径我去!!!
		ps ux | grep uwsgi //查看  uwsgi
		uwsgi : killall -9 uwsgi	//关闭uwsgi
	补充1,
		网站移植到新机子时,需要重新配置 uwsg.ini,里的路径!!!
	补充2, 	测试nat123 外部映射,  
		把默认的8000打端口改为80端口!! selfweb/uwsgi.ini: -> http = 127.0.0.1:80
		使用80端口需要权限:所以启动服务时:sudo python manage.py runserver 80
		5798346c.nat123.net 是 80端口 映射, 内网/外网端口均为 80
		登录nat123映射的域名出错: 表示 5798346c.nat123.net 不在 ALLOW_HOSTS 表里,
		selfweb/settings.py -> ALLOWED_HOSTS = ['5708346c.nat123.net']
		重新 sudo python manage.py runserver 80 -> 远程机登录 5798346c.nat123.net 成功
		若使用uwsgi 布置服务器:
				把django默认的8000打端口改为80端口!! selfweb/uwsgi.ini: -> http = 127.0.0.1:80
				使用80端口需要权限 sudo uwsgi --ini selfweb/uwsgi.ini
				远程机登录 5798346c.nat123.net 成功			
添加数据库 mysql:
	数据库,是django网站各种扩展模块的基础,所以,建站之前先要初始化一个数据库
	当migrate过程时,django会给 selfweb/settings.py->INSTALLED_APPS 里提到的模块都建立相应的表单,
	先登陆数据库命令行处理界面
	mysql -u root -p	//以数据库root 登陆 后续提示填写root密码:3***************7
		create database db_selfweb;	//每条命令要加";",这里建立一个数据库
	退出登陆数据库: ctrl+c
	配置工程连接这个数据库: 修改 selfweb/settings.py
		DATABASES = {
		    'default': {
		        # 'ENGINE': 'django.db.backends.sqlite3',
		        # 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
			# by william
		        'ENGINE': 'django.db.backends.mysql',
		        'NAME': 'db_selfweb',
		        'USER': 'root',
		        'PASSWORD': '3***************7',
		        'HOST': '127.0.0.1',
		        'PORT': '3306',			//mysql默认的监听口,命令可查: ps -an | grep 3306
		        'OPTIONS': {
		            'sql_mode': 'traditional',
		        }
		    }
		}
	检查配置是否出错: python manage.py check
	出错: 没有加 python2 的 mysql 接口 Mysqldb
	解决: pip install MYSQL-python
	再检查:python manage.py check	//没出错 !!  System check identified no issues (0 silenced).
	补充: 
		db_selfweb 并不存在与 selweb网站目录里!!,拷贝移植selfweb网站到新机子时,并不带 db_selfweb
		关于如何把 db_selfweb也拷贝过去,日后在探究
创建web模块,及建立自定义model模型
	model即定义了 一条数据含有的 内容项,遵从这个model的每条数据都是 这个model的实例,多个实例最终集中成一个数据表格
	我们在代码里操作model的实例其实就是在操作数据库
	修改 web/models.py
		# by william
		class BlogPost(models.Model):
		    title = models.CharField(max_length=255,verbose_name='文章标题')
		    body = models.TextField(verbose_name='文章内容')
		    create_time = models.DateTimeField(verbose_name='创建时间')
	其实就是定义了一个BlogPost的model了,接下来的事情,就是把我们定义的model转换成一个真正的mysql model,建立真正的BlogPost数据表
	修改 selfweb/settings.py
		INSTALLED_APPS = [
		    'django.contrib.admin',	//表示 添加 django管理模块 admin
		    'django.contrib.auth',	//表示 添加 django管理模块 admin
		    'django.contrib.contenttypes',
		    'django.contrib.sessions',
		    'django.contrib.messages',
		    'django.contrib.staticfiles',
		    # by william
		    'web',	//添加我们创建的web到默认安装的app里
		]
	python manage.py makemigrations		//更新migrate配置
	python manage.py migrate		//根据配置建立数据库表单!!
	然后登陆数据库看看:
		use db_selfweb;		//转到db_selfweb
		show tables;		//显示建立了的数据表单
		+----------------------------+
		| Tables_in_db_selfweb       |
		+----------------------------+
		| auth_group                 |
		| auth_group_permissions     |
		| auth_permission            |
		| auth_user                  |
		| auth_user_groups           |
		| auth_user_user_permissions |
		| django_admin_log           |
		| django_content_type        |
		| django_migrations          |
		| django_session             |
		| web_blogpost               |
		+----------------------------+
		11 rows in set (0.00 sec)
		看到了 web_blogpost 就是我们定义的model 对应的 mysql 数据库表单
		而其他的是 django默认的建立的表单
数据库表 所谓的 一对多关系:(通过model 的联系理解)
	补充修改 web/models.py
		# by william
		class Subject(models.Model):
		    name = models.CharField(max_length=255,verbose_name='类别名称')
		    introduce = models.CharField(max_length=255,verbose_name='类别简介')
		    image = models.ImageField(verbose_name='类别图片')
		
		class BlogPost(models.Model):
		    title = models.CharField(max_length=255,verbose_name='文章标题')
		    body = models.TextField(verbose_name='文章内容')
		    create_time = models.DateTimeField(verbose_name='创建时间')
		    subject = models.ForeignKey(Subject,verbose_name='类别',null=True)
	python manage.py makemigrations		//更新migrate配置 这时出错,提示缺 pillow ,pip install 就好
	python manage.py migrate		//根据配置建立数据库表单!!
	然后登陆数据库看看:
		mysql -u root -p	//键入密码3***************7
			use db_selfweb;
			show tables;
		除了web_blogpost 还有一个web_subject,
		而且 web_blogpost 里也多了一项 subject_id 的内容项,即照应blogpost 这个model 多了一个内容项
数据库表 所谓的 多对多关系:(通过model 的联系理解)
	给每篇blogpost 都添加标签
	在这里,标签是比类别还要特殊,这里例子的局限性认为,每篇文章只能被归类到一个类别里,但可以被贴上多个标签
	那么是问题来了,是不是要 给 blogpost 这个model 添加几个内容项?来存被贴上的多个标签?
	但是如果有些文章只被贴一个标签的话,多余的没用标签内容项让model看起来比较臃肿
	所以观察以下改变:
	补充修改 web/models.py
		# by william
		class Tag(models.Model):
		    name = models.CharField(max_length=255,verbose_name='标签名称')
		
		class Subject(models.Model):
		    name = models.CharField(max_length=255,verbose_name='类别名称')
		    introduce = models.CharField(max_length=255,verbose_name='类别简介')
		    image = models.ImageField(verbose_name='类别图片')
		
		class BlogPost(models.Model):
		    title = models.CharField(max_length=255,verbose_name='文章标题')
		    body = models.TextField(verbose_name='文章内容')
		    create_time = models.DateTimeField(verbose_name='创建时间')
		    subject = models.ForeignKey(Subject,verbose_name='类别',null=True)
		    tags = models.ManyToManyField(Tag,verbose_name='标签')
	python manage.py makemigrations		//更新migrate配置 
	python manage.py migrate		//根据配置建立数据库表单!!	
	然后登陆数据库看看:
		再多了一个web_tag, 和 web_blogpost_tags 数据表
		但是 web_blogpost 里并没有多了一项 关于tag 的内容项,即照应blogpost 这个model 的结构 并没有变化
		替代地 多出了一张 web_blogpost_tags 的新表 来记录 blogpost的每条数据实例与 tag 每条数据实例的关系
关于pycharm 这个IDE:
	先不管!!
强大的后台管理工具 django-admin (例子:在django-admin管理后台管理BlogPost、Subject、Tag这三个表)
	要使用admin管理模块: 需要: selfweb/settings.py -> INSTALLED_APPS 含有:
		'django.contrib.admin',	//表示 添加 django管理模块 admin
		'django.contrib.auth',	//表示 添加 django管理模块 admin
	还需要:selfweb/urls.py -> urlpatterns 含有 url(r'^admin/', admin.site.urls)
	python manage.py createsuperuser	//创建管理者 
	登陆http://127.0.0.1:8000/admin页面,可以进行相关管理
	修改web/admin.py:
	# by william
		from .models import BlogPost
		from .models import Subject
		from .models import Tag
		
		class BlogPostAdmin(admin.ModelAdmin):
		    list_display = ('title', 'create_time', 'subject', 'tags')
		
		class SubjectAdmin(admin.ModelAdmin):
		    list_display = ('name')
		
		class TagAdmin(admin.ModelAdmin):
		    list_display = ('name')
		
		admin.site.register(Tag,TagAdmin)
		admin.site.register(Subject,SubjectAdmin)
		admin.site.register(BlogPost,BlogPostAdmin)
	检查 python manage.py check //出现以下错误未解决
		SystemCheckError: System check identified some issues:
		
		ERRORS:
		<class 'web.admin.BlogPostAdmin'>: (admin.E109) The value of 'list_display[3]' must not be a ManyToManyField.
		<class 'web.admin.SubjectAdmin'>: (admin.E107) The value of 'list_display' must be a list or tuple.
		<class 'web.admin.TagAdmin'>: (admin.E107) The value of 'list_display' must be a list or tuple.
		
		System check identified 3 issues (0 silenced).
	上述错误未解决,但是不影响 http://127.0.0.1:8000/admin 出现 BlogPost、Subject、Tag 的选单
	按道理现在就可以点入,并添加 给这些数据库表单 添加一条条数据信息!!
	但是出错:
		勉强可以写入 BlogPost 的数据消息条,
		但是 Subject 和 Tag 连进去都失败,不行!!!
		直接错误为:
		AttributeError at /admin/web/subject/
		Unable to lookup 'n' on Subject or SubjectAdmin	
	问题解决:
	由于web/admin.py的书写格式错误,导致以上显示问题,实际上add 的数据消息条都成功建立:只是显示出问题:
	重写web/admin.py为:
		# -*- coding: utf-8 -*-
		from __future__ import unicode_literals
		
		from django.contrib import admin
		
		# Register your models here.
		
		# by william
		from .models import BlogPost
		from .models import Subject
		from .models import Tag
		
		class BlogPostAdmin(admin.ModelAdmin):
		    list_display = ('title', 'create_time', 'subject', 'tags')
		admin.site.register(BlogPost,BlogPostAdmin)
		
		class SubjectAdmin(admin.ModelAdmin):
		    list_display = ('name',)
		admin.site.register(Subject,SubjectAdmin)
		
		class TagAdmin(admin.ModelAdmin):
		    list_display = ('name',)
		admin.site.register(Tag,TagAdmin)
	重启网站服务器成功
	补充:	
		网站移植到新机子时,(譬如这次公司机子做好的,移植到kingders上)出现的问题:
		python manage.py check
			SystemCheckError: System check identified some issues:
			ERRORS:
			<class 'web.admin.BlogPostAdmin'>: (admin.E109) The value of 'list_display[3]' must not be a ManyToManyField.
		这中情况下,自然 python manage.py runserver 也不会成功
		原因居然是: web/admin.py 上的 list_display = ('title', 'create_time', 'subject', 'tags')出问题,
		改为 list_display = ('title', 'create_time', 'subject', ) 即,参数过多的原因么?反正改后就正常了
		还有,由于忘了 管理者账号,需要重新建一个.python manage.py createsuperuser ,
		kingders 上建了个 账号:admin 密码:williamishandsome
管理界面的定制化
	页面顶部写的“Django administrator”换成“selfweb管理后台”，
		管理页面总标题因为是django-admin自身的内容，因此做定制有些复杂些，
		在根目录下创建如下目录templates/admin，
			mkdir templates
			mkdir templates/admin
		在里面新建base_site.html文件:(要注意全部用英文字符符号,否则出错)
			touch templates/admin/base_site.html
			内容如下:
			{% extends "admin/base.html"%}		//模块继承,这个内容后续分析
			{% load i18n %}
			
			{% block title %}
			{{ title }} | {% trans "selfweb后台管理" %}
			{% endblock %}
			
			{% block branding %}
			<hi id="site_name">{% trans 'selfweb后台管理' %}</hi>
			{% endblock %}
			
			{% block nav-global %}
			{% endblock %}			
	管理首页里的“WEB”改成“网站”，“Blog posts”改成“文章”，“Tag”改成“标签”，
		修改web/models.py:
		# by william
		class Tag(models.Model):
		    name = models.CharField(max_length=255,verbose_name='标签名称')
		    class Meta:		//这时model 的嵌套类 的内容,后续分析
		        verbose_name_plural = '标签'
		    def __unicode__(self):
		        return self.name
		
		class Subject(models.Model):
		    name = models.CharField(max_length=255,verbose_name='类别名称')
		    introduce = models.CharField(max_length=255,verbose_name='类别简介')
		    image = models.ImageField(verbose_name='类别图片')
		    class Meta:
		        verbose_name_plural = '类别'
		    def _unicode_(self):
		        return self.name
		
		class BlogPost(models.Model):
		    title = models.CharField(max_length=255,verbose_name='文章标题')
		    body = models.TextField(verbose_name='文章内容')
		    create_time = models.DateTimeField(verbose_name='创建时间')
		    subject = models.ForeignKey(Subject,verbose_name='类别',null=True)
		    tags = models.ManyToManyField(Tag,verbose_name='标签')
		    class Meta:
		        verbose_name_plural = '文章'
		    def _unicode_(self):
		        return self.name
		这里的verbose_name_plural就是在这个结构在管理页面里的展示名称，
		__unicode__就是这个结构里每一个对象的展示形式，直接看一下你的管理页面的效果就知道了	
	启动 template 功能:
		修改shareditor/settings.py，在TEMPLATES  =>  DIRS配置项中添加'templates'，
			TEMPLATES = [
			    {
			        'BACKEND': 'django.template.backends.django.DjangoTemplates',
			        'DIRS': [
			            'templates',
			        ],
			        'APP_DIRS': True,
			        'OPTIONS': {
			            'context_processors': [
			                'django.template.context_processors.debug',
			                'django.template.context_processors.request',
			                'django.contrib.auth.context_processors.auth',
			                'django.contrib.messages.context_processors.messages',
			            ],
			        },
			    },
			]		
	另外我们在新建BlogPost的时候，
		类别和标签这两项里写的是“Subject object”和"Tag object"，都不知道具体信息，
		(未解决)
图片管理(要申请阿里云,整段未验证)
	我们在新建一个类别的时候要为image字段选择一张图片，
	我们看到图片实际上上传到了根目录下。这种方式存在一些问题：
		1）如果要在网站中展示这张图片需要为其单独指定路由；
		2）如果网站多机部署无法实时同步数据；
		3）如果图片很大，会耗费很多带宽，响应慢

	为了解决如上问题，我们引入阿里云的对象存储OSS服务(收费,但不贵,)，
	它的优点是有CDN加速，也就是不同地域都有镜像，访问快，而且价格低廉，可比同样的网络带宽便宜多了
	OSS的使用请见官方文档，我这里直接贴代码，懂的可以参考，不懂的可以直接用
	首先要在阿里云的OSS中创建一个Bucket，如selfweb-selfweb，读写权限一定要选择“公共读”
	其次要安装oss2库，执行：
	pip install oss2
	然后在我们代码的根目录创建commons目录(用于放置所有公共组件)，
	并在其中创建一个空的__init__.py(作为lib的目录都要有这个文件，否则无法import)，
	并创建ossutils.py文件，内容如下
		# -*- coding: utf-8 -*-
		import oss2
		import time
		
		AccessKeyId = '我的accesskey'
		AccessKeySecret = '我的accesskey密码'
		Endpoint = 'oss-cn-beijing.aliyuncs.com'
		InternalEndpoint = 'oss-cn-beijing-internal.aliyuncs.com' 
		
		def upload_oss(bucket_name, file_name, bytes_content):
		    """
		    :param bucket_suffix: 区分测试环境和线上环境
		    :param file_name: 会自动添加时钟戳
		    :param bytes_content: 二进制的文件内容
		    :returm: 外网可以访问的url
		    """
		    auth = oss2.Auth(AccessKeyId,AccessKeySecret)
		    buck = oss2.bucket(auth, Endpoint, bucket_name)
		    file_path = 'dynamic/' + str(int(time.time())) + '_' + file_name
		    result = bucket.put_object(file_path, bytes_content)
		    if result.status == 200:
		        return 'http://' + bucket_name + '.oss-cn-beijing.aliyuncs.com' + file_path
		    else:
		        return None
	重载Subject的image的上传逻辑，修改web/admin.py，引入ossuitls：
		from commons.ossutils import upload_oss
	声明BucketName变量下面会用到：
		BucketName = 'selfweb_selfweb'
	修改SubjectAdmin类，添加如下方法：
		def save_model(self, request, obj, form, change):
		    if 'image' in request.FILES:
		        image_name = request.FILES['image'].name
		        image_content = request.FILES['image'].read()
		
		        url = upload_oss(BucketName, image_name, image_content)
		        if url:
		            obj.image = url
		
		    super(SubjectAdmin, self).save_model(request, obj, form, change)
	这时我们重新修改一个类目，重新上传图片，我们发现图片已经不再保存到本地文件了，
	而在阿里云的OSS里找到了上传的文件，而在我们的数据库里存储了这个图片在阿里云OSS中的url，可以直接访问

/////////至此 后台基本准备就绪，真正的前台网站开始出场了//////////

template 模板渲染
	模板属于mvc中的view这一层，是用来为网页布局的，
	乍一看来就是个html页面，但是里面会嵌入模板引擎提供给我们的特殊语法。
	模板引擎有很多，不同语言或框架都会实现自己一套，
	还有一些通用的模板引擎，但是他们语法和功能都比较类似，
	无非就是模板继承、模板引入、读透传的变量、循环、逻辑判断、filters、自定义标签等。
	我们这里直接用django原生的django-template就足够了。
	上述 管理者页讨论的的时候 就初步涉及模板构建的内容了: 这里先整理以下 如何打开 template 模板功能:
		修改shareditor/settings.py，在TEMPLATES  =>  DIRS配置项中添加'templates'，
		然后执行后面的操作:
	创建web/templates/web/index.html，内容如下：
		<!DOCTYPE html>
		<html lang="en">
		<head>
		    <meta charset="UTF-8">
		    <title>Title</title>
		</head>
		<body>
		<h1>Hello {{ name }}</h1>
		</body>
		</html>
	修改web/views.py中的index函数如下：
		def index(request):
		    return render(request, 'web/index.html', {'name': 'william_huang'})
	注意:同时 selfweb/urls.py 需要这样:
		from web import views
		urlpatterns = [
		    ...
		    url(r'^$',views.index),
	
	打开网页 http://127.0.0.1:8000/ 我们看到了一个大大的Hello william_huang (注意,8000后没有任何参数,配合url 的 ^$ 参数)
	这里的{{}}就是变量透传的语法，直接获取到python传进去的变量。
	另外这个模板文件的路径用的是web/index.html而不是直接index.html，
	原因是django里多个app如果用相同的模板文件名，在python代码里指定模板名时它分辨不出是哪个，
	所以一般把app的名字作为模板文件的目录
模板继承
	上述演示模板使用例子, 下面是讨论 模板使用的扩展内容
	我们网站的所有页面都有一个共同的布局，那就是顶部是logo，底部是版权声明，
	所以这个框架可以抽象出来一个基类模板，而所有页面模板都继承自这一模板，
	下面我们创建这个基类模板web/templates/web/base.html，内容如下：
		<!DOCTYPE html>
		<html lang="zh-CN">
		<head>
		    <meta charset="UTF-8">
		    <meta http-equiv="X-UA-Compatible" content="IE=edge">
		    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
		    <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css">
		    <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css">
		    <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css">
		    <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script>
		    <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
		
		    <title>{% block title %}selfweb - wiliam个人网站{% endblock title %}</title>
		    {% block head %}
		    {% endblock head %}
		</head>
		<body>
		
		<div class="row bg-primary" style="margin-right: 0">
		    <div class="col-sm-1 col-xs-1"></div>
		    <div class="col-sm-2 col-xs-11">
		        <h1><a href="" style="text-decoration: none;color: white;">william_selfweb</a></h1>
		    </div>
		    <div class="col-sm-6"></div>
		</div>
		
		{% block body %}
		{% endblock body %}
		
		<div class="row" style="margin-right: 0">
		    <div class="col-sm-2"></div>
		    <div class="col-sm-8 col-xs-12 text-center" style="color: #959595;margin-bottom: 10px;">
		        Copyright © <a href="">selfweb.com</a> | 京ICP备xxxxxxx号 | ccxxccxxcc@gmail.com
		    </div>
		</div>
		
		</body>
		</html>
	这里面有一些叫做block的代码块，它的作用是声明可重写的部分，下面你就会看到这个代码块是怎么在子模板中使用的。
	我们重写web/templates/web/index.html：为
		{% extends "web/base.html" %}

		{% block title %}
		{% endblock %}

		{% block body %}
		{% endblock %}
	这里我们只是做了继承，并没有重写,所以显示只看到了<body>的
	<div class="row bg-primary" style="margin-right: 0">
	<div class="row" style="margin-right: 0"> 
	这两部分,即顶部是logo，底部是版权声明
	我们重写web/templates/web/index.html：为
		{% extends "web/base.html" %}
		
		{% block title %}
		{% endblock %}
		
		{% block body %}
		    <div class="row jumbotron" style="margin-right: 0">
		        <div class="col-md-1 col-xs-1"></div>
		        <div class="col-md-10 col-xs-10"><h1>Welcome Big Data ITors!</h1></div>
		        <div class="col-md-1 col-xs-1"></div>
		    </div>
		{% endblock %}
	这时不但继承了,还重写添加了 body 内容
动态数据展示
	从数据获取tag数据，并展示到首页里。修改web/views.py的index函数，把tag数据取出来并传到模板中，如下：
		from .models import Tag	
		def index(request):
		    tags = Tag.objects.all()
		    return render(request, 'web/index.html', {'tags': tags})
	重写web/templates/web/index.html：
	{% extends "web/base.html" %}
	
	{% block title %}
	{% endblock %}
	
	{% block body %}
	
	    <div class="row jumbotron" style="margin-right: 0">
	        <div class="col-md-1 col-xs-1"></div>
	        <div class="col-md-10 col-xs-10"><h1>Welcome Big Data ITors!</h1></div>
	        <div class="col-md-1 col-xs-1"></div>
	    </div>
	
	    <div class="row" style="margin-right: 0">
	        <div class="col-sm-1 col-xs-1"></div>
	        {% for tag in tags %}
	            <div class="col-sm-2 col-xs-12">
	                <div class="thumbnail">
	                    <img src="{{ tag.image }}" alt="tag">
	                    <div class="caption">
	                        <h3>{{ tag }}({{ tag.blogpost_set.count }})</h3>  //注意这行程序的这样写法,还没有建立路由关系
	                        <p>
	                            {% for blogpost in tag.blogpost_set.all %}
	                                {{ blogpost.title }}
	                            {% endfor %}
	                        </p>
	                        <h5>更多>>></h5>
	                    </div>
	                </div>
	            </div>
	        {% endfor %}
	        <div class="col-sm-1 col-xs-1"></div>
	    </div>
	
	{% endblock %}
	
重启网站服务器:
		killall -9 uwsgi
		uwsgi --ini selfweb/uwsgi.ini
	登陆:http://127.0.0.1:8000 
	可以看到便签和指定文章!!
	显示更多内容需要去发掘，比如说为Tag添加image属性
展示最新文章
	为了用户能找到最新的文章，所以在所有页面的底部显示最新发表的文章，这需要修改基类模板了，
	首先在views.py中透传latest_blog_posts变量，如下：
		from .models import Tag
		from .models import BlogPost
		def index(request):
		    tags = Tag.objects.all()
		    latest_blog_posts = BlogPost.objects.order_by('create_time')[0:5]
		    return render(request, 'web/index.html', {'tags': tags, 'latest_blog_posts': latest_blog_posts})
	修改web/templates/web/base.html，在<body></body>中倒数第二位置处添加如下代码：
	<div class="row navbar navbar-inverse" style="margin:0">
	    <div class="row" style="margin:0">
	        <div class="col-sm-1 col-xs-1"></div>
	        <div class="col-sm-5 col-xs-5">
	            <h4 style="color: #FFFFFF; border-bottom: 1px solid #695d69; padding-bottom: 10px; margin-top: 30px;">最新文章</h4>
	            {% for blogpost in latest_blog_posts %}
	                <div class="row" style="margin: 10px; margin-left: 0; overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">
	                    <span style="color: #959595;">({{ blogpost.create_time|date:"Y-m-d" }})</span>
	                    <a title="{{ blogpost }}" style="color: #959595;">{{ blogpost.title }}</a>		/*显示标题设置*/
	                </div>
	            {% endfor %}
	        </div>
	        <div class="col-sm-1 col-xs-1"></div>
	    </div>
	</div>
	重启网站服务器:
	可以底下新文章的通知,显示了时间和文章标题二次登陆则因为检测到2次进入,所以就不再显示新文章通知
建立路由:
	目前为止,首页显示的文章内容,很多都没有建立链接到指定的页面上,接下来做这方面的工作!!
指定标签的文章列表页路由
	上一节完成的首页部分每个标签有对应的一块展示区域，
	希望点击标题可以进入到这个标签的文章列表页。
	定义如下路由规则，修改selfweb/urls.py，为urlpatterns增加如下一行：
		url(r'^bloglistbytag', views.blog_list_by_tag, name='blog_list_by_tag'),	//数组成员里加","是一个好习惯
	意思是说对于url路径为bloglistbytag的网页，直接调用views.blog_list_by_tag来执行逻辑。
	其中的name是用来在模板中利用“url”模板语法使用的，马上会看到
	在web/views.py中添加如下函数：
		def blog_list_by_tag(request):
		    if 'tagname' in request.GET:
		        tag_name = request.GET['tagname']
		        blog_posts = BlogPost.objects.filter(tags__name=tag_name)
		        latest_blog_posts = BlogPost.objects.order_by('create_time')[0:5]
		        return render(request, 'web/blog_list_by_tag.html', {'tag_name': tag_name, 'blog_posts': blog_posts,
		                                                             'latest_blog_posts': latest_blog_posts})
		    else:
		        return HttpResponse('404')
	这里首先通过获取GET请求的tagname参数来获取到标签名，然后通过model层查询数据库获取导数据，
	并通过web/templates/web/blog_list_by_tag.html这个模板来渲染的，这个模板如下样子：
		{% extends "web/base.html" %}
		
		{% block title %}
		    {{ tag_name }}
		{% endblock %}
		
		{% block body %}
		
		    <div class="row" style="margin-right: 0">
		        <div class="col-sm-3 col-xs-1"></div>
		        <div class="col-sm-6 col-xs-10">
		            <h1>{{ tag_name }}</h1>
		        </div>
		        <div class="col-sm-3 col-xs-1"></div>
		    </div>
		
		    <div class="row" style="margin-right: 0">
		        <div class="col-sm-3 col-xs-1"></div>
		        <div class="col-sm-6 col-xs-10">
		            {% for blog_post in blog_posts %}
		                <h4><a href="">{{ blog_post.title }}</a>({{ blog_post.create_time|date:'Y-m-d' }})</h4>
		            {% endfor %}
		        </div>
		    </div>
		
		{% endblock %}
	重启网站服务器:
	http://127.0.0.1:8000/bloglistbytag?tagname=hh  //打开标签为hh的文章列表页面
	由此看路由已经建立好!!
	通过首页链接进到这个列表页,我们修改web/templates/web/index.html:
		<h3>{{ tag }}({{ tag.blogpost_set.count }})</h3>
	改成:
		<h3><a href="{% url 'blog_list_by_tag' %}?tagname={{ tag }}">{{ tag }}({{ tag.blogpost_set.count }})</a></h3>
	由此可见,当路由建立好后 <a href=""></a> 是添加连接路径的 !!!
	由于html 是经过浏览器实时解释渲染的,所以随意修改html 不用重启网站服务器就可以测试!!
文章详情页的路由:
	添加web/templates/web/blog_show.html:
		{% extends "web/base.html" %}
		
		{% block title %}
		    {{ blog_post }} - SharEDITor - 关注大数据技术
		{% endblock %}
		
		{% block body %}
		
		    <div class="row">
		        <div class="col-sm-2 col-xs-1"></div>
		        <div class="col-sm-6 col-xs-10">
		            <div class="row">
		                <div class="col-sm-12 col-xs-12">
		                    <div class="row">
		                        <h1>{{ blogpost.title }}</h1>
		                    </div>
		                    <div class="row">
		                        <a class="btn btn-info btn-xs">{{ blog_post.subject.name }}</a>
		                        {% for tag in blog_post.tags.all %}
		                            <a class="btn btn-warning btn-xs" href="{% url 'blog_list_by_tag' %}?tagname={{ tag }}">
		                                {{ tag.name }}
		                            </a>
		                        {% endfor %}
		                        <small>发表于 {{ blog_post.create_time|date:"Y-m-d H:i:s" }}</small>
		                        <small>阅读{{ blog_post.pv }}次</small>
		                    </div>
		
		                    <div class="row">
		                        <hr/>
		                    </div>
		
		                    <div class="row">
		                        <div class="row">
		                            <div class="col-sm-12 col-xs-12">
		                                <img style="width: 100%; height: 100%;" src="{{ blog_post.image }}">
		                            </div>
		                        </div>
		                        {{ blog_post.abstract }}
		                        <br />
		                        {{ blog_post.body }}
		                    </div>
		                </div>
		            </div>
		            <div class="row">
		                <div class="col-sm-6 col-xs-6">
		                    <span style="color:#aaaaaa;">前一篇:</span>
		                    {% if prev_blog_post.first != null %}
		                        <a href="">{{ prev_blog_post.first }}</a>
		                    {% endif %}
		                </div>
		                <div class="text-right col-sm-6 col-xs-6">
		                    <span style="color:#aaaaaa;">后一篇:</span>
		                    {% if next_blog_post.first != null %}
		                        <a href="">{{ next_blog_post.first }}</a>
		                    {% endif %}
		                </div>
		            </div>
		
		            <!--PC和WAP自适应版-->
		            <div id="SOHUCS" sid="{{ blog_post.id }}" ></div>
		            <script type="text/javascript">
		             (function(){
		                    var appid = 'cysV8S2ux';
		                    var conf = 'prod_bd659405e413a4b27a3568e27185b632';
		                    var width = window.innerWidth || document.documentElement.clientWidth;
		                    if (width < 960) {
		                        window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="http://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("http://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })();
		            </script>
		        </div>
		
		        <div class="col-sm-2 hidden-xs">
		            <br/>
		            <div class="row">
		                <div class="col-sm-8">
		                    <h4>官方微信公众号</h4>
		                    <a href="http://shareditor-shareditor.oss-cn-beijing.aliyuncs.com/dynamic/weixinpub.jpg">
		                        <img width="90%" height="90%" src="http://shareditor-shareditor.oss-cn-beijing.aliyuncs.com/dynamic/weixinpub.jpg">
		                    </a>
		                </div>
		                <div class="col-sm-1">
		                    <div class="row">
		                        <a href="https://github.com/warmheartli">
		                            <div class="fa fa-github fa-3x" style="margin-top: 20px;"></div>
		                        </a>
		                    </div>
		                    <div class="row">
		                        <a href="http://weibo.com/chuangwanglaile">
		                            <div class="fa fa-weibo fa-3x" style="margin-top: 20px;"></div>
		                        </a>
		                    </div>
		                </div>
		            </div>
		            <hr/>
		            <h4>
		                {% for tag in blog_post.tags.all %}
		                    系列:{{ tag.name }}
		                {% endfor %}
		            </h4>
		            <div style="overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">
		                {% for tag_blog_post in tag_blog_posts %}
		                    {% if tag_blog_post.id == blog_post.id %}
		                        <h6 style="color: red;">{{ tag_blog_post }}</h6>
		                    {% else %}
		                        <h6><a href="{% url 'blog_show' %}?blogId={{ tag_blog_post.id }}">{{ tag_blog_post }}</a></h6>
		                    {% endif %}
		                {% endfor %}
		            </div>
		            <h4>全部系列</h4>
		            {% for tag in tags %}
		                <h6><a href="{% url 'blog_list_by_tag' %}?tagname={{ tag.name }}">{{ tag.name }}</a></h6>
		            {% endfor %}
		        </div>
		    </div>
		
		{% endblock %}
	在selfweb/urls.py，为urlpatterns增加如下一行：
		    url(r'^blogshow', views.blog_show, name='blog_show'),
	在web/views.py中添加如下函数：
	def blog_show(request):
	    if 'blogId' in request.GET:
	        blog_id = request.GET['blogId']
	        blog_post = BlogPost.objects.get(id=blog_id)
	        latest_blog_posts = BlogPost.objects.order_by('create_time')[0:5]
	        tag_blog_posts = BlogPost.objects.filter(tags__name=blog_post.tags.first())
	        tags = Tag.objects.all()
	        prev_blog_post = BlogPost.objects.filter(tags__name=blog_post.tags.first()).filter(id__gt=blog_post.id).order_by('id')[0:1]
	        next_blog_post = BlogPost.objects.filter(tags__name=blog_post.tags.first()).filter(id__gt=blog_post.id).order_by('id').reverse()[0:1]
	        return render(request, 'web/blog_show.html', {'blog_post': blog_post, 'latest_blog_posts': latest_blog_posts,
	                                                      'tag_blog_posts': tag_blog_posts, 'tags': tags,
	                                                      'prev_blog_post': prev_blog_post, 'next_blog_post': next_blog_post})
	    else:
	        return HttpResponse('404')
	添加 <a href=""></a> 链接:
		web/templates/web/index.html:
                        <p>
                            {% for blogpost in tag.blogpost_set.all %}
                                {{ blogpost.title }}
                            {% endfor %}
                        </p>
		改成:
			<p>
			    {% for blog_post in tag.blogpost_set.all %}
			        <a href="{% url 'blog_show' %}?blogId={{ blog_post.id }}">
			            {{ blog_post.title }}
			        </a>
			    {% endfor %}
			</p>
		web/templates/web/blog_list_by_tag.html:
	                <h4><a href="">{{ blog_post.title }}</a>({{ blog_post.create_time|date:'Y-m-d' }})</h4>
		改成:
			<h4><a href="{% url 'blog_show' %}?blogId={{ blog_post.id }}">
			       {{ blog_post.title }}
			    </a>
			    ({{ blog_post.create_time|date:'Y-m-d' }})
			</h4>
	重启网站服务器测试!! 
	成功!!!
	通过,blog_show.html 可以看到典型的网站设计规则
djanggo:相关内容
	符合 MVC 原则的框架: 模型 视图 控制, 但上述哪个建站过程,还不知怎么看出这个原则
	model学习:
		manytomanyfield 概念
		foreignkey 概念
		模型层次例子:
			from django.db import models		//引用 models类
			class Author(models.Model):
			    name = models.CharField(max_length=100)
			class Book(models.Model)
			    title = models.CharField(max_length=100)
			    genre = models.CharField(max_length=100)
			    num_pages = models.IntegerField()
			    authors = models.ManyToManyField(Author)	//book 与 author 关系
			    def _unicode_(self):	//什么作用 ???
			        return self.title
			    class Meta:			//镶嵌类,用于添加各种django属性功能
			        abstract =True		//表示这是个抽象类
			class SmithBook(Book):		//继承 book model 的smithbook model
			    authors = models.ManyToManyField(Author,limit_choices_to=(
			        'name_endswith': 'Smith'
			    ))				//表示 smithbook 这个model 的author量为指定固定值'smith'	
			//migrate 时, django 只创建 author 与 smithBook 两个表单,而smithbook继承book内容,
			//没有生成book表单,是因为 book是虚拟的
			//如果 book 没有class Meta -> abstract=True 这项时, 就会创建 author book,smithbook 三个表单,
			//而smithbook依然是继承book内容的 model
		理解 class Meta 的例子:
			class Person(models.Model):
			    first = models.CharField(max_length=100)
			    last = models.CharField(max_length=100)
			    middle = models.CharField(max_length=100)
			    class Meta:
			        ordering = {'first','middle','last'}	//表示显示,按 first middle last 次序显示
			        unique_together = {'first','middle','last'} //表示多个相同内容的对象成员,就不要重复显示出来了
				verbose_name_plural = "people"	//这里的verbose_name_plural就是在这个结构在管理页面里的展示名称 
			//但是最后 关于 ordering 如何配合 html 使用,还未知道!!!先不管!!
	url,路由,链接,显示的学习:
		关于selfweb/urls.py 的路径定义 url(),第一个参数是路径正则表达式
			r'^$'	//表示网站根地址: 如 http://127.0.0.1:8000/ ,^指网站根目录,即8000后的那个/, $表示匹配到此结束
			r'^bloglistbytag'	//都表示匹配 网站根目录+bloglistbytag $表示是匹配结束的地方,但这里可加可不加
			或者r'^bloglistbytag$'	//例如: http://127.0.0.1:8000/bloglistbytag?tagname=baby
						//表示匹配到了http://127.0.0.1:8000/bloglistbytag,
						//?tagname=baby 表示是这个匹配页的参数,不算入匹配内容
			r'bar'	//既嫩匹配到 http://127.0.0.1:8000/xxx/bar/kkk/ ,又能匹配到 http://127.0.0.1:8000/bar/lll/ 等等
				//又能匹配到 http://127.0.0.1:8000/sgbarp/uuuu/
				//所以 注意合理使用 ^ 符, 和 $ 符 的重要
		继续分析url() 的后两个参数,例子:
			views.py:
			def add(request):
			    a = request.GET['a']
			    b = request.GET['b']
			    c = int(a)+int(b)
			    return HttpResponse(str(c))
			def add2(request, a, b):
			    c = int(a) + int(b)
			    return HttpResponse(str(c))
			urls.py:
			    当 url(r'^add/$', views.add, name='first_add') 这样注册url,
			    	登陆 127.0.0.1/add/?a=4&b=5 时,得到页面输出 9 这个数字
			    当 url(r'^add/(\d+)/(\d+)/$', views.add2, name='second_add') 这样注册url,
			    	点击 <a href="/add/4/5/">计算 4+5</a> 的链接
				便登陆 127.0.0.1/add/4/5 时,得到页面输出 9 这个数字
				点击 <a href="{% url 'second_add' 4 5 %}">计算 4+5</a> 的链接,
				也能登陆 127.0.0.1/add/4/5 时,得到页面输出 9 这个数字	
	manage.py工具集学习:
		syncdb	//数据库同步 ,即,更改了数据库的表单配置什么的,需要更新数据库内容!!
			//重要的功能是 把 新的model 转化成 表单, 
			//但是,更新原来的model 或者会不会破坏已存在的数据条内容,还没实践过!!

javascript 简介:	
	javascript可写在 <head>段,或者<body>段
	注意javascript 自带一个基础框架库,可直接使用依稀基础函数,如果要使用其他框架库,例如jquery,就要加载框架
	javascript与 html 的接口 一般是指 onclick,onmouseover,onload,onchange,onmousout,onmousedown、onmouseup
JS HTML DOM 和浏览器BOM:
	其实就是我们上述认为的 javascript 自带一个基础框架库DOM,提供多种种函数动态改变 HTML 页内容,
	也可以改变 css内容
	浏览器BOM 提供的是与浏览器有关的 javascript 基础框架库
json学习:
	json是一种特殊的数据格式标准,方便各类语言引擎执行数据处理和网络传输,
	规范了大规模数据处理和传输,能直接被javascript直接处理,与javascript对象无缝转换
	但并不能说是javascript语法标准之一!!	
jquery学习:
	jquery是javascript 应用框架,网页使用前,需要加载框架
	<script src="https://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>
	一般选择使用远程框架文件,而不要选择本地框架文件
	然后下一个<script></script>内就可以填写jquery提供的执行函数了
	一般scropt脚本都会放在html的前部位置	
	jQuery 使用 $ 符号作为 jQuery 的简写,但是也有很多其他javascript使用$作为简写标识符号,
		这时可通过nocondflict()来释放简写符,让给其他框架,例如以下一段代码:
		<head>
		<meta charset="utf-8">
		<script src="https://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>
		<script>
		$.noConflict();
		jQuery(document).ready(function(){
		  jQuery("button").click(function(){
		    jQuery("p").text("jQuery 仍然在工作!");
		  });
		});
		</script>
		</head>
		您也可以创建自己的简写。noConflict() 可返回对 jQuery 的引用，您可以把它存入变量，以供稍后使用。例如:
		<script>
		var jq = $.noConflict();
		jq(document).ready(function(){
		  jq("button").click(function(){
		    jq("p").text("jQuery 仍然在工作!");
		  });
		});
		</script>	
	jquery选择器,其实就是 jqurey(xx) 或 $(xx) 中的xx变量格式:
		1.基本选择器
		$("#id")            //ID选择器
		$("div")            //元素选择器
		$(".classname")     //类选择器
		$(".classname,.classname1,#id1")     //组合选择器
		2.层次选择器
		$("#id>.classname ")    //子元素选择器
		$("#id .classname ")    //后代元素选择器
		$("#id + .classname ")    //紧邻下一个元素选择器
		$("#id ~ .classname ")    //兄弟元素选择器
		3.过滤选择器(重点)
		$("li:first")    //第一个li
		$("li:last")     //最后一个li
		$("li:even")     //挑选下标为偶数的li
		$("li:odd")      //挑选下标为奇数的li
		$("li:eq(4)")    //下标等于4的li
		$("li:gt(2)")    //下标大于2的li
		$("li:lt(2)")    //下标小于2的li
		$("li:not(#runoob)") //挑选除 id="runoob" 以外的所有li
		3.2内容过滤选择器
		$("div:contains('Runob')")    // 包含 Runob文本的元素
		$("td:empty")                 //不包含子元素或者文本的空元素
		$("div:has(selector)")        //含有选择器所匹配的元素
		$("td:parent")                //含有子元素或者文本的元素
		3.3可见性过滤选择器
		$("li:hidden")       //匹配所有不可见元素，或type为hidden的元素
		$("li:visible")      //匹配所有可见元素
		3.4属性过滤选择器
		$("div[id]")        //所有含有 id 属性的 div 元素
		$("div[id='123']")        // id属性值为123的div 元素
		$("div[id!='123']")        // id属性值不等于123的div 元素
		$("div[id^='qq']")        // id属性值以qq开头的div 元素
		$("div[id$='zz']")        // id属性值以zz结尾的div 元素
		$("div[id*='bb']")        // id属性值包含bb的div 元素
		$("input[id][name$='man']") //多属性选过滤，同时满足两个属性的条件的元素
		3.5状态过滤选择器
		$("input:enabled")    // 匹配可用的 input
		$("input:disabled")   // 匹配不可用的 input
		$("input:checked")    // 匹配选中的 input
		$("option:selected")  // 匹配选中的 option
		4.表单选择器
		$(":input")      //匹配所有 input, textarea, select 和 button 元素
		$(":text")       //所有的单行文本框，$(":text") 等价于$("[type=text]")，推荐使用$("input:text")效率更高，下同
		$(":password")   //所有密码框
		$(":radio")      //所有单选按钮
		$(":checkbox")   //所有复选框
		$(":submit")     //所有提交按钮
		$(":reset")      //所有重置按钮
		$(":button")     //所有button按钮
		$(":file")       //所有文件域
AJAX学习:
	AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。
	简短地说，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示。
	jQuery 提供多个与 AJAX 有关的方法:
	$(selector).load(URL,data,callback); 
	例如:	
		$("#div1").load("demo_test.txt"); 把文件 "demo_test.txt" 的内容加载到指定的 <div> 元素中
		$("#div1").load("demo_test.txt #p1");把 "demo_test.txt" 文件中 id="p1" 的元素的内容，加载到指定的 <div> 元素中：
		下面的例子会在 load() 方法完成后显示一个提示框。如果 load() 方法成功，显示"外部内容加载成功！"，否则，则显示错误消息：
		$("button").click(function(){
		  $("#div1").load("demo_test.txt",function(responseTxt,statusTxt,xhr){
		    if(statusTxt=="success")
		      alert("外部内容加载成功!");
		    if(statusTxt=="error")
		      alert("Error: "+xhr.status+": "+xhr.statusText);
		  });
		});
		
	$.get(URL,callback);	获取 URL 地址上 的内容
	$.post(URL,data,callback);	把data post到 URL地址上,服务器经过处理后,返回处理后的内容!!!
	还有关于处理XML典型操作,例如:
		先新建一个request:
			xmlhttp=new XMLHttpRequest();
		然后指定 递出请求然后从服务器所有数据后,执行的处理函数
 			xmlhttp.onreadystatechange=function()=function(){...}
		指出请求是获取一个文本:
			xmlhttp.open("GET","/try/ajax/ajax_info.txt",true);
		发出请求:
			xmlhttp.send();
	//传统情况:
	//	浏览器 登录网页,远程服务器把整页源码发来,浏览器解析源码显示
	//	浏览器用户提交表单, 远程服务器处理表单请求,重新解析出整页源码,
	//	服务器重新把新整页源码发过来,浏览器解析源码显示
	//使用ajax情况:
	//	浏览器 登录网页,远程服务器把整页源码发来,浏览器解析源码显示,其中一些变量,以一些占位符代替
	//	浏览器用户提交表单, 实际确实传递了处理请求,
	//	服务器处理请求,返回结果信息,结果信息填充了旧的整页源码中某个占位符,浏览器解析源码显示
	//显而易见,使用ajax的话,就避免了 服务器重新解析出整页源码,重新把新整页源码发过来 的耗时操作
	//ajax占位符操作示范例子为:
	//	替换占位符原有内容:
	//		整页源码某段内容 <xxx id="kkk">aaaaaaaa</xxx>,
	//		提交处理请求后,远程服务器返回 一段vvvvvv内容,替换id="kkk"的段内容,
	//		然后这段内容就变成 <xxx id="kkk">vvvvvv</xxx>
	//	填充占位符:
	//		整页源码某段内容 <hh id="ggg"></hh>,其实并每有实际内容
	//		提交处理请求后,远程服务器返回 一段momomomo内容,填到id="ggg"的段,
	//		然后这段内容就变成 <hh id="ggg">momomomo</hh>
	//	独一无二的占位符,其实就是对应独一无二的 id,号 与段头/尾标识无关,
	//		譬如说,上述来两例子的 占位符 与 段头/尾标识(xxx,hh) 无关系 只与 id有关
Node.js学习:
	是一个服务端javascript
	就是说,语法,使用javascript标准,但是就像python java 一样有一个解释机,
	写一个javascript脚本文档出来,可以通过node解释机执行!!!

css学习:
	css是一种网页样式脚本: 一般的写法是 在 <style></style> 句柄里添加脚本内容
	例如:
	<!DOCTYPE html>
	<html>
	<head>
	<meta charset="utf-8"> 
	<title>菜鸟教程(runoob.com)</title> 
	<style>
	h1		//这里设置 h1 标识段内容的 样式脚本
	{
		background-color:#6495ed;
	}
	p		//这里设置 p 标识段内容的 样式脚本
	{
		background-color:#e0ffff;
	}
	div		//这里设置 div 标识段内容的 样式脚本
	{
		background-color:#b0c4de;
	}
	</style>
	</head>
	
	<body>
	
	<h1>CSS background-color 实例!</h1>
	<div>
	该文本插入在 div 元素中。
	<p>该段落有自己的背景颜色。</p>
	我们仍然在同一个 div 中。
	</div>
	
	</body>
	</html>
正则表达式学习:
	常用搜索通配符:?和*,例如:
	像 data?.dat 这样的模式将查找下列文件：
		data1.dat
		data2.dat
		datax.dat
		dataN.da 
	使用 * 字符代替 ? 字符扩大了找到的文件的数量。data*.dat 匹配下列所有文件：
		data.dat
		data1.dat
		data2.dat
		data12.dat
		datax.dat
		dataXYZ.dat
	但是,正则表达式中 ? 和 * 与上述的用法有区别!!!!!!
	通用表达符:	
		.	//匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 。
		[ ]	//标记一个中括号表达式的开始。要匹配 [，请使用 \[。
		^	//匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。
		$	//匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。
			//要匹配 $ 字符本身，请使用 \$。
		?	//匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。
			//例如 colou?r 可以匹配 color 或者 colour，? 问号代表前面的字符最多只可以出现一次（0次、或1次）。
		+	//匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。
			//例如 runoo+b，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次）。
		*	//匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。
			//例如 runoo*b，可以匹配 runob、runoob、runoooooob 等，* 号代表字符可以不出现，
			//	也可以出现一次或者多次（0次、或1次、或多次）。
		{}	//标记限定符表达式的开始。要匹配 {，请使用 \{。
			//{n} 	n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。
			//{n,} 	n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，
			//	但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。
			//{n,m} m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。
			//	例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。
		|	//指明两项之间的一个选择。要匹配 |，请使用 \|。
		( )	//标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。
		\
			// \*   代表*符号本身!! \加符号时(?,>,*,&...)表示转义字符意思,
			// \cx 	匹配由x指明的控制字符。例如， \cM 匹配一个 ctrl+m(即回车符)。
			//	x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。
			// \f 	匹配一个换页符。等价于 \x0c 和 \cL。
			// \n 	匹配一个换行符。等价于 \x0a 和 \cJ。
			// \r 	匹配一个回车符。等价于 \x0d 和 \cM。
			// \s 	匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
			// \S 	匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
			// \t 	匹配一个制表符。等价于 \x09 和 \cI。
			// \v 	匹配一个垂直制表符。等价于 \x0b 和 \cK。
			// \b 	匹配一个字边界，即字与空格间的位置,或空格与字的位置
			// \B 	非字边界匹配。
	更加具体理论的 通用表达符说明 :	
		\ 	将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。
			例如，'n' 匹配字符 "n"。'\n' 匹配一个换行符。序列 '\\' 匹配 "\" 而 "\(" 则匹配 "("。
		^ 	匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。
		$ 	匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置。
		* 	匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。
		+ 	匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。
		? 	匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 中的"do" 。? 等价于 {0,1}。
		{n} 	n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。
		{n,} 	n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，
			但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。
		{n,m} 	m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。
			例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。
		? 	当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。
			非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。
			例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。
		. 	匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用像"(.|\n)"的模式。
		(pattern) 	匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，
				在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 '\(' 或 '\)'。
		(?:pattern) 	匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。
				这在使用 "或" 字符 (|) 来组合一个模式的各个部分是很有用。
				例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。
		(?=pattern) 	正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。
				这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。
				例如，'Windows (?=95|98|NT|2000)' 能匹配 "Windows 2000" 中的 "Windows" ，
				但不能匹配 "Windows 3.1" 中的 "Windows"。预查不消耗字符，
				也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
		(?!pattern) 	负向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。
				这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。
				例如'Windows (?!95|98|NT|2000)' 能匹配 "Windows 3.1" 中的 "Windows"，
				但不能匹配 "Windows 2000" 中的 "Windows"。预查不消耗字符，
				也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
		x|y 	匹配 x 或 y。例如，'z|food' 能匹配 "z" 或 "food"。'(z|f)ood' 则匹配 "zood" 或 "food"。
		[xyz] 	字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'。
		[^xyz] 	负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 "plain" 中的'p'、'l'、'i'、'n'。
		[a-z] 	字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。
		[^a-z] 	负值字符范围。匹配任何不在指定范围内的任意字符。例如，'[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。
		\b 	匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。
		\B 	匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。
		\cx 	匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。
			否则，将 c 视为一个原义的 'c' 字符。
		\d 	匹配一个数字字符。等价于 [0-9]。
		\D 	匹配一个非数字字符。等价于 [^0-9]。
		\f 	匹配一个换页符。等价于 \x0c 和 \cL。
		\n 	匹配一个换行符。等价于 \x0a 和 \cJ。
		\r 	匹配一个回车符。等价于 \x0d 和 \cM。
		\s 	匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
		\S 	匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
		\t 	匹配一个制表符。等价于 \x09 和 \cI。
		\v 	匹配一个垂直制表符。等价于 \x0b 和 \cK。
		\w 	匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。
		\W 	匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。
		\xn 	匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。
			例如，'\x41' 匹配 "A"。'\x041' 则等价于 '\x04' & "1"。正则表达式中可以使用 ASCII 编码。
		\num 	匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。
		\n 	标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。
			否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。
		\nm 	标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。
			如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。
			如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。
		\nml 	如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。
		\un 	匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。
	表达符号的优先级:(从高到低排)
		\ 				转义符
		(), (?:), (?=), [] 		圆括号和方括号
		*, +, ?, {n}, {n,}, {n,m} 	限定符
		^, $, \任何元字符、任何字符 	定位点和序列（即：位置和顺序）
		| 				替换，"或"操作
						字符具有高于替换运算符的优先级，使得"m|food"匹配"m"或"food"。
						若要匹配"mood"或"food"，请使用括号创建子表达式，从而产生"(m|f)ood"。
		(注意,同级别的,从左到右进行运算) 
	实战:
		/Chapter [1-9][0-9]*/	//注意 需要用前后的"/"符号包住中间的正则表达式,是一种规范写法!!
					//这表达式表示除了匹配 Chapter 1  至  Chapter 99 的范围,还有例如可匹配到
					//Chapter 133 , Chapter 288888 , chapter 5777777777 , 等这些奇怪的字符串 	
		/Chapter [0-9]{1,2}/	//这表达式表示只匹配 Chapter 0  至  Chapter 99 的范围!!!
		/Chapter [1-9][0-9]?/		//这表达式表示 Chapter 1  至  Chapter 99 的范围!!!
		/Chapter [1-9][0-9]{0,1}/	//这表达式表示 Chapter 1  至  Chapter 99 的范围!!!
		/<.*>/		//下面的表达式匹配从开始小于符号 (<) 到关闭 H1 标记的大于符号 (>) 之间的所有内容
				//	即可以匹配整句 <H1>Chapter 1 - 介绍正则表达式</H1>	
				//注意,这里的 * 是指后接0个或多个 . 表达式符,即后接0个或多个任意字符,所以可以匹配整句,
		/<.*?>/		//这里 学习 最少匹配概念, *? 或者 +? 都是最小匹配组合符!!!
				//比如 	<H1>Chapter 1 - 介绍正则表达式</H1>,
				//这里 就只会匹配到 <H1> 而已, 而不会匹配整句!!!
		/<\w+?>/	//同样也是最少匹配 , <H1>Chapter 1 - 介绍正则表达式</H1>, 一句,只会匹配到 <H1> 而已
				// \W 也表示字符类, 与 . 是一样的意思
		/\bCha/		//可以匹配到单词 Chapter 的Cha 
		/ter\b/		//可以匹配到单词 Chapter 的ter
		/\Bapt/		//可以匹配到单词 Chapter 的apt ,但不能匹配单词 aptitude 中的字符串 apt
	javascript实战:
		1,
		<script>
		var str = "Is is the cost of of gasoline going up up";
		var patt1 = /\b([a-z]+) \1\b/ig;
		document.write(str.match(patt1));
		</script>
		//  /\b([a-z]+) \1\b/ig 匹配出 Is is,of of,up up 并显示
		//第一个\b 是空格与字符的字边界,第二个\b 是字符与控股的边界
		// ([a-z]+) 很明显指的是 Is is of up
		// \1 指的是第一个子匹配项 即 ([a-z]+)
		// 没有 后面的ig时, /\b([a-z]+) \1\b/ 只会匹配到 Is is 一条!!!!
		// i只不区分大小写,g指全局, 全局指最多次遍历匹配, 于是把 of of,up up 这两条也匹配出来!!!
		// 最终得到一个包含两个数据的数组:
		//	patt1[0] = "Is is,of of,up up"
		//	patt1[1] = "up"
		2,
		<script>
		var str = "http://www.runoob.com:80/html/html-tutorial.html";
		var patt1 = /(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/;
		arr = str.match(patt1);
		for (var i = 0; i < arr.length ; i++) {
		    document.write(arr[i]);
			document.write("<br>");
		}
		</script>
		// /(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/ 完全匹配 http://www.runoob.com:80/html/html-tutorial.html
		// (\w+):\/\/	匹配出 	http://    其中 (\w+)匹配出http
		// ([^/:]+)  中 [^/:] 的^在这里并没有开头的意思,但 ^/: 指从此处开始,匹配不包括 / 和 : 这两个符号的意思
		//	所以,这时+相当于 一个或多个[^/:] 的意思,于是 连续匹配了 www.runoob.com,
		//	遇到:的时候,^/:不满足,所以打住了,
		//	所以 ([^/:]+) 匹配了 www.runoob.com
		//(:\d*)?	匹配出 :80 , 
		//	首先 / 和 : 符号在正则方程里就是纯粹 / 和 : 符号, 没有其他意思,也不需要使用转义字符 \ 去表达,
		//	\d 就是匹配 数字,\d* 就是匹配任意位数的数字
		//	?  就是指 0个或1个 (:\d*) , 于是就匹配出了  :80
		//([^# ]*)	匹配出	/html/html-tutorial.html 
		//	[^# ] 表示 匹配不包括 # 字符
		//	* 表示 0个或者多个 [^# ] 所以最终匹配出/html/html-tutorial.html
		// 最终得到一个包含多个数据的数组:
		//	arr[0] = "http://www.runoob.com:80/html/html-tutorial.html"
		//	arr[1] = "http"
		//	arr[2] = "www.runoob.com"
		//	arr[3] = ":80"
		//	arr[4] = "/html/html-tutorial.html"
		//所以注意到, js 会把 正则表达式的 () 子表达式匹配出的内容也会保存起来!!!!!
	注意区分:
		^once 和 [^once] ,前者是,匹配出一个开头是once字符串内容的句,
				  后者是,匹配当前字符中不能是 c,e,n,o 其中之一!!!	
	在线实验网址: https://c.runoob.com/front-end/854 (非常好用)
		     https://c.runoob.com/
html5 学习:
	并没有太难的!!!
	主要是video 和数据库的接口重点看看
MangoDB(分布式文件存储的数据库,有别与Mysql):
	manggo 的shell 命令操作是符合javascript语言标准
	而Mysql的shell 命令操作是基于 一整套sql语法!!
	mangoDB 的每条数据条格式与 json相似 例如:
		{"site":"www.baidu.com"}
		{"site":"www.google.com","name":"Google"}
		{"site":"www.runoob.com","name":"菜鸟教程","num":5}
	与sql比较!!!
		SQL术语/概念 	MongoDB术语/概念 	解释/说明
		database 	database 	数据库
		table 	collection 	数据库表/集合
		row 	document 	数据记录行/文档
		column 	field 	数据字段/域
		index 	index 	索引
		table joins 	  	表连接,MongoDB不支持
		primary key 	primary key 	主键,MongoDB自动将_id字段设置为主键
	Capped collections 就是固定大小的collection	
	在MongoDB数据库中名字空间 <dbname>.system.* 是包含多种系统信息的特殊集合(Collection)，如下:
		集合命名空间		 	描述
		dbname.system.namespaces 	列出所有名字空间。
		dbname.system.indexes 		列出所有索引。
		dbname.system.profile 		包含数据库概要(profile)信息。
		dbname.system.users 		列出所有可访问数据库的用户。
		dbname.local.sources 		包含复制对端（slave）的服务器信息和状态。		
	MongoDB 数据类型
		数据类型 	描述
		String		字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。
		Integer		整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。
		Boolean		布尔值。用于存储布尔值（真/假）。
		Double		双精度浮点值。用于存储浮点值。
		Min/Max keys	将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。
		Arrays		用于将数组或列表或多个值存储为一个键。
		Timestamp	时间戳。记录文档修改或添加的具体时间。
		Object		用于内嵌文档。
		Null		用于创建空值。
		Symbol		符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。
		Date		日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。
		Object ID	对象 ID。用于创建文档的 ID。
		Binary Data	二进制数据。用于存储二进制数据。
		Code		代码类型。用于在文档中存储 JavaScript 代码。
		Regular expression	正则表达式类型。用于存储正则表达式。
	启动mangoDB服务:
		mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]
			mongodb:// 这是固定的格式，必须要指定。
			username:password@ 可选项，如果设置，在连接数据库服务器之后，驱动都会尝试登陆这个数据库
			host1 必须的指定至少一个host, host1 是这个URI唯一要填写的。
使用用户名fred，密码foobar登录localhost的baz数据库。

mongodb://fred:foobar@localhost/baz				它指定了要连接服务器的地址。如果要连接复制集，请指定多个主机地址。
			portX 可选的指定端口，如果不填，默认为27017
			/database 如果指定username:password@，连接并验证登陆指定数据库。若不指定，默认打开 test 数据库。
			?options 是连接选项。如果不使用/database，则前面需要加上/。
				所有连接选项都是键值对name=value，键值对之间通过&或;（分号）隔开 
		例子:
			使用用户名fred，密码foobar登录localhost的baz数据库。
			mongodb://fred:foobar@localhost/baz







20170815
使用GNUroot dbian:
手机装kali 工具: 
	https://github.com/LionSec/katoolin/issues?page=3&q=is%3Aissue+is%3Aopen
	https://mp.weixin.qq.com/s/Safyp-WpK6OzyvJbaHmJOA
	问题1:
	katoolin unable to locate package:未解,虽然尝试改 sources.list
	相关sources.list内容	
	deb http://http.kali.org/kali kali-rolling main contrib non-free
	# For source package access, uncomment the following line
	# deb-src http://http.kali.org/kali kali-rolling main contrib non-free
	deb http://http.kali.org/kali sana main non-free contrib
	deb http://security.kali.org/kali-security sana/updates main contrib non-free
	# For source package access, uncomment the following line
	# deb-src http://http.kali.org/kali sana main non-free contrib
	# deb-src http://security.kali.org/kali-security sana/updates main contrib non-free
	deb http://old.kali.org/kali moto main non-free contrib
	# For source package access, uncomment the following line
	# deb-src http://old.kali.org/kali moto main non-free contrib
手机装 metaspoilt 工具: 
	msfinstall perssion deny 怀疑缺库!!!!
	ldd msfinstall 不能查看依赖库,怀疑执行文件不是符合 armhf 硬件框架 
	最终发现是 chmod 没有起作用!!!,所以唉,什么都做不了
	不用傻瓜方法,先试试github方法!!
	rm -r metaspoilt 	//把原来的metaspoilt项目文件夹档案全删除!!	
	//不行,取不到chmod的权限,就不能正常使用.sh文件
	
装桌面 Xserver
	先 google play 安装个XServer XSDL 框架
	然后GNUboot:
		apt-get grade	//本想更新一下库的,居然搞出个大libc6兼容的问题出来!!!
		apt-get install lxde		
		卧槽,出错了: 之前的upgrade 把libc6弄乱了,现在都出这么一句 libc-bin: depends: xxxx is installed 之类
		仅仅 apt-get -f install 未能修复上述问题
		原因是从kali-rolling 那更新了 libc-dev-bin  libc6-dev 但唯独就是更新libc6 时失败了!!!!
		而因为后面操作 libc-dev-bin  libc6-dev 需要高版本的 libc6,由于libc6版本每更新所以失败!!!!
		之前upgrade时,libc6 half-install了,
		解决(重装libc6旧版本): 
				先sources.list把 kali-rolling 数据源去掉!!,然后
				apt-get autoclean
				apt-get update
				apt-get upgrade 
				apt-get install --reinstall libc6=2.19-18+deb8u10  //关键 重装旧版本libc6 
		至此搞定了 libc6 兼容问题,开始今天的主题:安装lxde桌面环境到手机上!!!
		apt-get install auto-apt  //先装auto-apt工具,因为,安装lxde需要各种依赖包,但是命令 apt-get install lxde 不会自动安装依赖包
		auto-apt run apt-get install lxde     //命令格式 auto-apt run [command]	这样就可以自动把依赖包都加上!!!
		然后 至少给装上一个图形界面的终端 Xterm apt-get install xterm
		然后打开 XServer XSDL 查看最后蓝屏指导的命令行
		然后在 GNUboot 上输入添加蓝屏全局变量的命令: export DISPLAY:=0 PLUSE_SERVER=top:127.0.0.1:4712
		然后在 GNUboot 执行: startlxde &
		回到 XServer XSDL 就进入了桌面系统了!
		






20170823
metasploit
	metasploit 是一个 工具框架,打开 metasploit-framework 或者终端输入 msfconsole后,便转到专门的msf终端, msf>
	armitage是metasploit的图形交互版本,使用armitage前 先打开 metasploit-framework
	msf的shell 命令 : 一般说,进入msf终端 手动执行msf命令,不实际,现实更趋向打包msf命令成一个shell命令,写入shell脚本执行例如:
	./msfconsole -x "use exploit/windows/smb/ms08_067_netapi; set RHOST [IP]; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST [IP]; run; exit"  	//这里 -x 参数就是一参数表示:打包msf命令成一个shell命令,然后执行!!
	metasploitable 是一个靶机系统,各种公开的漏洞可供使用!!!
netifera:
	Installation of Netifera
		$ cd /usr/src/
		$ wget http://netifera.com/download/netifera-1.0-linux.gtk.x86.zip
		$ unzip netifera-1.0-linux.gtk.x86.zip
		$ mkdir -p /pentest/scanners/
		$ mv netifera /pentest/scanners/
burp:抓包
靶机:
	metasploitable 是一个靶机系统,各种公开的漏洞可供使用!!!
	天人文章管理系统 整网站源码!!









20170830
linux 常用命令汇总: http://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html
命令查看帮助:
	模查找命令:		man -k clea	//模糊查找含clea字符的命令 
	whatis 参看命令简述L: 	whatis ls
	which 查看命令位置:	which ls 
	man  查看命令详细:	man ls
	man是一本命令说明书:分9章:
		(1)、用户可以操作的命令或者是可执行文件
		(2)、系统核心可调用的函数与工具等
		(3)、一些常用的函数与数据库
		(4)、设备文件的说明
		(5)、设置文件或者某些文件的格式
		(6)、游戏
		(7)、惯例与协议等。例如Linux标准文件系统、网络协议、ASCⅡ，码等说明内容
		(8)、系统管理员可用的管理条令
		(9)、与内核有关的文件
	综合使用案例:
		$whatis printf
		printf               (1)  - format and print data
		printf               (1p)  - write formatted output
		printf               (3)  - formatted output conversion
		printf               (3p)  - print formatted output
		printf [builtins]    (1)  - bash built-in commands, see bash(1)		
		我们看到printf在分类1和分类3中都有；分类1中的页面是命令操作及可执行文件的帮助；
		而3是常用函数库说明；如果我们想看的是C语言中printf的用法，可以指定查看分类3的帮助：
		$man 3 printf
寻找文件 find/locata
	find是实时查找:
	$find ./ -name "core*" | xargs file	//搜寻文件或目录
	$find ./ -name '*.o'		//查找目标文件夹中是否有obj文件
	$find ./ -name "*.o" -exec rm {} \;		//递归当前目录及子目录删除所有.o文件:
	如果需要更快的查询，可试试locate；locate会为文件系统建立索引数据库，如果有文件更新，需要定期执行更新命令来更新索引库:
	$locate string	//寻找包含有string的路径
	$updatedb	//更新索引数据库, 需要更新数据库，以获得最新的文件索引信息。
查看文件内容:
	查看文件：cat vi head tail more
	$cat -n	xxx	//显示xxx文件内容时,同时显示行号
	$ls -al | more		//按页显示列表内容
	$head -n 10 xxx		//只看xxx文件前10行
	$head -1 xxx		//只显示xxx文件第一行
	$tail -5 xxx	//显示xxx文件倒数第五行
	$diff file1 file2	//查看两个文件间的差别
	$tail -f xxx		//动态显示文本最新信息
	egrep '裁切' pcb画图经验	//查找 'pcb画图经验' 文件里的 '裁切' 内容所在行
批命令书写格式:
	批处理命令连接执行，使用 |
	串联: 使用分号 ;
	前面成功，则执行后面一条，否则，不执行:&&
	前面失败，则后一条执行: ||
	ls /proc && echo  suss! || echo failed.	//先ls /proc 成功便执行echo suss! 否则执行 echo failed
	与上述相同效果的是:
	if ls /proc; then echo suss; else echo fail; fi
	重定向:
	ls > kkk	//把ls得到的标准输出内容重定向到 kkk文件里 而不是终端屏幕
	ls &> kkk	//把ls得到的标准输出 和标准错误的内容 都重定向到 kkk文件里, 而不是显示到终端屏幕
	:> kkk		//清空kkk文件里的内容
	echo aa >> kkk	//把 aa 这个标准输出的内容 重定向添加到 kkk 文件里
	echo aa > kkk	//把 aa 这个标准输出的内容 重定向并且完全替换 kkk 文件的所有内容!!
	综合案例:
	cat pcb画图经验 | grep pcb | grep -v '!!' | wc -l	
	//先cat pcb画图经验 显示所有内容到标准输出文件, 
	//然后, grep pcb 从标准输出文件里 筛选所有含 pcb 的内容行,覆盖标准输出文件
	//然后, grep -v '!!' 从标准输出文件里 筛选所有含 !! 的内容行去掉,剩下的 重新覆盖标准输出文件
	//然后, wc -l 统计标准输出文件里有多少行内容,得到的结果 重新覆盖标准输出文件 
	//最后,标准输出文件 的内容 全部 发送到终端屏幕, 标准输出文件自身被清空!!
终端快捷键:
	shift + ctrl + C/V	//复制粘贴
	ctrl + U	//删光 整行 已输入的命令行字符 (注意只能删单行内容,即使使用\符号组合的多单行组合命令字符,也只能删光标所在单行)
	ctrl + W	//删字符串内容至 最近的空格
文本处理:
	find 文件查找
	find . \( -name "*.txt" -o -name "*.pdf" \) -print	//查找txt和pdf文件,'.'指当前路径
	find . -name ".h" -o ! \( -name "*.txt" -o -name "*.pdf" -o -name "*.c"  \)  //查找h文件,但排除txt,pdf,c文件
	find . -regex  ".*\(\.txt|\.pdf\)$"	//正则方式查找.txt和pdf	补充:-iregex： 忽略大小写的正则
	find . ! -name "*.txt" -print		//否定参数 "!" ,查找所有非txt文本:
	find . -maxdepth 1 -type f	//指定搜索深度,打印出当前目录的文件（深度为1）
	定制搜索
	find . -type d -print  //只列出所有目录	补充:-type f 文件, -type l 符号链接, -type d 目录
	//find支持的文件检索类型可以区分普通文件和符号链接、目录等，但是二进制文件和文本文件无法直接通过find的类型区分出来；
	file命令可以检查文件具体类型（二进制或文本）:
	$file xxx  //识别二进制文件
		xxxi: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), 
	for GNU/Linux 2.6.9, not stripped
	$file kkk  //识别文本文件
	kkk: ASCII text
	所以,可以用以下命令组合来实现查找本地目录下的所有二进制文件:
		ls -lrt | awk '{print $9}'|xargs file|grep  ELF| awk '{print $1}'|tr -d ':'
	按时间搜索
            -atime 访问时间 (单位是天，分钟单位则是-amin，以下类似）
            -mtime 修改时间 （内容被修改）
            -ctime 变化时间 （元数据或权限变化）
	find . -atime 7 -type f -print		//最近 第7天 被访问过的所有文件
	find . -atime -7 -type f -print		//最近 7天内 被访问过的所有文件
	find . -atime +7 type f -print		//查询 7天前 被访问过的所有文件
	按大小搜索：
	find . -type f -size +2k	//寻找大于2k的文件  补充: w(字=word=32bits) k(kb) M(mb) G(gb) 
	按权限查找:
	find . -type f -perm 644 -print //找具有可执行权限的所有文件
	按用户查找:
	find . -type f -user weber -print// 找用户weber所拥有的文件
	找到后的后续动作
	find . -type f -name "*.swp" -delete		//删除当前目录下所有的swp文件
	find . -type f -name "*.swp" | xargs rm		//删除当前目录下所有的swp文件
	find . -type f -user root -exec chown weber {} \;	//将当前目录下的所有权变更为weber, 执行动作（强大的exec）
								//注：{}是一个特殊的字符串，对于每一个匹配的文件，{}会被替换成相应的文件名
	find . -type f -mtime +10 -name "*.txt" -exec cp {} OLD \;	//将找到的文件全都copy到另一个目录
	结合多个命令
	//-exec ./commands.sh {} \    :如果需要后续执行多个命令，可以将多个命令写成一个脚本。然后 -exec 调用时执行脚本即可:
	-print的定界符		
	//默认使用’\n’作为文件的定界符； -print0 使用’\0’作为文件的定界符，这样就可以搜索包含空格的文件；
	grep 文本搜索
	grep hllo kkk //grep最简单,不严谨的默认命令, 从 kkk文件 中搜索 hello 的字符内容, 
	常用参数
	-o 只输出匹配的文本行 VS -v 只输出没有匹配的文本行
	-c 统计文件中包含文本的次数	// grep -c “text” filename
	-n 打印匹配的行号
	-i 搜索时忽略大小写
	-l 只打印文件名
	grep "class" . -R -n	//在多级目录中对文本递归搜索(程序员搜代码的最爱）
	grep -e "class" -e "vitural" kkk	//匹配kkk文件里的多个搜索项,
	grep "test" file* -lZ| xargs -0 rm	//grep输出以0作为结尾符的文件名（-z）	(未用过,涉及rm 需要比较谨慎)
	cat LOG.* | tr a-z A-Z | grep "FROM " | grep "WHERE" > b	//综合应用：将日志中的所有带where条件的sql查找查找出来:
	查找中文示例：(未成功)
		工程目录中utf-8格式和gb2312格式两种文件，要查找字的是中文
    		查找到它的utf-8编码和gb2312编码分别是E4B8ADE69687和D6D0CEC4
		查询:
		grep：grep -rnP "\xE4\xB8\xAD\xE6\x96\x87|\xD6\xD0\xCE\xC4" *即可
		汉字编码查询：http://bm.kdd.cc/
	xargs 命令行参数转换
	xargs 能够将输入数据转化为特定命令的命令行参数；这样，可以配合很多命令来组合使用。比如grep，比如find； - 将多行输出转化为单行输出
	cat xxx| xargs	//这里是把 xxx 文件输出到 标准输出文件,然后把标准输出文件里的内容全部看作为一行 参数 然后print出 
	cat single.txt | xargs -n 3	//将单行转化为多行,然后print出 -n：指定每行显示的字段数,
					//即把一整行内容分成多行输出,每行显示三段内容,每段内容由源文档固有的空格或者回车做分割
	xargs参数说明
		d 定义定界符 （默认为空格 多行的定界符为 n）
		-n 指定输出为多行
		-I {} 指定替换字符串，这个字符串在xargs扩展时会被替换掉,用于待执行的命令需要多个参数时
		-0：指定0为输入定界符
	cat file.txt | xargs -I {} ./command.sh -p {} -1	//具体未测试过
	find source_dir/ -type f -name "*.cpp" -print0 |xargs -0 wc -l	//统计程序行数
	./redis-cli smembers $1  | awk '{print $1}'|xargs -I {} ./redis-cli get {}  
		//综合例子:redis通过string存储数据，通过set存储索引，需要通过索引来查询出所有的值
	sort 排序
	字段说明
		-n 按数字进行排序 VS -d 按字典序进行排序
		-r 逆序排序
		-k N 指定按第N列排序
	sort -nrk 1 kkk		//把文档每行按照 条件重新排序,然后显示出来
	sort -bd data 		//忽略像空格之类的前导空白字符
	sort unsort.txt | uniq	//先是重新排序,然后排序后的内容放入 标准输出文件, 然后在标准输出文件里 消除重复行, 最后显示
	sort unsort.txt | uniq -c	//统计各行在文件中出现的次数
	sort unsort.txt | uniq -d	//找出重复行
	//补充:uniq 命令中可指定每行中需要比较的重复内容的参数：-s 开始位置 -w 比较字符数 (没有例子)	
	tr命令
	echo 12345 | tr '0-9' '9876543210' //加解密转换，替换对应字符
	cat text| tr '\t' ' '  		//制表符转空格
	cat file | tr -d '0-9' 		// 删除所有数字
	cat file | tr -c '0-9' 		//获取文件中所有数字
	cat file | tr -d -c '0-9 \n'  	//删除非数字数据
	cat file | tr -s ' '		//tr -s 压缩文本中出现的重复字符；最常用于压缩多余的空格:
	tr中可用各种字符类：
		alnum：字母和数字
		alpha：字母
		digit：数字
		space：空白字符
		lower：小写
		upper：大写
		cntrl：控制（非可打印）字符
		print：可打印字符
		使用方法：tr [:class:] [:class:]
		tr '[:lower:]' '[:upper:]'	//把 upper 转 lower
	cut -f2,4 filename		//截取文件的第2列和第4列
	cut -f3 --complement filename	//去文件除第3列的所有列
	cat -f2 -d";" filename		//-d 指定定界符
	cut 取的范围
		N- 第N个字段到结尾
		M 第1个字段为M
		N-M N到M个字段
	cut 取的单位
		-b 以字节为单位
		-c 以字符为单位
		-f 以字段为单位（使用定界符）
	cut -c1-5 file 			//打印第一到5个字符
	cut -c-2 file  			//打印前2个字符
	$echo string | cut -c5-7	//截取文本的第5到第7列
	将两个文本按列拼接到一起;
		$ cat file1
		1
		2
		$ cat file2
		colin
		book		
		$ paste file1 file2	//	paste 按列拼接文本
		1 colin
		2 book
		$ paste file1 file2 -d ","	//默认的定界符是制表符，可以用-d指明定界符:
		1,colin
		2,book
	wc -l file 	// 统计行数
	wc -w file 	// 统计单词数
	wc -c file 	// 统计字符数
	sed 's/text/replace_text/' file   //替换 每一行的 第一处匹配的text,替换换成replace_text ,然后print,注意并不会改写 原file文件
	sed 's/text/replace_text/g' file  //替换 每一行的   所有的text,	  替换换成replace_text ,然后print,注意并不会改写 原file文件
	sed -i 's/text/repalce_text/g' file	//默认替换后，输出替换后的内容，如果需要直接替换原文件,使用-i:
	sed '/^$/d' file	//移除空白行 然后print出
	sed 's/text/\ &++++\ /g' kkk	// & 引用符号, 这里 &引用内容就是 匹配内容text, 这里把所有 "text" 转换成 "\ &++++\ "
					//即 text 转换成 [空格]text++++[空格], 注意,这里的 "\ ",表示的是空格
	变量转换 (未证实例子)
		echo this is en example | sed 's/\w+/[&]/g'	//已匹配的字符串通过标记&来引用.
		$>[this]  [is] [en] [example]		
	sed 's/hello\([0-9]\)/\1/'	//例如 例子:hello39878,其中 hello\([0-9]\) 匹配的是hello3,即 \([0-9]\) 匹配到的是3
					//然后 \1,指的是那个 \([0-9]\) , 即hello3 被替换成3  
	sed 's/hello\([0-9]\)\([0-9]\)/\2\1/' kkk	//扩展知识,例子: hello39878
							//hello\([0-9]\)\([0-9]\) 匹配到 hello39
							//第一个\([0-9]\)\ 匹配的是3,所以 \1 指的是3
							//第二个\([0-9]\)\ 匹配的是9,所以 \2 指的是9
							//hello\([0-9]\)\([0-9]\) 被替换成 \2\1,即 hello39 被替换成 93
	sed 引号关系:
		p=patten
		echo pattenjjk_\$p | sed 's/$p/zzz/'	//单引号: $参数符号不起作用 得到 pattenjjk_zzz
		echo pattenjjk_\$p | sed "s/$p/zzz/" 	//双引号: $参数符号起作用 得到 zzzjjk_$p
	sed 's/^.\{3\}/&\//g' kkk	//把kkk文件 每行 的前三个任意字符  ^.\{3\} ,被 &\/ 替换
					//& 引用的是 ^.\{3\} ,结果例子如下:
					//替换前:		替换后:
					//llllllllll		lll/lllllll
					//abcdefghij		abc/defghij
					//popopopopo		pop/opopopo
	awk 数据流处理工具:
	awk最简单脚本结构
		awk ' BEGIN{ statements } statements2 END{ statements } ' file
		工作方式
		1.执行begin中语句块；
		2.从文件或stdin中读入一行，然后执行statements2，重复这个过程，直到文件全部被读取完毕；
		3.执行end语句块；
	echo -e "line1\nline2" | awk 'BEGIN{print "start"} {print } END{ print "End" }'	//使用不带参数的print时，会打印当前行
	print 的综合例子:
		echo | awk ' {var1 = "v1" ; var2 = "V2"; var3="v3"; \		
		print var1, var2 , var3; }'
		//上述实为 一行命令,通过 \ 符号分两行写, 上述 awk 并没有执行 begin 和 end 两段内容!!
		//echo 输出了 空白 的内容到 标准输出文件,虽然内容空白, 但标准输出文件"名义上"还是有一行内容的
		//awk 读取这行内容, 然后执行 var1 = "v1" ; var2 = "V2"; var3="v3"; print var1, var2 , var3; 这组;号分割的命令
		//屏幕输出:v1 V2 v3
		echo hello | awk ' {var1 = "v1" ; var2 = "V2"; var3="v3"; print var1, var2 , var3; }'
		//屏幕依然输出:v1 V2 v3
		//这时,虽然 标准输出文件已经有 hello 这串字符,awk 也引入了一行费空白的内容,
		//但是这时,print 带参数, 但没有一个参数指向 awk引入行的内容,所以 print 出的内容 并没有 hello 
		echo | awk ' {var1 = "v1" ; var2 = "V2"; var3="v3"; print var1"-"var2"-"var3; }'  
		//使用-拼接符的方式（”“作为拼接符）;
		//屏幕输出:v1-V2-v3
	特殊变量： NR NF $0 $1 $2
		NR:表示记录数量，在执行过程中对应当前行号；
		NF:表示字段数量，在执行过程总对应当前行的字段数；
		$NF:表示当前行的最后一字段的文本内容;
		$0:这个变量包含执行过程中当前行的文本内容；
		$1:第一个字段的文本内容；
		$2:第二个字段的文本内容；
		$3:.....
	echo -e "line1 f2 f3\n line2 \n line 3" | awk '{print NR":"$0"-"$1"-"$2}'
		//屏幕输出:
		//	1:line1 f2 f3-line1-f2
		//	2: line2 -line2-
		//	3: line 3-line-3
	awk '{print $2, $3}' file	//打印每一行的第二和第三个字段
	awk ' END {print NR}' file	//统计文件的行数
	echo -e "1\n 2\n 3\n 4\n" | awk 'BEGIN{sum = 0 ; print "begin";} {sum += $1;} END {print "=="; print sum }'	
		//累加每一行的第一个字段
	传递外部变量
		输入来自stdin:
			var=1000
			echo | awk '{print vara}' vara=$var // 注意shell上手动设的变量都暂时放在 标准输入文件
		输入来自文件
			awk '{print vara}' vara=$var file
	awk扩展结构,用样式对awk处理的行进行过滤
		awk 'NR < 5' 			//行号小于5
		awk 'NR==1,NR==4 {print}' file 	//行号等于1和4的打印出来
		awk '/linux/' 			//包含linux文本的行（可以用正则表达式来指定，超级强大）
		awk '!/linux/' 			//不包含linux文本的行
	awk -F : '{print $NF}' /etc/passwd 	//使用-F来设置定界符（默认为空格) 而这里的定界符是 ":"
						//-F : 是 针对 $NF的,
						//例如某一行内容是  games:x:5:60:games:/usr/games:/usr/sbin/nologin
						//:界定符 把整行内容划分成 6 个字段段内容:
						// games, x, S, 60, games, /usr/games:/usr/sbin/nologin
						//$NF 指即保留并print出最后一个字段 /usr/games:/usr/sbin/nologin
						//如果 -F : 改为 bin, 那么界定符就是 bin,
						//把整行内容划分成 2 个字段段内容:
						// games:x:5:60:games:/usr/games:/usr/s, /nologin
						//那么只保留bin后的内容,即print出: /nologin
	echo | awk '{"grep root /etc/passwd" | getline cmdout; print cmdout }'	
		//使用getline，将外部shell命令的输出读入到变量cmdout中:
		//这里,把grep 得到的 多行内容 的 第一行内容 getline 读入到 awk里,然后print出
	在awk中使用循环
		awk '{ for(i=0;i<10;i++){print i ;}; }'	//成功例子
		for(i=0;i<10;i++){print $i;}		//未测试例子
		for(i in array){print array[i];}	//未测试例子
	综合例子:
		echo '2015_04_02 20:20:08: mysqli connect failed, please check connect info'| \
		awk -F : '{ for(i=1;i<=3;i++) printf("%s:",$i)}'
			//echo 一行内容到 标准输出文件
			//以 :为界定符号分出 4 个字段: 
			//	2015_04_02 20
			//	20
			//	08
			//	[空格]mysqli connect failed, please check connect info
			//循环print出 第一,第二,第三个字段 最终print出:  2015_04_02 20:20:08:
			//这种方式会将最后一个冒号打印出来
		echo '2015_04_02 20:20:08: mysqli connect failed, please check connect info'|awk -F':' '{print $1 ":" $2 ":" $3; }'
			//最终print出: 2015_04_02 20:20:08  
			//比上一个方法好.
		echo '2015_04_02 20:20:08: mysqli connect failed, please check connect info'| \
		awk -F':' '{print $1 ":" $2 ":" $3; print $4;}'
			//这个就分别print出两行内容:
			//	2015_04_02 20:20:08
			//	mysqli connect failed, please check connect info
		seq 9| awk '{lifo[NR] = $0; lno=NR} END{ for(;lno>-1;lno--){print lifo[lno];}} '
			//以逆序的形式打印行：(tac命令的实现）:
			//seq 9 输出:
			//	1
			//	2
			//	3
			//	4
			//	5
			//	6
			//	7
			//	8
			//	9
			//也就说,seq,输出9行内容到 标准输出文件,
			//awk '{lifo[NR] = $0; lno=NR} END{ for(;lno>-1;lno--){print lifo[lno];}} ' 处理9行内容后,覆盖标准输出文件
			//最后print得:
			//	9
			//	8
			//	7
			//	6
			//	5
			//	4
			//	3
			//	2
			//	1
	ps -fe| grep msv8 | grep -v MFORWARD | awk '{print $2}' | xargs kill -9;	//awk结合grep找到指定的服务，然后将其kill掉
	awk 'NR<=10{print}' filename	//相当于 head命令
	awk '{buffer[NR%10] = $0;} END{for(i=0;i<11;i++){ print buffer[i %10]} } ' filename	//相当于 tail命令
	ls -lrt | awk '{print $6}'	//相当于打印指定列
	ls -lrt | cut -f6		//相当于cut方式实现
	cat kkk	| awk 'NR==4,NR==30{print}'	//print出kkk文件的第 4 - 30 行的 内容.
	awk '/start_pattern/, /end_pattern/' filename	//打印含start_pattern的行 直到 含end_pattern的行 的文本.
	seq 100 | awk '/13/,/15/'	//例子 注意,这里 把 {print}一步 也省略了, 但是结果一样的
	cat /etc/passwd| awk '/mai.*mail/,/news.*news/' //例子 
	awk常用内建函数
		index(string,search_string):返回search_string在string中出现的位置
		sub(regex,replacement_str,string):将正则匹配到的第一处内容替换为replacement_str;
		match(regex,string):检查正则表达式是否能够匹配字符串；
		length(string)：返回字符串长度
		//为在 awk 里做过正则表达式,所以未尝试
	echo | awk '{"grep root /etc/passwd" | getline cmdout; print length(cmdout) }'
	seq 10 | awk '{printf "->%4s\n", $1}'	//printf 类似c语言中的printf，对输出进行格式化:
	迭代每一行内容----依次print出文本每行内容:
		传统 shell 方法:(while循环法)
		while read line; do echo $line; done < kkk // 注意,这是一条完整的shell命令,并非复合命令 !!!
		//这里有必要 复习 shell 的while循环命令!!
		//上述 while read line; do echo $line; done 是一条,而非多条,完整命令,单条命令完整性如 ls,cd....一般 
		// < kkk 是一个命令参数,表示先把 kkk 文件的内容输入到 标准输出文件,然后 这条命令再对标准输出文件操作,最后print出
		//这条命令相当独特,可以分多行写,而不需要额外写 "\" 分行符,像以下样子:
		//	kingders@kingders-ThinkPad-T420:~/other$ while read line;
		//	> do echo $line;
		//	> done < kkk
		cat file.txt | (while read line;do echo $line;done)	//也可以这样,注意,这是两条命令拼合的复合命令
		awk法
		cat file.txt| awk '{print}'
	迭代每一个字段----依次print出 行内容里的 每个字段
		read pp < kkk && for word in $pp; do echo $word; done
		//read 把 kkk文件里的第一行内容,写入到 标准输入文件的 pp 变量, 然后再执行 && 后一条命令!!
		//然后 以空格为界定符,把每个字段分别取出写入 标准输出文件,并显示出屏幕来
		//这里 一定要使用 && 多命令组合符,而非 | 多命令组合符号,
		//使用 | 拼接命令时,read 读出kkk第一行内容,但未刷入标准输入文件的 pp 变量, 
		//	接着就执行 for 命令, for命令用到pp变量,pp变量未存在,矛盾了
		//使用 && 拼接命令时,确保read pp < kkk 执行完毕并正确,才执行for命令, 所以for命令正常执行
		//for word in $oo; do echo $word; done  这也是一条完整命令,从标准输入文件里读取 pp 变量,
		//这里有必要 复习 shell 的 for循环命令!!
		//这条命令也是可以分行写而没有问题!!
		//	kingders@kingders-ThinkPad-T420:~/other$ for word in $pp;
		//	> do echo $word;
		//	> done
	迭代每一个字符----显示一个字段里的每一个字符
		//${string:start_pos:num_of_chars}：从字符串中提取num个字符；(bash文本切片）
		//${#word}:返回变量word的长度
		传统 shell 方法:(for循环法)
		for((i=0;i<${#word};i++)) do echo ${word:i:1}; done
		//这是一条完整的命令,这是for命令的另一种写法, 注意 for() do 之间没有";"号 ,也可以分行写
		//	kingders@kingders-ThinkPad-T420:~/other$ for((i=0;i<${#word};i++))
		//	> do
		//	> echo ${word:i:1};
		//	> done
	$od -c filename		//以ASCII字符显示文件:











20170831
linux系统管理工具:
$ps -ef				//查询正在运行的进程信息
$ps -ef | grep colin115		//查询归属于用户colin115的进程
$ps -lu kingders		//也是查询归属于用户 kingders的进程,
pgrep -l re	//查询进程名中含有re的进程
	2 kthreadd
	28 ecryptfs-kthrea
	29515 redis-server
$ps -ajx	//以完整的格式显示所有的进程
$top	//显示进程信息，并实时更新
	//输入top命令后，进入到交互界面；接着输入字符命令后显示相应的进程状态：
	//对于进程，平时我们最常想知道的就是哪些进程占用CPU最多，占用内存最多。以下两个命令就可以满足要求:
	//	P：根据CPU使用百分比大小进行排序。
	//	M：根据驻留内存大小进行排序。
	//	i：使top不显示任何闲置或者僵死进程。
lsof -i:3306		//查看端口占用的进程状态	........... 测试失败
			//lsof（list open files）是一个列出当前系统打开文件的工具。
			//在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。
			//如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等,在查询网络端口时，经常会用到这个工具。	
lsof -u kingfders	//查看用户username的进程所打开的文件
lsof -c init		//查询init进程当前打开的文件
lsof -p 23295		//查询指定的进程ID(23295)打开的文件：
lsof +d mydir1/		//查询指定目录下被进程开启的文件（使用+D 递归目录）：
$kill PID		//杀死指定PID的进程 (PID为Process ID)
kill -9 3434		//杀死与 进程PID3434 相关进程
$kill %job		//杀死job工作 (job为job number)
分析进程栈:
	ps -ef | grep gedit	//找出 ksmd 进程 pid号
	kingders 17231  1859  2 15:55 ?        00:02:37 gedit
	pmap 17231		//使用命令pmap，来输出进程内存的状况，可以用来分析进程堆栈；
	17231:   gedit
	0000000000400000    548K r-x-- gedit
	0000000000689000      8K r---- gedit
	000000000068b000     12K rw--- gedit
	0000000001143000  27112K rw---   [ anon ]
	00007f6821cc1000   4096K rw-s-   [ shmid=0x3b38016 ]
	00007f68220c1000      8K r-x-- ISO8859-1.so
	00007f68220c3000   2044K ----- ISO8859-1.so
	00007f68222c2000      4K r---- ISO8859-1.so
	00007f68222c3000      4K rw--- ISO8859-1.so
	00007f68222c4000     44K r-x-- libenchant_hspell.so
	.............
ps -u kingders | awk '/av_/ {print "kill -9 " $1}' | sh		//将用户kingders下的所有进程名以av_开头的进程终止:
ps -fe| grep kingders | grep HOST |awk '{print $2}' | xargs kill -9;	//将用户kingders下所有进程名中包含HOST的进程终止:
cat /proc/cpuinfo	//查询CPU信息
cat /proc/cpuinfo | grep processor | wc -l	//查看CPU的核的个数
安装sar:
	apt-get install sysstat
	gedit /etc/default/sysstat
		----
		# Should sadc collect system activity informations? Valid values
		# are "true" and "false". Please do not put other values, they
		# will be overwritten by debconf!
		ENABLED="true"		//这个地方 false 改为 true
		----
	service sysstat restart
	然后就可以使用 sar了
sar -u 1 2	//查看CPU使用率, 每秒采样 1 次，总共采样2次
	Linux 4.2.0-42-generic (kingders-ThinkPad-T420) 	2017年08月31日 	_x86_64_	(4 CPU)
	17时36分42秒     CPU     %user     %nice   %system   %iowait    %steal     %idle
	17时36分43秒     all      1.01      0.00      0.50      0.00      0.00     98.49
	17时36分44秒     all      6.02      0.00      1.45      0.00      0.00     92.53
	Average:        all      3.57      0.00      0.98      0.00      0.00     95.45
sar -q 1 2	//查看CPU平均负载,查看运行队列中的进程数、系统上的进程大小、平均负载等,每秒采样 1 次，总共采样2次
	Linux 4.2.0-42-generic (kingders-ThinkPad-T420) 	2017年08月31日 	_x86_64_	(4 CPU)
	17时38分55秒   runq-sz  plist-sz   ldavg-1   ldavg-5  ldavg-15   blocked
	17时38分56秒         0       618      0.02      0.08      0.08         0
	17时38分57秒         0       618      0.02      0.08      0.08         0
	Average:            0       618      0.02      0.08      0.08         0
$sar -r 1 2	//查看内存使用状况 sar指定-r之后，可查看内存使用状况,每秒采样 1 次，总共采样2次
	Linux 4.2.0-42-generic (kingders-ThinkPad-T420) 	2017年08月31日 	_x86_64_	(4 CPU)
	17时41分59秒 kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty
	17时42分00秒   2964188   5091368     63.20    583428   1848604   6786232     17.27   2954104   1627220        28
	17时42分01秒   2963816   5091740     63.21    583428   1848604   6786232     17.27   2954116   1627228        32
	Average:      2964002   5091554     63.21    583428   1848604   6786232     17.27   2954110   1627224        30
$free -m	//查看内存使用量
$sar -W 1 3	//查询页面交换,
		//查看页面交换发生状况 页面发生交换时，服务器的吞吐量会大幅下降；
		//服务器状况不良时，如果怀疑因为内存不足而导致了页面交换的发生，可以使用sar -W这个命令来确认是否发生了大量的交换；
$df -h		//查看磁盘空间利用情况
du -sh  	//查询当前目录下空间使用情况,-h是人性化显示 s是递归整个目录的大小
for i in `ls`; do du -sh $i; done | sort	//查看该目录下所有文件夹的排序后的大小
du -sh `ls`	//也可以这样,查看该目录下所有文件夹的排序后的大小
vmstat 1 3	//查看资源使用情况,与sar命令差不多,每秒采样 1 次，总共采样3次, 命令格式 vmstat n m (n 为监控频率、m为监控次数）
	procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
	 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
	 1  0 471012 2952980 583460 1844876    0    1    18   101   10   11 21  7 71  0  0
	 0  0 471012 2952856 583460 1844940    0    0     0     0  235  716  1  0 99  0  0
	 0  0 471012 2952856 583460 1844940    0    0     0     0  255  830  1  1 98  0  0
watch -d -n 1 './redis-cli info | grep memory'	//操作redis时，监控内存变化
						//使用watch 工具监控变化 当需要持续的监控应用的某个数据变化时，
						//watch工具能满足要求； 执行watch命令后，会进入到一个界面，输出当前被监控的数据，
						//一旦数据变化，便会高亮显示变化情况；
						//(以下为watch工具中的界面内容，一旦内存变化，即实时高亮显示变化）
	Every 1.0s: ./redis-cli info | grep memory                                                         Mon Apr 28 16:10:36 2014
	used_memory:45157376
	used_memory_human:43.07M
	used_memory_rss:47628288
	used_memory_peak:49686080
	used_memory_peak_human:47.38M
netstat -a	//列出所有端口 (包括监听和未监听的),netstat 命令用于显示各种网络相关信息，
		//如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。
netstat -at	//列出所有 tcp 端口
netstat -l	//列出所有有监听的服务状态
使用netstat工具查询端口,及使用它的进程
	$netstat -antp | grep 6379	
	tcp        0      0 127.0.0.1:6379          0.0.0.0:*               LISTEN      25501/redis-server
	$ps 25501
  	PID  	TTY      STAT   TIME 	COMMAND
	25501 	?        Ssl   28:21 	./redis-server ./redis.conf
查询7902端口现在运行什么程序:
	第一步,查询使用该端口的进程的PID；
	$lsof -i:7902	//查到30294
	COMMAND   PID   USER   FD   TYPE    DEVICE SIZE NODE NAME
	WSL     30294 tuapp    4u  IPv4 447684086       TCP 10.6.50.37:tnos-dp (LISTEN)
	第二步,使用ps工具查询进程详情：
	$ps -fe | grep 30294
	tdev5 	 30294 26160  0 Sep10 ?        01:10:50 tdesl -k 43476
	root     22781 22698  0 00:54 pts/20   00:00:00 grep 11554
$route -n	//查看路由状态
$traceroute IP	//探测前往地址IP的路由路径	(测试不如意)
$host domain	//DNS查询，寻找域名domain对应的IP:
$host IP	//反向DNS查询			(IP要反写,例 192.168.1.12,要写成 12.1.168.192)
wget url	//直接下载文件或者网页
	常用选项:
		–limit-rate :下载限速
		-o：指定日志文件；输出都写入日志；
		-c：断点续传
ftp sftp lftp ssh
	$ssh ID@host	//SSH登陆,ssh登陆远程服务器host，ID为用户名。
	$sftp ID@host	//ftp/sftp文件传输,登陆服务器host，ID为用户名。sftp登陆后，可以使用下面的命令进一步操作：
		get filename 	//下载文件
		put filename 	//上传文件
		ls 		//列出host上当前路径的所有文件
		cd 		//在host上更改当前路径
		lls 		//列出本地主机上当前路径的所有文件
		lcd 		//在本地主机更改当前路径
	lftp -u user:pass host		//lftp同步文件夹(类似rsync工具)
	lftp user@host:~> mirror -n
	$scp localpath ID@host:path	//将本地localpath指向的文件上传到远程主机的path路径
	$scp -r ID@site:path localpath	//以ssh协议，遍历下载path路径下的整个文件系统，到本地的localpath
环境变量:
	bashrc与profile都用于保存用户的环境信息，bashrc用于交互式non-loginshell，而profile用于交互式login shell。
	/etc/profile，/etc/bashrc 是系统全局环境变量设定
	~/.profile，~/.bashrc用户目录下的私有环境变量设定
	当登入系统获得一个shell进程时，其读取环境设置脚本分为三步:
		首先读入的是全局环境变量设置文件/etc/profile，
		然后根据其内容读取额外的文档，如/etc/profile.d和/etc/inputrc
    		读取当前登录用户Home目录下的文件~/.bash_profile，
		其次读取~/.bash_login，
		然后读取~/.profile，
		(~/.bash_profile,~/.bash_login,~/.profile这三个文档设定基本上是一样的，读取有优先关系
		最后读取~/.bashrc
	~/.profile与~/.bashrc的区别:
		这两者都具有个性化定制功能
		~/.profile可以设定本用户专有的路径，环境变量，等，它只能登入的时候执行一次
		~/.bashrc也是某用户专有设定文档，可以设定路径，命令别名，每次shell script的执行都会使用它一次
	补充:我们可以在这些环境变量中设置自己经常进入的文件路径，以及命令的快捷方式：
		.bashrc
		alias m='more'
		alias cp='cp -i'
		alias mv='mv -i'
		alias ll='ls -l'
		alias lsl='ls -lrt'
		alias lm='ls -al|more'
		
		log=/opt/applog/common_dir
		unit=/opt/app/unittest/common
		
		.bash_profile
		. /opt/app/tuxapp/openav/config/setenv.prod.sh.linux
		export PS1='$PWD#'
		通过上述设置，我们进入log目录就只需要输入cd $log即可；
查询系统版本
	$uname -a		//查看Linux系统版本
	$lsb_release -a		//查看Linux系统版本
	$more /etc/release	//查看Unix系统版本：操作系统版本
$cat /proc/meminfo	//查看内存信息
$pagesize	//显示内存page大小（以KByte为单位）
$arch		//显示架构
$date		//显示当前系统时间
设置系统日期和时间(格式为2014-09-15 17:05:00):	//设置系统时间需要root用户权限
	$date -s 2014-09-15 17:05:00
	$date -s 2014-09-15
	$date -s 17:05:00
	$date +%Y%m%d.%H%M%S	//格式化输出当前日期时间	
		>20150512.173821
IPC资源管理
	$ipcs	//查看系统使用的IPC资源
		------ Shared Memory Segments --------
		key        shmid      owner      perms      bytes      nattch     status      
		0x00000000 61833216   kingders   600        524288     2          dest         
		0x00000000 950273     kingders   600        524288     2          dest         
		0x00000000 262146     kingders   600        16777216   2                       
		0x00000000 393219     kingders   600        524288     2          dest         
		0x00000000 589828     kingders   600        524288     2          dest         
		0x00000000 688133     kingders   600        524288     2          dest         
		........
		------ Semaphore Arrays --------
		key        semid      owner      perms      nsems     
		
		------ Message Queues --------
		key        msqid      owner      perms      used-bytes   messages  
	$ipcs -m	//查看系统使用的IPC共享内存资源,	即 Shared Memory Segments
	$ipcs -q	//查看系统使用的IPC队列资源,	即 Message Queues
	$ipcs -s	//查看系统使用的IPC信号量资源,	即 Semaphore Arrays
	应用示例：查看IPC资源被谁占用
		有个IPCKEY：51036 ，需要查询其是否被占用；
        	51036 -> c75c	//首先通过计算器将其转为十六进制
		$ipcs -m | grep c75c	//如果知道是被共享内存占用
   			0x0000c75c 40403197   tdea3    666        536870912  2
		$ipcs | grep c75c	//如果不确定，则直接查找
			0x0000c75c 40403197   tdea3    666        536870912  2
			0x0000c75c 5079070    tdea3    666        4
检测和设置系统资源限制 (未测试过)
	ulimit – a	//显示当前所有的系统资源limit 信息
	ulimit – c unlimited	//对生成的 core 文件的大小不进行限制:








20170901
linux程序调试,
gdb 简单调试例子
	$gdb programmer     //启动gdb
	>break main         //设置断点
	>run                //运行调试程序
	>next               //单步调试
	>print var1         //在调试过程中，我们需要查看当前某个变量值的时候，使用print 命令打印该值
	>list               //显示当前调试处的源代码
	>info b             //显示当前断点设置情况
$pstrack <program-pid>	//pstack是一个脚本工具，可显示每个进程的栈跟踪。
			//pstack 命令必须由相应进程的属主或 root 运行。其核心实现就是使用了gdb以及thread apply all bt命令;
	示例:
	$ pstack 4551	
		Thread 7 (Thread 1084229984 (LWP 4552)):
	#0  0x000000302afc63dc in epoll_wait () from /lib64/tls/libc.so.6
	#1  0x00000000006f0730 in ub::EPollEx::poll ()
	#2  0x00000000006f172a in ub::NetReactor::callback ()
	#3  0x00000000006fbbbb in ub::UBTask::CALLBACK ()
	#4  0x000000302b80610a in start_thread () from /lib64/tls/libpthread.so.0
	#5  0x000000302afc6003 in clone () from /lib64/tls/libc.so.6
	#6  0x0000000000000000 in ?? ()
strace -o output.txt -T -tt -e trace=all -p 28979	//跟踪28979进程的所有系统调用（-e trace=all），
							//并统计系统调用的花费时间，以及开始时间（以可视化的时分秒格式显示），
							//最后将记录结果存在output.txt文件里面。
							//strace常用来跟踪进程执行时的系统调用和所接收的信号。
							//在Linux世界，进程不能直接访问硬件设备，
							//当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，
							//必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。
							//strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。
$strace -p <process-pid>	//查看进程正在做什么(实时输出进程执行系统调用的情况)
$nm myProgrammer		//nm用来列出目标文件的符号清单
	08049f28 d _DYNAMIC
	08049ff4 d _GLOBAL_OFFSET_TABLE_
	080484dc R _IO_stdin_used
	         w _Jv_RegisterClasses
	08049f18 d __CTOR_END__
	08049f14 d __CTOR_LIST__
	08049f20 D __DTOR_END__
	08049f1c d __DTOR_LIST__
	.....
	这些包含可执行代码的段称为正文段,数据段包含了不可执行的信息或数据.BSS 段包含以符号数据开头的块。
	对于 nm 命令列出的每个符号，它们的值使用十六进制来表示（缺省行为），并且在该符号前面加上了一个表示符号类型的编码字符。
	常见的各种编码包括：
		A 表示绝对 (absolute)，这意味着不能将该值更改为其他的连接；
		B 表示 BSS 段中的符号；
		C 表示引用未初始化的数据的一般符号。
$objdump -d myprogrammer	//ogjdump工具用来显示二进制文件的信息，就是以一种可阅读的格式让你更多地了解二进制文件可能带有的附加信息。
	a.out:     file format elf32-i386
	Disassembly of section .init:
	080482b4 <_init>:
	 80482b4:   53                      push   %ebx
	 80482b5:   83 ec 08                sub    $0x8,%esp
	 80482b8:   e8 00 00 00 00          call   80482bd <_init+0x9>
	 80482bd:   5b                      pop    %ebx
	 80482be:   81 c3 37 1d 00 00       add    $0x1d37,%ebx
	 80482c4:   8b 83 fc ff ff ff       mov    -0x4(%ebx),%eax
	 80482ca:   85 c0                   test   %eax,%eax
	 80482cc:   74 05                   je     80482d3 <_init+0x1f>
	 80482ce:   e8 3d 00 00 00          call   8048310 <__gmon_start__@plt>
	 80482d3:   e8 e8 00 00 00          call   80483c0 <frame_dummy>
	 80482d8:   e8 b3 01 00 00          call   8048490 <__do_global_ctors_aux>
	 80482dd:   83 c4 08                add    $0x8,%esp
	 80482e0:   5b                      pop    %ebx
	 80482e1:   c3                      ret	
	Disassembly of section .plt:
	...
	//每个可执行代码段将在需要特定的事件时执行，这些事件包括库的初始化和该程序本身主入口点。
	//该工具，可用于研究编译器和汇编器的输出。细节信息，比如这段代码中所显示的这些信息，
	//可以揭示有关本地处理器本身运行方式的很多内容。对该处理器制造商提供的技术文档进行深入的研究，您可以收集关于一些有价值的信息，
	//通过这些信息可以深入地了解内部的运行机制，因为功能程序提供了清晰的输出。
$readelf -all a.out	//这个工具和objdump命令提供的功能类似，但是它显示的信息更为具体，
			//并且它不依赖BFD库(BFD库是一个GNU项目，它的目标就是希望通过一种统一的接口来处理不同的目标文件）
	ELF Header:
	  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
	  Class:                             ELF32
	  Data:                              2's complement, little endian
	  Version:                           1 (current)
	  OS/ABI:                            UNIX - System V
	  ABI Version:                       0
	  Type:                              EXEC (Executable file)
	  Machine:                           Intel 80386
	  Version:                           0x1
	  Entry point address:               0x8048330
	  Start of program headers:          52 (bytes into file)
	  Start of section headers:          4412 (bytes into file)
	  Flags:                             0x0
	  Size of this header:               52 (bytes)
	  Size of program headers:           32 (bytes)
	  Number of program headers:         9
	  Size of section headers:           40 (bytes)
	  Number of section headers:         30
	  Section header string table index: 27	
	Section Headers:
	  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
	  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
	  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1
	  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4
	  [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4
	  [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 000020 04   A  5   0  4
	  [ 5] .dynsym           DYNSYM          080481cc 0001cc 000050 10   A  6   1  4
	  [ 6] .dynstr           STRTAB          0804821c 00021c 00004c 00   A  0   0  1
	  [ 7] .gnu.version      VERSYM          08048268 000268 00000a 02   A  5   0  2
	  [ 8] .gnu.version_r    VERNEED         08048274 000274 000020 00   A  6   1  4
	  [ 9] .rel.dyn          REL             08048294 000294 000008 08   A  5   0  4
	  [10] .rel.plt          REL             0804829c 00029c 000018 08   A  5  12  4
	  [11] .init             PROGBITS        080482b4 0002b4 00002e 00  AX  0   0  4
	  [12] .plt              PROGBITS        080482f0 0002f0 000040 04  AX  0   0 16
	  [13] .text             PROGBITS        08048330 000330 00018c 00  AX  0   0 16
	  [14] .fini             PROGBITS        080484bc 0004bc 00001a 00  AX  0   0  4
	  [15] .rodata           PROGBITS        080484d8 0004d8 000011 00   A  0   0  4
	  [16] .eh_frame_hdr     PROGBITS        080484ec 0004ec 000034 00   A  0   0  4
	  [17] .eh_frame         PROGBITS        08048520 000520 0000c4 00   A  0   0  4
	  [18] .ctors            PROGBITS        08049f14 000f14 000008 00  WA  0   0  4
	  [19] .dtors            PROGBITS        08049f1c 000f1c 000008 00  WA  0   0  4
	  [20] .jcr              PROGBITS        08049f24 000f24 000004 00  WA  0   0  4
	  [21] .dynamic          DYNAMIC         08049f28 000f28 0000c8 08  WA  6   0  4
	  [22] .got              PROGBITS        08049ff0 000ff0 000004 04  WA  0   0  4
	  [23] .got.plt          PROGBITS        08049ff4 000ff4 000018 04  WA  0   0  4
	  [24] .data             PROGBITS        0804a00c 00100c 000008 00  WA  0   0  4
	  [25] .bss              NOBITS          0804a014 001014 000008 00  WA  0   0  4
	  [26] .comment          PROGBITS        00000000 001014 00002a 01  MS  0   0  1
	  [27] .shstrtab         STRTAB          00000000 00103e 0000fc 00      0   0  1
	  [28] .symtab           SYMTAB          00000000 0015ec 000410 10     29  45  4
	  [29] .strtab           STRTAB          00000000 0019fc 0001f9 00      0   0  1
	  ...
	//ELF Header 为该文件中所有段入口显示了详细的摘要。在列举出这些 Header 中的内容之前，您可以看到 Header 的具体数目。
	//在研究一个较大的目标文件时，该信息可能非常有用。
	//除了所有这些段之外，编译器可以将调试信息放入到目标文件中，并且还可以显示这些信息。
$readelf --debug-dump a.out | more	//这命令，可帮助仔细分析编译器的输出
					//调试工具，如 GDB，可以读取这些调试信息，并且当程序在调试器中运行的同时，
					//可以使用该工具显示更具描述性的标记，而不是对代码进行反汇编时的原始地址值。
$size a.out	//查看程序运行时各个段的实际内存占用
	text           data     bss     dec     hex filename
	1146            256       8    1410     582 a.out
$file a.out	//查看文件的类型,比如我们在64位机器上发现了一个32位的库，链接不上，这就有问题了
	a.out: ELF 64-bit LSB executable, AMD x86-64, version 1 (SYSV), for GNU/Linux 2.6.9, dynamically linked (uses shared libs),
	for GNU/Linux 2.6.9, not stripped
$file core.22355	//查看Core文件是由哪个程序生成
$strings <objfile>	//查询数据中的文本信息,一个文件中包含二进制数据和文本数据，
			//如果只需要查看其文本信息，使用这个命令就很方便；过滤掉非字符数据，将文本信息输出:
$fuser -m -u redis-server	//显示 redis-server的使用者,fuser显示所有正在使用着指定的file, file system 或者 sockets的进程信息;
	redis-server: 11552rce(weber) 22912rce(weber) 25501rce(weber)
	//使用了-m和-u选项，用来查找所有正在使用redis-server的所有进程的PID以及该进程的OWNER；
$fuser –k /path/to/your/filename	//fuser通常被用在诊断系统的”resource busy”问题。
					//如果想kill所有正在使用某一指定的file, file system or sockets的进程时，可使用-k选项
$xxd a.out	以十六进制方式显示文件，只显示文本信息:
	0000000: 7f45 4c46 0101 0100 0000 0000 0000 0000  .ELF............
	0000010: 0200 0300 0100 0000 3083 0408 3400 0000  ........0...4...
	0000020: 3c11 0000 0000 0000 3400 2000 0900 2800  <.......4. ...(.
	0000030: 1e00 1b00 0600 0000 3400 0000 3480 0408  ........4...4...
	0000040: 3480 0408 2001 0000 2001 0000 0500 0000  4... ... .......
	0000050: 0400 0000 0300 0000 5401 0000 5481 0408  ........T...T...
	...
$od -Ax -tcx4 a.c	//以十六进制和字符同时显示,
	000000   #   i   n   c   l   u   d   e       <   s   t   d   i   o   .
	              636e6923        6564756c        74733c20        2e6f6964
	000010   h   >  \n  \n   v   o   i   d       m   a   i   n   (   )  \n
	              0a0a3e68        64696f76        69616d20        0a29286e
	000020   {  \n  \t   i   n   t       i       =       5   ;  \n  \t   p
	              69090a7b        6920746e        35203d20        70090a3b
	000030   r   i   n   t   f   (   "   h   e   l   l   o   ,   %   d   "
	              746e6972        68222866        6f6c6c65        2264252c
	000040   ,   i   )   ;  \n   }  \n
	              3b29692c        000a7d0a
	000047
$od -c a.c	//以字符方式显示
	0000000   #   i   n   c   l   u   d   e       <   s   t   d   i   o   .
	0000020   h   >  \n  \n   v   o   i   d       m   a   i   n   (   )  \n
	0000040   {  \n  \t   i   n   t       i       =       5   ;  \n  \t   p
	0000060   r   i   n   t   f   (   "   h   e   l   l   o   ,   %   d   "
	0000100   ,   i   )   ;  \n   }  \n
	0000107
	//类似命令还有hexdump（十六进制输出）
	//通常使用od命令查看特殊格式的文件内容。通过指定该命令的不同选项可以以十进制、八进制、十六进制和ASCII码来显示文件。
	//参数说明：
	//-A 指定地址基数:			-t 指定数据的显示格式，主要的参数有：
	//	d 十进制				c ASCII字符或反斜杠序列
	//	o 八进制（系统默认值）			d 有符号十进制数
	//	x 十六进制				f 浮点数
	//	n 不打印位移值				o 八进制（系统默认值为02）
	//						u 无符号十进制数
	//						x 十六进制数
	//						(除了选项c以外的其他选项后面都可以跟一个十进制数n，指定每个显示值所包含的字节数)
	//od命令系统默认的显示方式是八进制，这也是该命令的名称由来（Octal Dump）。
	//但这不是最有用的显示方式，用ASCII码和十六进制组合的方式能提供更有价值的信息输出。
linux程序性能优化
$top	//系统响应变慢，首先得定位大致的问题出在哪里，是IO瓶颈、CPU瓶颈、内存瓶颈还是程序导致的系统问题；
	top - 09:14:56 up 264 days, 20:56,  1 user,  load average: 0.02, 0.04, 0.00
	Tasks:  87 total,   1 running,  86 sleeping,   0 stopped,   0 zombie
	Cpu(s):  0.0%us,  0.2%sy,  0.0%ni, 99.7%id,  0.0%wa,  0.0%hi,  0.0%si,  0.2%st
	Mem:    377672k total,   322332k used,    55340k free,    32592k buffers
	Swap:   397308k total,    67192k used,   330116k free,    71900k cached
	PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
	1 root      20   0  2856  656  388 S  0.0  0.2   0:49.40 init
	2 root      20   0     0    0    0 S  0.0  0.0   0:00.00 kthreadd
	3 root      20   0     0    0    0 S  0.0  0.0   7:15.20 ksoftirqd/0
	4 root      RT   0     0    0    0 S  0.0  0.0   0:00.00 migration/
	......
	进入交互模式后:
		输入M，进程列表按内存使用大小降序排序，便于我们观察最大内存使用者使用有问题（检测内存泄漏问题）;
		输入P，进程列表按CPU使用大小降序排序，便于我们观察最耗CPU资源的使用者是否有问题；
	top第三行显示当前系统的，其中有两个值很关键:
		%id：空闲CPU时间百分比，如果这个值过低，表明系统CPU存在瓶颈；
		%wa：等待I/O的CPU时间百分比，如果这个值过高，表明IO存在瓶颈；
free	//查看内存是否存在瓶颈，使用top指令看比较麻烦，而free命令更为直观:
	             total       used       free     shared    buffers     cached
	Mem:        501820     452028      49792      37064       5056     136732
	-/+ buffers/cache:     310240     191580
	Swap:            0          0          0
	//如果是因为缺少内存，系统响应变慢很明显，因为这使得系统不停的做换入换出的工作;
	//进一步的监视内存使用情况，可使用vmstat工具，实时动态监视操作系统的内存和虚拟内存的动态变化.
	//Linux上的free命令详解 http://www.cnblogs.com/coldplayerest/archive/2010/02/20/1669949.html
iostat -d -x -k 1 1	//使用iostat工具分析IO瓶颈,如果IO存在性能瓶颈，top工具中的%wa会偏高；
	Linux 2.6.32-279.el6.x86_64 (colin)   07/16/2014      _x86_64_        (4 CPU)
	Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await  svctm  %util
	sda               0.02     7.25    0.04    1.90     0.74    35.47    37.15     0.04   19.13   5.58   1.09
	dm-0              0.00     0.00    0.04    3.05     0.28    12.18     8.07     0.65  209.01   1.11   0.34
	dm-1              0.00     0.00    0.02    5.82     0.46    23.26     8.13     0.43   74.33   1.30   0.76
	dm-2              0.00     0.00    0.00    0.01     0.00     0.02     8.00     0.00    5.41   3.28   0.00
	//如果%iowait的值过高，表示硬盘存在I/O瓶颈。
	//如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。
	//如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；
	//如果 await 远大于 svctm，说明I/O 队列太长，io响应太慢，则需要进行必要优化。
	//如果avgqu-sz比较大，也表示有大量io在等待。
3.4. 分析进程调用
查看bash程序进程栈:
	/opt/app/tdev1$ps -fe| grep bash
		tdev1   7013  7012  0 19:42 pts/1    00:00:00 -bash
		tdev1  11402 11401  0 20:31 pts/2    00:00:00 -bash
		tdev1  11474 11402  0 20:32 pts/2    00:00:00 grep bash
	/opt/app/tdev1$pstack 7013
		#0  0x00000039958c5620 in __read_nocancel () from /lib64/libc.so.6
		#1  0x000000000047dafe in rl_getc ()
		#2  0x000000000047def6 in rl_read_key ()
		#3  0x000000000046d0f5 in readline_internal_char ()
		#4  0x000000000046d4e5 in readline ()
		#5  0x00000000004213cf in ?? ()
		#6  0x000000000041d685 in ?? ()
		#7  0x000000000041e89e in ?? ()
		#8  0x00000000004218dc in yyparse ()
		#9  0x000000000041b507 in parse_command ()
		#10 0x000000000041b5c6 in read_command ()
		#11 0x000000000041b74e in reader_loop ()
		#12 0x000000000041b2aa in main ()
		...
		//pstack用来跟踪进程栈，这个命令在排查进程问题时非常有用，
		//比如我们发现一个服务一直处于work状态（如假死状态，好似死循环），使用这个命令就能轻松定位问题所在；
		//可以在一段时间内，多执行几次pstack，若发现代码栈总是停在同一个位置，那个位置就需要重点关注，很可能就是出问题的地方；
优化程序建议采用以下准则:
	二八法则：
		在任何一组东西中，最重要的只占其中一小部分，约20%，其余80%的尽管是多数，却是次要的；
		在优化实践中，我们将精力集中在优化那20%最耗时的代码上，整体性能将有显著的提升；
		函数A虽然代码量大，但在一次正常执行流程中，只调用了一次。
		而另一个函数B代码量比A小很多，但被调用了1000次。显然，我们更应关注B的优化。
	编完代码，再优化；
		编码的时候总是考虑最佳性能未必总是好的；在强调最佳性能的编码方式的同时，可能就损失了代码的可读性和开发效率；

gprof使用步骤,参考(C++的性能优化实践 http://www.cnblogs.com/me115/archive/2013/06/05/3117967.html)
	g++ -pg -o test.exe test.cpp	//用gcc、g++、xlC编译程序时，使用-pg参数
					//编译器会自动在目标代码中插入用于性能测试的代码片断，
					//这些代码在程序运行时采集并记录函数的调用关系和调用次数，
					//并记录函数自身执行时间和被调用函数的执行时间
	./test.exe	//执行编译后的可执行程序,该步骤运行程序的时间会稍慢于正常编译的可执行程序的运行时间
			//程序运行结束后，会在程序所在路径下生成一个缺省文件名为gmon.out的文件，
			//这个文件就是记录程序运行的性能、调用关系、调用次数等信息的数据文件。
	gprof test.exe gmon.out		//使用gprof命令来分析记录程序运行信息的gmon.out文件,生成结果报告输出到屏幕上
					//可以看到函数调用相关的统计、分析信息。
	gprof test.exe gmon.out> gprofresult.txt	// 生成的结果报告 重定向到文本文件以便于后续分析。
其它工具
	valgrind	//调试内存泄漏的工具
	OProfile	//Linux 平台上的一个功能强大的性能分析工具 参考 http://www.ibm.com/developerworks/cn/linux/l-oprof/
	sar		//关于sar的使用,看之前介绍!!








20170906
django 开发 地图网游太难,可能只能当后端,模糊搜索后发现应该要使用html5
html5 webgame 学习:	
	写一个测试网页,测试html5众多功能,
	把下述一个简单html 写到 gedit文本编辑器,然后保存为 test.html 且是 utf-8 编码格式保存!!
	(注意,不要用win自带txt编辑器,因为保存时,编辑器默认以ANSI编码格式保存)
	然后使用firefox直接打开可以看效果!!
	(test.html用到的各种资源都放在同目录的:/home/kingders/other/html5_learn里)
/*test.html start*/
<!DOCTYPE html>
<html manifest="demo_html.appcache">
<!-- 加 manifest 表示，告诉浏览器保存 脱机页面到demo_html.appcache 文件里 -->
<head>
	<!-- html注释符号长这样,上面的是修复 -->
	<meta charset="utf-8"> 
	<title>菜鸟教程(runoob.com)</title> 
	<meta charset="utf-8">
	<title>渲染 HTML5</title>
	<!--[if lt IE 9]>
	<script src="https://apps.bdimg.com/libs/html5shiv/3.7/html5shiv.min.js"></script>
	<![endif]-->
	<!-- 上面是一段代码注释,但又可以修复 ie9 不支持html5 的问题,先不探究为啥一段注释还能起这种作用,暂时只知道是说什么Shiv 解决方案而已 -->

	<!-- 定义了一种格式style -->
	<script>document.createElement("myHero")</script>
	<style>
	myHero {
		display: block;
		background-color: #ddd;
		padding: 50px;
		font-size: 30px;
	} 
	</style>

	<!-- 拖放功能示例预设置 定义了俩个格式框 div1，div2，还有一些功能函数-->
	<style type="text/css">
		#div1, #div2
		{float:left; width:100px; height:35px; margin:10px;padding:10px;border:1px solid #aaaaaa;}
	</style>
	<script>
		function allowDrop(ev)		
		{
			ev.preventDefault();
		}		
		function drag(ev)
		{
			ev.dataTransfer.setData("Text",ev.target.id); //数据类型是 "Text"，值是可拖动元素的 id ("drag1")
		}
		function drop(ev)
		{
			ev.preventDefault();
			var data=ev.dataTransfer.getData("Text");
			ev.target.appendChild(document.getElementById(data));
		}
		//调用 preventDefault() 来避免浏览器对数据的默认处理（drop 事件的默认行为是以链接形式打开）
		//通过 dataTransfer.getData("Text") 方法获得被拖的数据。该方法将返回在 setData() 方法中设置为相同类型的任何数据。
		//被拖数据是被拖元素的 id ("drag1")
		//把被拖元素追加到放置元素（目标元素）中
	</script>

	<!-- web 存储 -->
	<script>
	function clickCounter_localstorage()
	{
		if(typeof(Storage)!=="undefined")
		{
			if (localStorage.clickcount)
			{
				localStorage.clickcount=Number(localStorage.clickcount)+1;
			}
			else
			{
				localStorage.clickcount=1;
			}
			document.getElementById("result1").innerHTML=" 你已经点击了按钮 " + localStorage.clickcount + " 次 ";
		}
		else
		{
			document.getElementById("result1").innerHTML="对不起，您的浏览器不支持 web 存储。";
		}
	}
	function clickCounter_seesionstorage()
	{
		if(typeof(Storage)!=="undefined")
		{
			if (sessionStorage.clickcount)
			{
				sessionStorage.clickcount=Number(sessionStorage.clickcount)+1;
			}
			else
			{
				sessionStorage.clickcount=1;
			}
			document.getElementById("result2").innerHTML="在这个会话中你已经点击了该按钮 " + sessionStorage.clickcount + " 次 ";
		}
		else
		{
			document.getElementById("result2").innerHTML="抱歉，您的浏览器不支持 web 存储";
		}
	}
	</script>
</head>


<body>	
	<!--导入图片资源-->
	<p>使用的图片资源:</p>
	<img id="scream" src="monai.jpg" alt="The Scream" width="220" height="277">
	
	<p>Canvas:</p>
	<!--分配CANVAS 画板1-->
	<canvas id="myCanvas" width="200" height="100" style="border:1px solid #d3d3d3;">	
	您的浏览器不支持 HTML5 canvas 标签。</canvas>
	<!--分配CANVAS 画板2-->
	<canvas id="myCanvas2" width="200" height="100" style="border:1px solid #d3d3d3;">	
	您的浏览器不支持 HTML5 canvas 标签。</canvas>
	<!--分配CANVAS 画板3-->
	<canvas id="myCanvas3" width="200" height="100" style="border:1px solid #d3d3d3;">	
	您的浏览器不支持 HTML5 canvas 标签。</canvas>
	<!--分配CANVAS 画板4-->
	<canvas id="myCanvas4" width="250" height="300" style="border:1px solid #d3d3d3;">
	您的浏览器不支持 HTML5 canvas 标签。</canvas>	


	<h1>我的第一篇文章</h1>

	<article>
	菜鸟教程 —— 学的不仅是技术，更是梦想！！！
	</article>

	<myHero>myHero 格式 示范 </myHero>

	<script>
	//javascript注释符长这样
	//使用画板1
	var c=document.getElementById("myCanvas");
	var ctx=c.getContext("2d");	
	//画对角线
	ctx.moveTo(0,0);	
	ctx.lineTo(200,100);
	ctx.stroke();
	//画圆
	ctx.beginPath();
	ctx.arc(95,50,40,0,2*Math.PI);	//arc(x,y,r,start,stop)  画布的左上角坐标为0,0 
					//x：圆心在x轴上的坐标,y：圆心在y轴上的坐标,r：半径长度,start：起始角度，圆心平行的右端为0度,stop：结束角度,
					//Math.PI表示180°，画圆的方向是顺时针
	ctx.stroke();
	//绘制文本
	ctx.font="30px Arial";
	ctx.fillText("Hello World",10,50);

	//使用画板2
	var c=document.getElementById("myCanvas2");
	var ctx=c.getContext("2d");
	// 创建渐变
	var grd=ctx.createLinearGradient(0,0,200,0);
	grd.addColorStop(0,"green");
	grd.addColorStop(1,"yellow");
	// 填充渐变
	ctx.fillStyle=grd;
	ctx.fillRect(10,10,150,80);

	//使用画板2
	var c=document.getElementById("myCanvas3");
	var ctx=c.getContext("2d");
	// 创建渐变
	var grd=ctx.createRadialGradient(75,50,5,90,60,100);
	grd.addColorStop(0,"red");
	grd.addColorStop(1,"white");	 
	// 填充渐变
	ctx.fillStyle=grd;
	ctx.fillRect(10,10,150,80);

	//使用画板4 插入图片
	var c=document.getElementById("myCanvas4");
	var ctx=c.getContext("2d");
	var img=document.getElementById("scream");
	img.onload = function() {
		ctx.drawImage(img,10,10);
	} 
	</script>

	<!--画一张SVG 矢量图片-->
	<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="190">
		<!-- svg 里的注释符号与html一样 -->
		<!-- http://www.w3.org/2000/svg 是引用svg功能的接口网址 -->	
		<polygon points="100,10 40,180 190,60 10,60 160,180"
		style="fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;"/>
	</svg>

	<!--MathML 数学式子 显示-->
 	<math xmlns="http://www.w3.org/1998/Math/MathML">
		<!-- MathML 里的注释符号与html一样 -->
		<!-- http://www.w3.org/1998/Math/MathML 是引用mathml功能的接口网址 -->
		<p>式子1:</p>
		<mrow>
			<msup><mi>a</mi><mn>2</mn></msup>
			<mo>+</mo>
			
			<msup><mi>b</mi><mn>2</mn></msup>
			<mo>=</mo>
			
			<msup><mi>c</mi><mn>2</mn></msup>
		</mrow>
		<p>式子2:</p>
		<mrow>			
			<mrow>
				<msup>
					<mi>x</mi>
					<mn>2</mn>
				</msup>
				<mo>+</mo>
				<mrow>
					<mn>4</mn>
					<mo>⁢</mo>
					<mi>x</mi>
				</mrow>
				<mo>+</mo>
				<mn>4</mn>
				</mrow>
					<mo>=</mo>
				<mn>0</mn>
			</mrow>
		</mrow>
		<!-- 矩阵显示不出来，先不追究 -->
		<p>矩阵:</p>
		<mrow>
			<mi>A</mi>
			<mo>=</mo>
			<mfenced open="[" close="]">
				<mtable>
					<mtr>
						<mtd><mi>x</mi></mtd>
						<mtd><mi>y</mi></mtd>
					</mtr>
					<mtr>
						<mtd><mi>z</mi></mtd>
						<mtd><mi>w</mi></mtd>
					</mtr>
				</mtable>
			</mfenced>
		</mrow>
	</math>

	<!--拖放示例-->
	<p>拖放例子</p>
	<p>div1-------------------div2</p>
	<div id="div1" ondrop="drop(event)" ondragover="allowDrop(event)">
		<img src="img_w3slogo.gif" draggable="true" ondragstart="drag(event)" id="drag1" width="88" height="31"></div>
			<!-- draggable="true" 设置元素可拖放 -->
			<!-- 可拖动元素的 id "drag1" -->
	<div id="div2" ondrop="drop(event)" ondragover="allowDrop(event)"></div>
	
	<!-- 设置了三行隔行 -->
	<br>
	<br>
	<br>

	<!--video 及 DOM 控制示例-->
	<p>视频及控制示例</p>
	<div style="text-align:center"> 
		<button onclick="playPause()">播放/暂停</button> 
		<button onclick="makeBig()">放大</button>
		<button onclick="makeSmall()">缩小</button>
		<button onclick="makeNormal()">普通</button>
		<br>
		<video id="video1" width="320" height="240" controls>
			<source src="movie.mp4" type="video/mp4">
			<source src="movie.ogg" type="video/ogg">
			<!-- 可惜不知道怎么获取 movie.ogg 音频文件 所以并没有成功展示ogg音频效果-->
			您的浏览器不支持 HTML5 video 标签。
		</video>
	</div> 
	<script> 
		var myVideo=document.getElementById("video1"); 
		function playPause()
		{ 
			if (myVideo.paused) 
			  myVideo.play(); 
			else 
			  myVideo.pause(); 
		} 
		
			function makeBig()
		{ 
			myVideo.width=560; 
			myVideo.height=420; 
		} 
		
			function makeSmall()
		{ 
			myVideo.width=176; 
			myVideo.height=144; 
		} 
		
			function makeNormal()
		{ 
			myVideo.width=320; 
			myVideo.height=240;
		} 
	</script> 

	<!-- audio示例 -->
	<p>音频及控制示例</p>
	<audio controls>
		<source src="horse.ogg" type="audio/ogg">
		<source src="horse.mp3" type="audio/mpeg">
		<!-- 获取了 horse.ogg 音频文件-->
		<!-- 没有获取了 horse.mp3 音频文件 所以并没有成功展示mp3音频效果-->
		您的浏览器不支持 audio 元素。
	</audio>

	<!-- 表单 例子 -->
	<p>input示例</p>
	<!--注意，并没有demo-form.php 这个文件，这个文件主要是对输入参数后续处理，但不影响input演示 -->
	<form action="demo-form.php">选择你喜欢的颜色: <input type="color" name="favcolor"><input type="submit"></form>
	<form action="demo-form.php">生日: <input type="date" name="bday"><input type="submit"></form>
	<form action="demo-form.php">生日 (日期和时间): <input type="datetime" name="bdaytime"><input type="submit"></form>
	<form action="demo-form.php">生日-local (日期和时间): <input type="datetime-local" name="bdaytime"><input type="submit"></form>
	<form action="demo-form.php">E-mail: <input type="email" name="email"><input type="submit"></form>
	<form action="demo-form.php">生日 (月和年): <input type="month" name="bdaymonth"><input type="submit"></form>
	<form action="demo-form.php">数量 ( 1 到 5 之间 ): <input type="number" name="quantity" min="1" max="5"><input type="submit"></form>
	<form action="demo-form.php" method="get">Points: <input type="range" name="points" min="1" max="10"><input type="submit"></form>
	<form action="demo-form.php">Search Google: <input type="search" name="googlesearch"><input type="submit"></form>
	<form action="demo-form.php">电话号码: <input type="tel" name="usrtel"><input type="submit"></form>
	<form action="demo-form.php">选择时间: <input type="time" name="usr_time"><input type="submit"></form>
	<form action="demo-form.php">添加您的主页: <input type="url" name="homepage"><input type="submit"></form>
	<form action="demo-form.php">选择周: <input type="week" name="week_year"><input type="submit"></form>
	<form action="demo-form.php" method="get">下拉表单示例：<input list="browsers" name="browser">
		<datalist id="browsers">
			<option value="Internet Explorer">
			<option value="Firefox">
			<option value="Chrome">
			<option value="Opera">
			<option value="Safari">
		</datalist>
		<input type="submit">
	</form>
	<!--	<keygen> 元素的作用是提供一种验证用户的可靠方法。
		<keygen>标签规定用于表单的密钥对生成器字段。
		当提交表单时，会生成两个键，一个是私钥，一个公钥。
		私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）
	-->
	<p>keygen 示例</p>
	<form action="demo_keygen.php" method="get">
		用户名: <input type="text" name="usr_name">
		加密: <keygen name="security">
		<input type="submit">
	</form>
	<!-- output> 元素示例-->
	<p>output示例</p>
	<form oninput="x.value=parseInt(a.value)+parseInt(b.value)">0
		<input type="range" id="a" value="50">100
		+<input type="number" id="b" value="50">
		=<output name="x" for="a b"></output>
	</form>

	<!-- html5 语义元素 测试 -->
	<!-- 	语义元素来明确一个Web页面的不同部分
			《header》
		-------------------------
			《nav》
		-------------------------
		《section》	|《aside》
		----------------|
		《article》	|
		-------------------------
			《footer》
	-->
	<!-- 然而实在不知道如何展示aside 部分 -->
	<header>
		<h1> hender </h1>
		<p><time pubdate datetime="2011-03-15"></time></p>
	</header>
	<nav>
		<a href="/html/">HTML</a> |
		<a href="/css/">CSS</a> |
		<a href="/js/">JavaScript</a> |
		<a href="/jquery/">jQuery</a>
	</nav>
	<section>
		<h1>section1：WWF</h1>
		<p>The World Wide Fund for Nature (WWF) is an international organization working on issues regarding the conservation, research and restoration of the environment, formerly named the World Wildlife Fund. WWF was founded in 1961.</p>
	</section>
	<section>
		<h1>section2：WWF's Panda symbol</h1>
		<p>The Panda has become the symbol of WWF. The well-known panda logo of WWF originated from a panda named Chi Chi that was transferred from the Beijing Zoo to the London Zoo in the same year of the establishment of WWF.</p>
	</section>
	<article>
		<h1>article</h1>
		<p> Windows Internet Explorer 9(缩写为 IE9 )在2011年3月14日21:00 发布。</p>
	</article>
	<aside>
		<h4>aside</h4>
		<p>The Epcot Center is a theme park in Disney World, Florida.</p>
	</aside>

	<br>

	<!-- web 存储 例子 -->
	<!-- 所谓 web存储，就是临时生成的 暂存在浏览器上的 自定义变量（变量名字key+变量值value）  -->
	<!-- sessionStorage.clickcount 中 clickcount是自定义变量变量名，在这里变量的变量值是一个数字值 -->
	<!-- localStorage.clickcount 中 clickcount也是自定义变量变量名，在这里变量的变量值也是一个数字值 -->	
	<p>web 存储 例子</p>
	<p><button onclick="clickCounter_localstorage()" type="button">localstorage例子点我！</button></p>
	<div id="result1"></div>
	<p>点击该按钮查看计数器的增加。由于计数数据是localstorage变量，关闭页面重开，数据不会重置</p>
	<p><button onclick="clickCounter_seesionstorage()" type="button">seesionstorage例子点我！</button></p>
	<div id="result2"></div>
	<p>点击该按钮查看计数器的增加。由于计数数据是seesionstorage变量，关闭页面重开，数据会重置</p>
	
	<br>

	<!-- web存储典型例子 一个简单的网站列表程序 -->
	<p>一个简单的网站列表程序</p>
	<div style="border: 2px dashed #ccc;width:320px;text-align:center;">     
		<label for="sitename">网站名(key)：</label>  
		<input type="text" id="sitename" name="sitename" class="text"/>  
		<br/>  
		<label for="siteurl">网 址(value)：</label>  
		<input type="text" id="siteurl" name="siteurl"/>  
		<br/>  
		<input type="button" onclick="save()" value="新增记录"/>  
		<hr/>  
		<label for="search_phone">输入网站名：</label>  
		<input type="text" id="search_site" name="search_site"/>  
		<input type="button" onclick="find()" value="查找网站"/>  
		<p id="find_result"><br/></p>  
	</div>  
	<br/>  
	<div id="list"></div>  
	<script>
		// 载入所有存储在localStorage的数据
		loadAll(); 	
		//保存数据  
		function save(){  
			var siteurl = document.getElementById("siteurl").value;  
			var sitename = document.getElementById("sitename").value;  
			localStorage.setItem(sitename, siteurl);
			alert("添加成功");
		}
		//查找数据  
		function find(){  
			var search_site = document.getElementById("search_site").value;  
			var sitename = localStorage.getItem(search_site);  
			var find_result = document.getElementById("find_result");  
			find_result.innerHTML = search_site + "的网址是：" + sitename;  
		}
		//将所有存储在localStorage中的对象提取出来，并展现到界面上
		function loadAll(){  
			var list = document.getElementById("list");  
			if(localStorage.length>0){  
				var result = "<table border='1'>";  
				result += "<tr><td>网站名</td><td>网址</td></tr>";  
				for(var i=0;i<localStorage.length;i++){  
					var sitename = localStorage.key(i);  
					var siteurl = localStorage.getItem(sitename);  
					result += "<tr><td>"+sitename+"</td><td>"+siteurl+"</td></tr>";  
				}  
				result += "</table>";  
 				list.innerHTML = result;  
			}else{  
				list.innerHTML = "数据为空……";  
			}  
		}      
    	</script>

	<br>

	<!-- web worker例子 即后台处理程序例子！！ -->
	<p>web worker 例子：计数器</p>
	<p>计数： <output id="jishu"></output></p>
	<button onclick="startWorker()">开始工作</button> 
	<button onclick="stopWorker()">停止工作</button>
	<script>
		var w;	
		function startWorker() {
		    if(typeof(Worker) !== "undefined") {
		        if(typeof(w) == "undefined") {
		            w = new Worker("demo_workers.js");	//创建 Web Worker 对象
		        }
		        w.onmessage = function(event) {		//向 web worker 添加一个 "onmessage" 事件监听器，即设置了onmessage 事件处理函数
		            document.getElementById("jishu").innerHTML = event.data; //把内容显示到id为jishu处
		        };
		    } else {
		        document.getElementById("jishu").innerHTML = "抱歉，你的浏览器不支持 Web Workers...";
		    }
		}	
		function stopWorker() 
		{ 
		    w.terminate();	//终止 Web Worker
		    w = undefined;
		}
		//webworker 补充：
		//由于 web worker 位于外部文件中，它们无法访问下列 JavaScript 对象：
		//    window 对象
		//    document 对象
		//    parent 对象
	</script>

	<!-- Server-Sent Events例子 定期更新内容！ 测试失败，因为php/asp文件好像没设么反应，不知道怎么带php/asp文件例子 -->
	<!-- 定期更新内容：指EventSource定期像远程服务器端php/asp发送请求， 远程php/asp 把新内容传回 EventSource 再显示 -->
	<p>Server-Sent Events例子 定期更新内容</p>
	<h1>获取服务端更新数据</h1>
	<div id="sse1"></div>
	<script>
		if(typeof(EventSource)!=="undefined")
		{
			//创建EventSource 对象,可以是基于php的对象，也可以是基于asp的对象
			//var source=new EventSource("demo_sse.php");	//创建一个新的 EventSource 对象，然后规定发送更新的页面的 URL（本例是 "demo_sse.php"）
			var source=new EventSource("demo_sse.asp");	//创建一个新的 EventSource 对象，然后规定发送更新的页面的 URL（本例是 "demo_sse.asp"）
			source.onmessage=function(event)	//注意是设置了onmessage 事件处理函数，每接收到一次更新，就会发生一次onmessage 事件
			{
				document.getElementById("sse1").innerHTML+=event.data + "<br>";//把内容显示到id为sse1处
			};
		}
		else
		{
			document.getElementById("sse1").innerHTML="抱歉，你的浏览器不支持 server-sent 事件...";
		}
	</script>

	<!-- web socket例子 建立一个快速的 通道 接通服务端 然后互通数据  没有可以配合调试的远程端口，所以未测试-->
	<!-- WebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议 -->
	<p>web socket例子 建立通道 互传数据</p>
	<div id="sse">
		<a href="javascript:WebSocketTest()">运行 WebSocket</a>
	</div>
	<script type="text/javascript">
		function WebSocketTest()
		{
			if ("WebSocket" in window)
			{
				alert("您的浏览器支持 WebSocket!");
				// 打开一个 web socket
				var ws = new WebSocket("ws://localhost:9998/echo");
				ws.onopen = function()
				{
					// Web Socket 已连接上，使用 send() 方法发送数据
					ws.send("发送数据");
					alert("数据发送中...");
				};			
				ws.onmessage = function (evt) 
				{ 
					var received_msg = evt.data;
					alert("数据已接收...");
				};
				ws.onclose = function()
				{ 
					// 关闭 websocket
					alert("连接已关闭..."); 
				};
			}
			else
			{
				// 浏览器不支持 WebSocket
				alert("您的浏览器不支持 WebSocket!");
			}
		}
		//创建一个支持 WebSocket 的服务 配合调试:
		//	下载 mod_pywebsocket:	git clone https://github.com/google/pywebsocket.git
		//	安装:	python setup.py build
		//		sudo python setup.py install
		//	查看文档说明:	pydoc mod_pywebsocket
		//	开启服务:sudo python standalone.py -p 9998 -w ../example/
		//		以上命令会开启一个端口号为 9998 的服务，使用 -w 来设置处理程序 echo_wsh.py 所在的目录
	</script>

</body>
</html>
/*test.html end*/











20170908
架设网站!!	
基本知识:
	主机空间:就是内容存放的服务器空间  000webhost 免费的主机空间!!
	网域名称:例如:baidu.com, 域名注册公司Godaddy
	内容管理系统(CMS): Wordpress
		
	申请了一个 000webhost 免费主机空间: 使用了 wordpress cms系统
		url: wingkidng.000webhostapp.com
		admin useser wingkidng@gmail.com
		admin password 数字加字母的
		然而这个架出来的网站只是一个页面网站,只能通过 admin 窗口管理内容,只适合做一些个人博客类的网站
		不能自主添加自定义 html,js等其他文件,不是一个真正自己假设的网站

架设web服务器(kingders)
	linux上搭的web服务器 叫 LAMP linux+apache+mysql+php
	安装apache:apt-get install apache2	
		登陆:127.0.0.1 测试成功
		Apache的默认文档根目录是在Ubuntu上的 /var/www目录
		配置文件是 /etc/apache2/apache2.conf。
		配置存储在的子目录在 /etc/apache2目录
	安装mysql: apt-get install mysql-server mysql-client 
		前面弄python时已经做好了 mysql!!
	安装PHP5: apt-get install php5
		安装Apache的PHP5的模块: apt-get install libapache2-mod-php5
		安装完需要重启 apache: /etc/init.d/apache2 restart
		添加一个测试的 phpinfo.php 在/var/www/里,浏览器 登陆 127.0.0.1/phpinfo.php测试成功
		查看 php5 的可添加扩展模块有哪些,apt-cache search php5,
		安装重要的 php 扩展模块:(包括mysql支持模块)
			apt-get install php5-mysql php5-curl php5-gd php5-idn php-pear \
			php5-imagick php5-imap php5-mcrypt php5-memcache php5-ming php5-ps \
			php5-pspell php5-recode php5-snmp php5-sqlite php5-tidy php5-xmlrpc php5-xsl
			安装完需要重启 apache: /etc/init.d/apache2 restart
			登陆:http://127.0.0.1/phpinfo.php 可以看到更多模块内容
	安装phpMyAdmin: apt-get install phpmyadmin 
		phpMyAdmin是一个网络接口，通过它可以管理你的MySQL数据库
		出现:	Web server to reconfigure automatically: 时选 apache
		出现:	The phpmyadmin package must have a database installed and configured before it can be used.
				This can be optionally handled with dbconfig-common.
			If you are an advanced database administrator and know that 
				you want to perform this configuration manually, 
				or if your database has already been installed and configured, 
				you should refuse this option.  
				Details on what needs to be done should most likely be provided in /usr/share/doc/phpmyadmin.
			Otherwise, you should probably choose this option.
			Configure database for phpmyadmin with dbconfig-common? 
			暂时选了yes
		出现:	Please provide the password for the administrative account 
				with which this package should create its MySQL database and user.
			Password of the database's administrative user:
			填了:那个数字密码
		然后有出现了: 提示填密码,确认密码,原来这里是建立mysql账户,我去
		登陆 127.0.0.1/phpMyAdmin 失败!!
		显然做 phpMyAdmin的步骤都错了,需要修改,
		到 apache 网站根目录: cd /var/www/html
		建立快捷方式到这: sudo ln -s /usr/share/phpmyadmin phpmyadmin
		登陆 127.0.0.1/phpmyadmin 成功
		然后输入 刚刚使用安装phpmyadmin时新建的mysql账户,失败!!
		终端 用 mysql 命令登陆这个新账户也不行!! (怀疑根本就没有成功建立) 
		查看安装log:	Setting up dbconfig-common (1.8.47+nmu1) ...
				Creating config file /etc/dbconfig-common/config with new version
		查看: gedit /etc/dbconfig-common/config 并没有发现什么
		查看: gedit /etc/dbconfig-common/phpmyadmin.conf,发现原来刚建立的数据库名字是 phpmyadmin
		终端 用 mysql 命令登陆这个新账户还真进去了
		登陆 127.0.0.1/phpmyadmin 然后登陆phpmyadmin账户
		查看了phpmyadmin 的账户表单发现,感觉这个账户应留着,于是打开phpmyadmin.conf 把密码隐去不显示就算了
		最后,登陆 127.0.0.1/phpmyadmin 然后登陆root账户,看到了以前改动的内容,此root是我之前建立的root
		确认 pymyadmin 可以可视化 处理 mysql database内容!
架设web服务器(win7 的 IIS web服务器)
	控制面板 -> 程序 -> 打开或关闭Windows服务 -> Internet信息服务 -> 勾选所有 -> 确定
	浏览器登录 http://localhost/，若出现IIS7欢迎界面.表示成功
	允许 局域网上的机子访问:
		设置防火墙:控制面板 -> 系统和安全 -> 允许程序通过Windows防火墙 -> 万维网服务HTTP -> 右侧的两个复选都勾上 -> 确定
		cmd.exe -> ipconfig 得到 本机ip 192.168.1.108
		同局域网其他机子浏览器登录 192.168.1.108，若出现IIS7欢迎界面.表示成功
	补充:	iis服务器的 web端口默认: 80
		更改默认端口: 开始 -> 管理工具
	至此基本完成服务器假设.(还有 php,mysql等扩充未创建)
外网映射 (kingders机子)
	架设好web服务器,如果需要供外网登陆, 又没有有可能申请公网ip,就只能使用外网映射的方式
	服务商有 花生壳 nat123 等
	安装 nat123服务:
		装环境: apt-get install mono-complete 
		测试环境: mono -v
		http://www.nat123.com 登陆配置映射了!!
			端口映射添加 -> 非80网站 ->映射线路:nat123 -> 应用名称随便填
			-> 内网端口: 8099 -> 内网网址:localhost -> 外网端口:18099 
			-> 外网域名: 410883c8.nat123.net -> 确认保存
		下载客户端脚本 到 /home/kingders/other/nat123/ 解压
		执行客户端服务:	cd /home/kingders/other/nat123/nat123linux201505
				mono nat123linux.sh
	外网机子浏览器登录:410883c8.nat123.net:18099 (注意不是:www.410883c8.nat123.net:18099)
	成功!!
外网映射 (win7 + iis)
	安装nat123 win7 版本
	http://www.nat123.com 登陆配置映射了!!
		端口映射添加 -> 80网站 ->映射线路:nat123 -> 应用名称随便填
		-> 内网端口: 80 -> 内网网址:localhost -> (外网端口固定为80,不用管) 
		-> 外网域名: 5708346c.nat123.net -> 确认保存
	登录 nat123客户端后,就会自动建立映射!!!
	然后,外网机子浏览器登录:5708346c.nat123.net (注意不是:www.5708346c.nat123.net)
	成功访问 win7 上 开启的 iis web服务器
web服务器区别:
	发现: django+uwsgi 相当于 apache 相当与 iis
	django 是单线程的,是一个web开发框架(集成简单服务器软件和网站开发框架),让开发者更简单开发网站
	uwisai 被成为是一个容器,使得django 实现多线程的操作,即扩展django的服务器软件功能,使之达到商用级别
	apache 是一个多线程完备的商用web服务器软件,但不提供网站开发框架,开发者只能原始开发网站,再加载到apache上使用	
	iis 是microsoft公司的服务器软件,不提供网站开发框架,开发者只能原始开发网站,再加载到 iis 上使用	







20170912
php学习:
	php是服务器脚本语言,当远程客户端访问 服务器的 .php 文件时,
	服务器会先解析 .php 文件内容,然后把生成的结果html页 发到远程客服端.
	这里更要注意的是:
		如果.html文件 使用<?php ?>嵌入了 php代码段, 一定要把文件扩展名改成 .php
		如果依然保留.html扩展名, php段代码将不被执行!!
		因为客户端请求.html时,服务器软件使用默认html解析器并不能解析 php段代码
		如果客户端请求.php时,服务器软件会使用php解析器解释文件,php除了可解析php段代码,还包含html解析器功能,能解析所有的html的内容!!
		架设部署的一般服务器软件不包括 php解析模块,所以需要在架设部署服务器软件时需要另外添加这个模块
	php语法内容放在 html5_learn -> php_learn
css学习:
	CSS 指层叠样式表
	CSS声明总是以分号(;)结束，声明组以大括号({})括起来:
	CSS注释以 "/*" 开始, 以 "*/" 结束, 
	HTMLid选择器 id=xx ,对应 CSS 中 id 选择器 #xx 例如:
		//.html
		<p id="xx">vvv</p>
		//.css
		#xx
		{
			text-align:center;
			color:red;
		} 
	HTML中以class属性表示 class="bbb",对应 CSS 中 类选择器 .bbb 例如:
		//.html
		<p class="bbb">vvv</p>
		//.css
		.bbb
		{
			text-align:center;
			color:red;
		} 
	HTML中以 其他属性表示,例如
		//.css
		[jjj=hello] {width:150px;} /*涵括所有 jjj属性为hello的段的css格式,即指bb,cc段*/
		cc[jjj=hello] {width:150px;} /*仅当cc段的jjj属性为hello时的格式 cc[jjj=hello] 中间不能有空格 */
		[jjj] {border:5px solid green;} /*所有含有jjj属性的段,应有的css格式,即指aa,bb,cc,段*/
		[jjj~=llo] {border:5px solid green;} /*jjj属性含有关键字符窜llo的段,应有的css格式,即指aa,bb,cc,段*/
		//.html
		<aa jjj="hellomate" kkk="nihao">哦哦哦哦哦哦哦哦哦哦</aa>
		<bb jjj="hello" kkk="nihao">哦哦哦哦哦哦哦哦哦哦</bb>
		<cc jjj="hello" kkk="nihao">哦哦哦哦哦哦哦哦哦哦</cc>

	还有专门的class属性对应,例如: html的 <p class="center">vvv</p> 对应 CSS的 p.center 例如:
		//.html
		<p class="center">vvv</p>
		//.css
		p.bbb
		{
			text-align:center;
			color:red;
		} 
	插入样式表的方法有三种:
		外部样式表(External style sheet) 例如:
			<link rel="stylesheet" type="text/css" href="bbbbb.css">
			bbbbb.css内容:
				hr {color:sienna;}
				p {margin-left:20px;}	/*不要在属性值(20px)与单位(margin-left:)之间留有空格*/
				body 
				{
					background-image:url("/images/back40.gif");
					background-color:#cccccc;
				}
		内部样式表(Internal style sheet) 例如:			
			<head>
			<style>
			hr {color:sienna;}
			p {margin-left:20px;}
			body {background-image:url("images/back40.gif");}
			</style>
			</head>
		内联样式(Inline style)例如:
			<p style="color:sienna;margin-left:20px">这是一个段落。</p>
		内联样式）Inline style > （内部样式）Internal style sheet >（外部样式）External style sheet > 浏览器默认样式
	背景:
		背景颜色,例子:
			h1 {background-color:#6495ed;}	/* h1标签的段的背景色 颜色十六进制表示 */
			p {background-color:#e0ffff;}	/* p标签的段的背景色 RGB标准表示 */
			div {background-color:#b0c4de;}	/* div标签的段的背景色 颜色名称表示 */
		背景图像,例子:
			body 	
			{
				background-image:url('paper.gif');
				background-repeat:repeat-x;	/*图像只在水平方向平铺 (repeat-x)*/
				background-repeat:no-repeat;	/*不想让图像平铺,与上述平铺不共存,只是示范而已*/
				background-position:right top;	/*改变图像在背景中的位置*/
			} 
		背景属性简写,例子:
			body {background:#ffffff url('img_tree.png') no-repeat right top;}
			属性简写时,顺序:
				background-color
				background-image
				background-repeat
				background-attachment
				background-position
	文本格式:
		文本颜色,例子:
			body {color:red;}
			h1 {color:#00ff00;}
			h2 {color:rgb(255,0,0);}
		文本对齐,例子:
			h1 {text-align:center;}
			p.date {text-align:right;}
			p.main {text-align:justify;}
		文本修饰,例子:
			a {text-decoration:none;}	/*none是删除文本的装饰,比如可以删除链接文件下划线*/
			h1 {text-decoration:overline;}	/*上画线*/
			h2 {text-decoration:line-through;}	/*中划线*/
			h3 {text-decoration:underline;}		/*下划线*/
		文本转换,例子:
			p.uppercase {text-transform:uppercase;}		/*全为大写*/
			p.lowercase {text-transform:lowercase;}		/*全为小写*/
			p.capitalize {text-transform:capitalize;}	/*单词首字母大写,其他小写*/
		文本缩进,例子:
			p {text-indent:50px;}	/*第一行的缩进50px(像素)*/
	链接样式:
		关于链接的css样式写法比较特别,例子:
		//.css
		ab:link {background-color:#B2FF99;color:#000000;text-decoration:none;}      /* 未访问链接*/
		ab:visited {background-color:#FFFF85;color:#00FF00;text-decoration:none;}  /* 已访问链接 */
		ab:hover {background-color:#FF704D;color:#FF00FF;text-decoration:underline;}  /* 鼠标移动到链接上 */
		ab:active {background-color:#FF704D;color:#0000FF;text-decoration:underline;}  /* 鼠标点击时 */
		//.html
		<ab href="www.baidu.com">这是一个链接</a>
		标识使用了":"号,而且.css设置有先后顺序:link->visited->hover->active
	CSS 列表的属性字:
		list-style
		list-style-image
		list-style-position
		ist-style-type
	CSS 字体的属性字:
		font 	在一个声明中设置所有的字体属性
		font-family 	指定文本的字体系列
		font-size 	指定文本的字体大小
		font-style 	指定文本的字体样式
		font-variant 	以小型大写字体或者正常字体显示文本。
		font-weight     指定字体的粗细。
	表格,例子:
		见 csstest.html->表格例子
	盒子模型:
		Margin(外边距) - 清除边框外的区域，外边距是透明的。
		Border(边框) - 围绕在内边距和内容外的边框。
		Padding(内边距) - 清除内容周围的区域，内边距是透明的。
    		Content(内容) - 盒子的内容，显示文本和图像。
		例子:
			div {
			    background-color: lightgrey;
			    width: 300px;
			    border: 25px solid green;
			    padding: 25px;
			    margin: 25px;
			}	
	分组 和 嵌套 选择器,例子:
		//.css
		p {color:blue;text-align:center;}
		.marked {background-color:red;}
		.marked p {color:white;}
		//.html
		<p>这个段落是蓝色文本，居中对齐。</p>
		<div class="marked"><p>这个段落不是蓝色文本。</p></div>
		<p>所有 class="marked"元素内的 p 元素指定一个样式，但有不同的文本颜色。</p>
	尺寸属性关键字:
		height 	设置元素的高度。
		line-height 	设置行高。
		max-height 	设置元素的最大高度。
		max-width 	设置元素的最大宽度。
		min-height 	设置元素的最小高度。
		min-width 	设置元素的最小宽度。
		width 	设置元素的宽度。
	显示与隐藏 属性关键字: display, visibility 例子:
		h1 {visibility:hidden;}		/*隐藏h1段内容*/
		h2 {display:none;}		/*也是隐藏例子,隐藏h2段内容*/
	定位,例子:
		p {position:fixed;top:30px;}	/* static 表示默认位置 top, bottom, left, right 无需设置 */
		p {position:fixed;top:30px;}	/* fixed 表示 top, bottom, left, right 重新定义位置 */
		h2 {position:relative;left:-20px;}/* relative 表示 top, bottom, left, right 相对位置,相对移动了多少后的位置 */
		h2 {position:absolute;left:100px;top:150px;}/* absolute 表示 top, bottom, left, right 相对<html>的绝对位置 */
	Float(浮动);
		float属性关键字,就是段内容动态位置分配原则
		例子:
			img {float:right;}	/*img段内容,按从右到左,从上到下的分布原则*/
	后代选取器,例子:
		//.html
		<div>
			<p>段落 1。 在 div 中。</p>
			<p>段落 2。 在 div 中。</p>
		</div>
		<p>段落 3。不在 div 中。</p>
		<p>段落 4。不在 div 中。</p>
		//.css
		div p {background-color:yellow;}	/*这里指向的<div>里的<p>段内容*/
	子元素选择器,例子	
		div>p {background-color:yellow;}	/*感觉与后代选取器一样的效果*/
	后邻兄弟选择器
		div+p {background-color:yellow;}	/*与<div>段相邻的后一段如果是<p>,那就是指这个<p>段*/
	后面的兄弟们选择器
		div-p {background-color:yellow;}	/*与<div>同层级,且位于<div>后的所有<p>段*/
	伪类,就是带":"号的系统类,例如之前链接时见到的 ab:link 的 :link 等
		所有CSS伪类/元素
		选择器 			示例 		示例说明
		:checked 		input:checked 	选择所有选中的表单元素
		:disabled 		input:disabled 	选择所有禁用的表单元素
		:empty 			p:empty 	选择所有没有子元素的p元素
		:enabled 		input:enabled 	选择所有启用的表单元素
		:first-of-type 		p:first-of-type 选择每个父元素是p元素的第一个p子元素
		:in-range 		input:in-range 	选择元素指定范围内的值
		:invalid 		input:invalid 	选择所有无效的元素
		:last-child 		p:last-child 	选择所有p元素的最后一个子元素
		:last-of-type 		p:last-of-type 	选择每个p元素是其母元素的最后一个p元素
		:not(selector) 		:not(p) 	选择所有p以外的元素
		:nth-child(n) 		p:nth-child(2) 	选择所有p元素的第二个子元素
		:nth-last-child(n) 	p:nth-last-child(2) 	选择所有p元素倒数的第二个子元素
		:nth-last-of-type(n) 	p:nth-last-of-type(2) 	选择所有p元素倒数的第二个为p的子元素
		:nth-of-type(n) 	p:nth-of-type(2) 	选择所有p元素第二个为p的子元素
		:only-of-type 		p:only-of-type 	选择所有仅有一个子元素为p的元素
		:only-child 		p:only-child 	选择所有仅有一个子元素的p元素
		:optional 		input:optional 	选择没有"required"的元素属性
		:out-of-range 		input:out-of-range 	选择指定范围以外的值的元素属性
		:read-only 		input:read-only 	选择只读属性的元素属性
		:read-write 		input:read-write 	选择没有只读属性的元素属性
		:required 		input:required 	选择有"required"属性指定的元素属性
		:root 			root 		选择文档的根元素
		:target 		#news:target 	选择当前活动#news元素(点击URL包含锚的名字)
		:valid 			input:valid 	选择所有有效值的属性
		:link 			a:link 		选择所有未访问链接
		:visited 		a:visited 	选择所有访问过的链接
		:active 		a:active 	选择正在活动链接
		:hover 			a:hover 	把鼠标放在链接上的状态
		:focus 			input:focus 	选择元素输入后具有焦点
		:first-letter 		p:first-letter 	选择每个<p> 元素的第一个字母
		:first-line 		p:first-line 	选择每个<p> 元素的第一行
		:first-child 		p:first-child 	选择器匹配属于任意元素的第一个子元素的 <]p> 元素
		:before 		p:before 	在每个<p>元素之前插入内容
		:after 			p:after 	在每个<p>元素之后插入内容
		:lang(language) 	p:lang(it) 	为<p>元素的lang属性选择一个开始值
	media类:
		同样的内容,在不同的终端上显示,应该有自己舒服格式,于是使用media类,例如
			<style>
			@media screen	/*应用在屏幕的格式*/
			{
			    p.test {font-family:verdana,sans-serif;font-size:14px;}
			}
			@media print	/*应用在印刷媒体的格式*/
			{
			    p.test {font-family:times,serif;font-size:10px;}
			}
			@media screen,print	/*同时应用在屏幕和印刷媒体的格式*/
			{
			    p.test {font-weight:bold;}
			}
			</style>
		@media的参数:
		all 		用于所有的媒体设备。
		aural 		用于语音和音频合成器。
		braille 	用于盲人用点字法触觉回馈设备。
		embossed 	用于分页的盲人用点字法打印机。
		handheld 	用于小的手持的设备。
		print 		用于打印机。
		projection 	用于方案展示，比如幻灯片。
		screen 		用于电脑显示器。
		tty 		用于使用固定密度字母栅格的媒体，比如电传打字机和终端。
		tv 		用于电视机类型的设备。

	css例子:
		垂直导航,下拉菜单,见csstest.html
		提示工具Tooltip, 图册,响应式图册,透明层叠的图片文字,图像拼合按钮 见csstest1.html
css3新添:
	边框圆角:
		border-radius 	所有四个边角 border-*-*-radius 属性的缩写
		border-top-left-radius 	定义了左上角的弧度
		border-top-right-radius 	定义了右上角的弧度
		border-bottom-right-radius 	定义了右下角的弧度
		border-bottom-left-radius 	定义了左下角的弧度
		例:
		div {
			border:2px solid;
			/*border-radius:25px;*/	/*统一圆角,效果见自己实验*/
			/*border-radius: 15px 50px 30px 5px:*/ /*独立圆角,效果见自己实验*/
			/*border-radius: 15px 50px 30px:*/ /*三值圆角,效果见自己实验*/
			border-radius: 15px 50px: /*双值圆角,效果见自己实验*/
		} 
	盒阴影,例:div {width:300px;height:100px;background-color:yellow;box-shadow: 10px 10px 5px #888888;}
	边界图片,例:
		div {
			border:15px solid transparent;
			width:250px;
			padding:10px 20px;
			/* border-image:url(border.png) 30 30 stretch;*/ /*图像平铺（重复）来填充边框*/
			border-image:url(border.png) 30 30 stretch;	/*图像被拉伸以填充边框*/
		}
	背景:
		图片:
			background-image
			background-position
			background-repeat:
		其他:
			background-clip 	规定背景的绘制区域。 	3
			background-origin 	规定背景图片的定位区域。 	3
			background-size 	规定背景图片的尺寸。
	渐变: background 后的函数形状参数 linear-gradient(),例如
		#grad3 {
		    height: 100px;
		    background: -webkit-linear-gradient(180deg, red, blue); /* Safari 5.1 - 6.0 */
		    background: -o-linear-gradient(180deg, red, blue); /* Opera 11.1 - 12.0 */
		    background: -moz-linear-gradient(180deg, red, blue); /* Firefox 3.6 - 15 */
		    background: linear-gradient(180deg, red, blue); /* 标准的语法（必须放在最后） */
		}
		除了linear-gradient(),还有有:
			radial-gradient(),repeating-linear-gradient(),repeating-radial-gradient()
	文本效果:
		text-shadow,文字阴影
		box-shadow,盒子阴影
		text-overflow,文字溢出(隐藏或溢出)
		word-wrap:break-word;允许自动换行
		word-break:keep-all;不拆词换行
		word-break:break-all;可拆词换行
		常用:
		hanging-punctuation 	规定标点字符是否位于线框之外。 	
		punctuation-trim 	规定是否对标点字符进行修剪。 	
		text-align-last 	设置如何对齐最后一行或紧挨着强制换行符之前的行。 	
		text-emphasis 	向元素的文本应用重点标记以及重点标记的前景色。 	
		text-justify 	规定当 text-align 设置为 "justify" 时所使用的对齐方法。 	
		text-outline 	规定文本的轮廓。 	3
		text-overflow 	规定当文本溢出包含元素时发生的事情。 	
		text-shadow 	向文本添加阴影。 	
		text-wrap 	规定文本的换行规则。 	
		word-break 	规定非中日韩文本的换行规则。 	
		word-wrap 	允许对长的不可分割的单词进行分割并换行到下一行。
		例如,添加阴影: h1 {text-shadow: 5px 5px 5px #FF0000;}
	2d/3d转换,例如:	
		translate() 平移变换
		div
		{
			width:100px;
			height:75px;
			background-color:red;
			border:1px solid black;
		}
		div#div2
		{
			transform:translate(50px,100px);	/* translate() 平移变换*/
			-ms-transform:translate(50px,100px); /* IE 9 */
			-webkit-transform:translate(50px,100px); /* Safari and Chrome */
		}
		div#div3
		{
			transform:rotate(30deg);	/*rotate() 旋转变换*/
			-ms-transform:rotate(30deg); /* IE 9 */
			-webkit-transform:rotate(30deg); /* Safari and Chrome */
		}
		div#div4
		{
			-ms-transform: scale(2,3); /* IE 9 */
			-webkit-transform: scale(2,3); /* Safari */
			transform: scale(2,3); /* 缩放变换 */
		}
		div#div5
		{
			transform: translate(50px,100px) scale(2,3);	/*多重变换*/
			-ms-transform:skew(30deg,20deg); /* IE 9 */
			-webkit-transform:skew(30deg,20deg); /* Safari and Chrome */
		}
		以下列出了所有的转换属性:
		transform 		适用于2D或3D转换的元素 	
		transform-origin 	允许您更改转化元素位置
		transform-style 	规定被嵌套元素如何在 3D 空间中显示。 	
		perspective 		规定 3D 元素的透视效果。 	
		perspective-origin 	规定 3D 元素的底部位置。 	
		backface-visibility 	定义元素在不面对屏幕时是否可见。 		
		2D 转换方法
		matrix(n,n,n,n,n,n) 	定义 2D 转换，使用六个值的矩阵。
		translate(x,y) 		定义 2D 转换，沿着 X 和 Y 轴移动元素。
		translateX(n) 		定义 2D 转换，沿着 X 轴移动元素。
		translateY(n) 		定义 2D 转换，沿着 Y 轴移动元素。
		scale(x,y) 		定义 2D 缩放转换，改变元素的宽度和高度。
		scaleX(n) 		定义 2D 缩放转换，改变元素的宽度。
		scaleY(n) 		定义 2D 缩放转换，改变元素的高度。
		rotate(angle) 		定义 2D 旋转，在参数中规定角度。
		skew(x-angle,y-angle) 	定义 2D 倾斜转换，沿着 X 和 Y 轴。
		skewX(angle) 		定义 2D 倾斜转换，沿着 X 轴。
		skewY(angle) 		定义 2D 倾斜转换，沿着 Y 轴。
		3D 转换方法
		matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) 	定义 3D 转换，使用 16 个值的 4x4 矩阵。
		translate3d(x,y,z) 	定义 3D 转化。
		translateX(x) 	定义 3D 转化，仅使用用于 X 轴的值。
		translateY(y) 	定义 3D 转化，仅使用用于 Y 轴的值。
		translateZ(z) 	定义 3D 转化，仅使用用于 Z 轴的值。
		scale3d(x,y,z) 	定义 3D 缩放转换。
		scaleX(x) 	定义 3D 缩放转换，通过给定一个 X 轴的值。
		scaleY(y) 	定义 3D 缩放转换，通过给定一个 Y 轴的值。
		scaleZ(z) 	定义 3D 缩放转换，通过给定一个 Z 轴的值。
		rotate3d(x,y,z,angle) 	定义 3D 旋转。
		rotateX(angle) 	定义沿 X 轴的 3D 旋转。
		rotateY(angle) 	定义沿 Y 轴的 3D 旋转。
		rotateZ(angle) 	定义沿 Z 轴的 3D 旋转。
		perspective(n) 	定义 3D 转换元素的透视视图。
	过渡,例如:
		div {
		    width: 100px;
		    height: 100px;
		    background: red;
		    -webkit-transition: width 2s, height 2s, -webkit-transform 2s; /* For Safari 3.1 to 6.0 */
		    transition: width 2s, height 2s, transform 2s;			}
		
		div:hover {
		    width: 200px;
		    height: 200px;
		    -webkit-transform: rotate(180deg); /* Chrome, Safari, Opera */
		    transform: rotate(180deg);
		}
		/* 当鼠标 点向<div>那段内容时,width,height,transform 
		   三个内容会经历过渡动画,转换到div:hover 后的css设置参数
		   当鼠标 离开<div>那段内容时,width,height,transform
		   三个内容会经历过渡动画,回到div的css设置参数
		 */
		过渡属性:
			transition 		简写属性，用于在一个属性中设置四个过渡属性。 
			transition-property 	规定应用过渡的 CSS 属性的名称.
			transition-duration 	定义过渡效果花费的时间。默认是 0。 
			transition-timing-function 	规定过渡效果的时间曲线。默认是 "ease"。 
			transition-delay 	规定过渡效果何时开始。默认是 0。
	动画,例如:
		//.css
		div
		{
			width:100px;
			height:100px;
			background:red;
			position:relative;
			animation-name:myfirst;		/*div里定义了一个的动画*/
			animation-duration:5s;
			animation-timing-function:linear;
			animation-delay:2s;
			animation-iteration-count:infinite;	/*无休止动画*/
			animation-direction:alternate;
			animation-play-state:running;
			/* 为了兼容 Safari and Chrome: */
			-webkit-animation-name:myfirst;
			-webkit-animation-duration:5s;
			-webkit-animation-timing-function:linear;
			-webkit-animation-delay:2s;
			-webkit-animation-iteration-count:infinite;
			-webkit-animation-direction:alternate;
			-webkit-animation-play-state:running;
		}
		
		@keyframes myfirst	/*div里定义了一个的动画变化过程*/	
		{
			0%   {background:red; left:0px; top:0px;}
			25%  {background:yellow; left:200px; top:0px;}
			50%  {background:blue; left:200px; top:200px;}
			75%  {background:green; left:0px; top:200px;}
			100% {background:red; left:0px; top:0px;}
		}
		
		@-webkit-keyframes myfirst /* 为了兼容 Safari and Chrome */
		{
			0%   {background:red; left:0px; top:0px;}
			25%  {background:yellow; left:200px; top:0px;}
			50%  {background:blue; left:200px; top:200px;}
			75%  {background:green; left:0px; top:200px;}
			100% {background:red; left:0px; top:0px;}
		}
		//.html
		<div><p><a href="www.baidu.com."> 百度</a></p></div>
		/*现象是动着的 百度链接*/
		CSS3的动画属性
			@keyframes 		规定动画。 	
			animation 		所有动画属性的简写属性，除了 animation-play-state 属性。 	
			animation-name 		规定 @keyframes 动画的名称。 	
			animation-duration 	规定动画完成一个周期所花费的秒或毫秒。默认是 0。 	
			animation-timing-function 	规定动画的速度曲线。默认是 "ease"。 	
			animation-delay 	规定动画何时开始。默认是 0。 	
			animation-iteration-count 	规定动画被播放的次数。默认是 1。 	
			animation-direction 	规定动画是否在下一周期逆向地播放。默认是 "normal"。 	
			animation-play-state 	规定动画是否正在运行或暂停。默认是 "running"。
	多列特性:(不详述)
		column-count 	指定元素应该被分割的列数。
		column-fill 	指定如何填充列
		column-gap 	指定列与列之间的间隙
		column-rule 	所有 column-rule-* 属性的简写
		column-rule-color 	指定两列间边框的颜色
		column-rule-style 	指定两列间边框的样式
		column-rule-width 	指定两列间边框的厚度
		column-span 	指定元素要跨越多少列
		column-width 	指定列的宽度
		columns 	设置 column-width 和 column-count 的简写
	用户界面新特性: (不详述)
		appearance 	允许您使一个元素的外观像一个标准的用户界面元素 	
		box-sizing 	允许你以适应区域而用某种方式定义某些元素 	
		icon 		为创作者提供了将元素设置为图标等价物的能力。 	
		nav-down 	指定在何处使用箭头向下导航键时进行导航 	
		nav-index 	指定一个元素的Tab的顺序 
		nav-left 	指定在何处使用左侧的箭头导航键进行导航 	
		nav-right 	指定在何处使用右侧的箭头导航键进行导航 	
		nav-up 		指定在何处使用箭头向上导航键时进行导航 	
		outline-offset 	外轮廓修饰并绘制超出边框的边缘 	
		resize 		指定一个元素是否是由用户调整大小
	css3新特性例子,见 html5_learn -> css_learn -> csstest2.html:
		关于图片的
		关于导航的
		关于@media 应用的 !!!









20170919
学习XML
	基本认识:
		XML 被设计用来传输和存储数据。
		XML 不会做任何事情
		XML 把数据从 HTML 分离
		XML 文档形成一种树结构
			<root>
			<child>
			<subchild>.....</subchild>
			</child>
			</root>
		XML 属性值必须加引号:
			<note date="12/11/2007">
		xml 实体引用:
			内容中含 <,>,&,'等等特定符号作为实体内容时,需要使用 &it,&gt,&amp等等来代替
			&lt; 	< 	less than
			&gt; 	> 	greater than
			&amp; 	& 	ampersand
			&apos; 	' 	apostrophe
			&quot; 	" 	quotation mark
		XML 中的注释:<!-- This is a comment -->
		XML 以 LF 存储换行
			在 Windows 应用程序中，换行通常以一对字符来存储：回车符（CR）和换行符（LF）。
			在 Unix 和 Mac OSX 中，使用 LF 来存储新行。
		xml+DTD:
			拥有正确语法的 XML 被称为"形式良好"的 XML。
			通过 DTD 验证的XML是"合法"的 XML
		xml验证: http://www.runoob.com/xml/xml-validator.html
		XML命名空间,为了区分html段符号和用户自定义的段符号 使用xmlns 定义前缀,前缀代表一个命名空间例如:
			<h:table xmlns:h="http://www.w3.org/TR/html4/">
			<h:tr>
			<h:td>Apples</h:td>
			<h:td>Bananas</h:td>
			</h:tr>
			</h:table>
			//又例如:
			<root xmlns:h="http://www.w3.org/TR/html4/"
			xmlns:f="http://www.w3cschool.cc/furniture">
			<h:table>
			<h:tr>
			<h:td>Apples</h:td>
			<h:td>Bananas</h:td>
			</h:tr>
			</h:table>
			<f:table>
			<f:name>African Coffee Table</f:name>
			<f:width>80</f:width>
			<f:length>120</f:length>
			</f:table>			
			</root> 
		ajax的实现方式就是,
			创建一个 XMLHttpRequest 对象,提交到服务器!!
			服务器分析完返回一个xml文件
			客户端浏览器的xml parser解析器 会把 XML 文档转换为 XML DOM 对象(可通过 JavaScript 操作的对象)
			DOM（Document Object Model 文档对象模型）定义了访问和操作文档的标准方法。
			以下是一个演示获取 服务器xml文件后 转为 DOM对象 然后访问显示的例子:xmltest.html
			其中往服务器请求的test_ajax_cd_catalog.xml 在php_learn里也有,查看
/*xmltest.html start*/
<!DOCTYPE html>
<html>
<head>
	<script>
	if (window.XMLHttpRequest)	
	  {// code for IE7+, Firefox, Chrome, Opera, Safari
	  xmlhttp=new XMLHttpRequest();		<!--创建一个 XMLHttpRequest 对象-->
	  }
	else
	  {// code for IE6, IE5
	  xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
	  }
	xmlhttp.open("GET","test_ajax_cd_catalog.xml",false);
	xmlhttp.send();				<!--提交到服务器-->
	xmlDoc=xmlhttp.responseXML; 		<!-- 获得返回的xml文件内容 -->
	
	x=xmlDoc.getElementsByTagName("CD");	<!-- 提取其中内容变为DOM对象 -->
	i=0;
	
	function displayCD()
	{
	artist=(x[i].getElementsByTagName("ARTIST")[0].childNodes[0].nodeValue);
	title=(x[i].getElementsByTagName("TITLE")[0].childNodes[0].nodeValue);
	year=(x[i].getElementsByTagName("YEAR")[0].childNodes[0].nodeValue);
	txt="Artist: " + artist + "<br>Title: " + title + "<br>Year: "+ year;
	document.getElementById("showCD").innerHTML=txt;
	}
	
	function next()
	{
	if (i<x.length-1)
	  {
	  i++;
	  displayCD();
	  }
	}
	
	function previous()
	{
	if (i>0)
	  {
	  i--;
	  displayCD();
	  }
	}
	</script>
</head>
<body onload="displayCD()">	
	<div id='showCD'></div><br>
	<input type="button" onclick="previous()" value="<<" />
	<input type="button" onclick="next()" value=">>" />
</body>
</html>
/*xmltest.html end*/	
		XML CDATA
			XML 文档中的所有文本均会被解析器解析,只有 CDATA 区段中的文本会被解析器忽略。
			像 "<" 和 "&" 字符在 是逃不过 xml parser 的解析的.
			所以特别的不应被parser分析的属于被传递的数据的的内容,可以透过CDATA来保护!!
			CDATA 部分由 "<![CDATA[" 开始，由 "]]>" 结束,例如:
				<script>
				<![CDATA[
				function matchwo(a,b)
				{
				if (a < b && a < 0) then
				{
				return 1;
				}
				else
				{
				return 0;
				}
				}
				]]>
				</script>
			CDATA 部分不能包含字符串 "]]>"。也不允许嵌套的 CDATA 部分。
			标记 CDATA 部分结尾的 "]]>" 不能包含空格或换行。
		xml + DOM 高级:
			获取元素的值 例子
			 txt=xmlDoc.getElementsByTagName("title")[0].childNodes[0].nodeValue;
			获取属性的值 例子
			 txt=xmlDoc.getElementsByTagName("title")[0].getAttribute("lang"); 
			改变元素的值 例子
			x=xmlDoc.getElementsByTagName("title")[0].childNodes[0];
			x.nodeValue="Easy Cooking"; 
			创建新的属性
			x=xmlDoc.getElementsByTagName("book");
			for(i=0;i<x.length;i++)
			{
				x[i].setAttribute("edition","first");
			} 
			创建元素 例子
			XML DOM 的 createElement() 方法创建一个新的元素节点。
			XML DOM 的 createTextNode() 方法创建一个新的文本节点。
			XML DOM 的 appendChild() 方法向节点添加子节点（在最后一个子节点之后）。
			下面的实例创建了一个新的元素（<edition>），带有如下文本：First，然后把它添加到第一个 <book> 元素：
				newel=xmlDoc.createElement("edition");
				newtext=xmlDoc.createTextNode("First");
				newel.appendChild(newtext);				
				x=xmlDoc.getElementsByTagName("book");
				x[0].appendChild(newel); 
			删除元素
			x=xmlDoc.getElementsByTagName("book")[0];
			x.removeChild(x.childNodes[0]); 		
	一个xml实例:
		<?xml version="1.0" encoding="UTF-8"?>	//XML 声明:它定义XML版本（1.0）和所使用的编码 UTF-8,可选部分，若存在必须文档的第一行
		<note>			//下一行描述文档的根元素
		<to>Tove</to>
		<from>Jani</from>
		<heading>Reminder</heading>
		<body>Don't forget me this weekend!</body>
		</note>			//最后一行定义根元素的结尾






20170920
研究建立一个用户系统!!!
win7安装了 wamp !!(win+apache+mysql+php)
	直接是打包的 wampserver64 版本
	然而并没有成功转换 网站根目录,暂时不管
网上下了一个电商网站 (汉潮b2b2c)
	使用 Thinkphp框架,需要ioncube的php插件
	按百度成功安装 ioncube 
打开 Thinkphp 调试:
	在网站的 主入口文件 index.php 修改:
		define("APP_DEBUG",true);
		require './ThinkPHP/ThinkPHP.php';
登录网站出错: Thinkphp 框架错误:	
	SQLSTATE[HY000] [1045] Access denied for user 'root'@'localhost' (using password: YES)
	问题根源:由于wamp第一次安装mysql,还没有设置mysql的root密码!!
	浏览器登录 localhost/phpmyadmin 用户名添root,不用密码就可登录,登录后该root账户密码
	查看 网站根目录: config.inc.php 的 mysql的帐号密码,和我们设置的一样!!
	通过phpmyadmin:
		建立一个网站指定的数据库:hanchao_b2b2c25,
		倒入数据备份: hanchao_b2b2c.sql
	重新登录localhost 成功!!! 








20170921
php中文网 找到了多个可使用实战例子
账户系统1笔记(users_reg_login): http://www.php.cn/code/3980.html
	测试过程中,验证码出现过问题,归根是php session问题,重视!
	测试过过程中 突然抽风了,测试通过!!!
	只记录v2版本的:login_v2.php logincheck_v2.php register_v2.php regcheck.php pic.php
	其中 pic.php 是关于生成验证码的!!
	另外对应的 mysql 数据库表单 新建sql命令:
		DROP DATABASE IF EXISTS userdb_v2;
		CREATE DATABASE userdb_v2 DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;
		USE userdb_v2;
		CREATE TABLE user(
		id int(11) NOT NULL AUTO_INCREMENT,
		username varchar(30) DEFAULT NULL,
		userpwd varchar(32) DEFAULT NULL,
		createtime int(11) NOT NULL,
		createip int(11) DEFAULT NULL,
		PRIMARY KEY (id)
		) ENGINE=MyISAM DEFAULT CHARSET=utf8;
		insert into user(username,userpwd) values('admin','admin');
	还有注意 insert into 语句的书写方式;
	还有根据 实际情况更改 文件中的数据库 登录账户密码:
php + html5 websocket 聊天室:(php_learn/websoket-php-chat):https://my.oschina.net/babyanzichen/blog/806864
	安装测试 kingders机: 
		terminal运行命令: php websocket.php , (各种错误,所以失败,因为django占用了8000口??)
		(退出django后,重新执行命令,虽然也有错,但这次可用了)
		还有这里占用的 8000 端口 跟 localhost的http服务 8099 端口不冲突!!!
		然后本机登录localhost:8099/html/html5_learn/php_learn/websoket-php-chat/clint.html进入聊天室
		外网用户也可以通过http://410833c8.nat123.net:18099/html/html5_learn/php_learn/websoket-php-chat/clint.html
		但是nat123并没有吧 8000 口映射出来,所以不知道为什么外网可以访问没有被映射的端口
		最后发现,websocket并没有通过nat123映射到外网,因为client.html url还是 127.0.0.1:8000!!!!!
	websocket需要另外映射到外网  (机子不要挂公司的 http 代理)
		现在设置websocket 的端口为40000,即改服务端 websocket.php
			$sk=new Sock('127.0.0.1',40000);
		nat123 官网上建立映射端口:
			  重点      名称	映射线路    内网地址    内网端口	  外网域名	      外网端口
			非80网站 -> websocket -> nat123 -> localhost -> 40000 -> 18084898.nat123.cc -> 49931
		然后client.html的 var url改成以下样子
		var url='ws://18084898.nat123.cc:49931';	//这是nat123 映射websocket的地址
		最后成功映射,外网电脑可以接入聊天室
	安装测试 公司的wamp环境机:
		登录localhost指定websoket-php-chat位置 点击 websocket.php 启动 websocket服务
		登录 client.html 客户端 			 
	先单独测试 websocket!!
		
session深入:(php_learn/session)
	测试session跨文本低级操作:
		测试页使用 ajax GET方法,给session处理文本发无意义数据,session处理文本只是改变了session值
		然后测试页成功显示了改变了的session值!!
		本地登录localhost,得到的session内容,与通过nat123映射的外网登录,得到的session值互为独立!!
websocket深入:
	websocket与http是同阶别的协议
客户端:
<html>
<head>
    <meta charset="UTF-8">
    <title>Web sockets test</title>
    <script src="jquery-min.js" type="text/javascript"></script>
    <script type="text/javascript">
        var ws;
        function ToggleConnectionClicked() {          
                try {
                    ws = new WebSocket("ws://127.0.0.1:2000");//连接服务器        
                    ws.onopen = function(event){alert("已经与服务器建立了连接\r\n当前连接状态："+this.readyState);};
                    ws.onmessage = function(event){alert("接收到服务器发送的数据：\r\n"+event.data);};
                    ws.onclose = function(event){alert("已经与服务器断开连接\r\n当前连接状态："+this.readyState);};
                    ws.onerror = function(event){alert("WebSocket异常！");};
                } catch (ex) {
                    alert(ex.message);      
                }
        };
 
        function SendData() {
            try{
                var content = document.getElementById("content").value;
                if(content){
                    ws.send(content);
                }
                
            }catch(ex){
                alert(ex.message);
            }
        };
 
        function seestate(){
            alert(ws.readyState);
        }
       
    </script>
</head>
<body>
   <button id='ToggleConnection' type="button" onclick='ToggleConnectionClicked();'>连接服务器</button><br /><br />
   <textarea id="content" ></textarea>
    <button id='ToggleConnection' type="button" onclick='SendData();'>发送我的名字：beston</button><br /><br />
    <button id='ToggleConnection' type="button" onclick='seestate();'>查看状态</button><br /><br />

</body>
</html>

服务器端:
class WS {
    var $master;  // 连接 server 的 client
    var $sockets = array(); // 不同状态的 socket 管理
    var $handshake = false; // 判断是否握手

    function __construct($address, $port){
        // 建立一个 socket 套接字
        $this->master = socket_create(AF_INET, SOCK_STREAM, SOL_TCP)   
            or die("socket_create() failed");
        socket_set_option($this->master, SOL_SOCKET, SO_REUSEADDR, 1)  
            or die("socket_option() failed");
        socket_bind($this->master, $address, $port)                    
            or die("socket_bind() failed");
        socket_listen($this->master, 2)                               
            or die("socket_listen() failed");

        $this->sockets[] = $this->master;

        // debug
        echo("Master socket  : ".$this->master."\n");

        while(true) {
            //自动选择来消息的 socket 如果是握手 自动选择主机
            $write = NULL;
            $except = NULL;
            socket_select($this->sockets, $write, $except, NULL);

            foreach ($this->sockets as $socket) {
                //连接主机的 client 
                if ($socket == $this->master){
                    $client = socket_accept($this->master);
                    if ($client < 0) {
                        // debug
                        echo "socket_accept() failed";
                        continue;
                    } else {
                        //connect($client);
                        array_push($this->sockets, $client);
                        echo "connect client\n";
                    }
                } else {
                    $bytes = @socket_recv($socket,$buffer,2048,0);
                    print_r($buffer);
                    if($bytes == 0) return;
                    if (!$this->handshake) {
                        // 如果没有握手，先握手回应
                        $this->doHandShake($socket, $buffer);
                        echo "shakeHands\n";
                    } else {
                    
                        // 如果已经握手，直接接受数据，并处理
                        $buffer = $this->decode($buffer);
                        //process($socket, $buffer); 
                        echo "send file\n";
                    }
                }
            }
        }
    }
    
    function dohandshake($socket, $req)
    {
        // 获取加密key
        $acceptKey = $this->encry($req);
        $upgrade = "HTTP/1.1 101 Switching Protocols\r\n" .
                   "Upgrade: websocket\r\n" .
                   "Connection: Upgrade\r\n" .
                   "Sec-WebSocket-Accept: " . $acceptKey . "\r\n" .
                   "\r\n";

        echo "dohandshake ".$upgrade.chr(0);           
        // 写入socket
        socket_write($socket,$upgrade.chr(0), strlen($upgrade.chr(0)));
        // 标记握手已经成功，下次接受数据采用数据帧格式
        $this->handshake = true;
    }
    
    
    function encry($req)
    {
        $key = $this->getKey($req);
        $mask = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";

        return base64_encode(sha1($key . '258EAFA5-E914-47DA-95CA-C5AB0DC85B11', true));
    }
    
    function getKey($req) 
    {
        $key = null;
        if (preg_match("/Sec-WebSocket-Key: (.*)\r\n/", $req, $match)) { 
            $key = $match[1]; 
        }
        return $key;
    }
    
    // 解析数据帧
    function decode($buffer)  
    {
        $len = $masks = $data = $decoded = null;
        $len = ord($buffer[1]) & 127;

        if ($len === 126)  {
            $masks = substr($buffer, 4, 4);
            $data = substr($buffer, 8);
        } else if ($len === 127)  {
            $masks = substr($buffer, 10, 4);
            $data = substr($buffer, 14);
        } else  {
            $masks = substr($buffer, 2, 4);
            $data = substr($buffer, 6);
        }
        for ($index = 0; $index < strlen($data); $index++) {
            $decoded .= $data[$index] ^ $masks[$index % 4];
        }
        return $decoded;
    }
    
    // 返回帧信息处理
    function frame($s) 
    {
        $a = str_split($s, 125);
        if (count($a) == 1) {
            return "\x81" . chr(strlen($a[0])) . $a[0];
        }
        $ns = "";
        foreach ($a as $o) {
            $ns .= "\x81" . chr(strlen($o)) . $o;
        }
        return $ns;
    }

    // 返回数据
    function send($client, $msg)
    {
        $msg = $this->frame($msg);
        socket_write($client, $msg, strlen($msg));
    }
}

   测试    $ws = new WS("127.0.0.1",2000);


php服务端2
//socket.php
set_time_limit(0);//永不超时
class socket{
    private $host = '127.0.0.1';
    private $port = 8080;
    private $maxuser = 10;
    public  $accept = array(); //连接的客户端
    private $cycle = array(); //循环连接池
    private $isHand = array();//握手信息


    //加载socket配置
    function __construct($host, $port, $max) {
        $this->host = $host;
        $this->port = $port;
        $this->maxuser = $max;
    }

    //挂起socket
    public function start_server() {
        //创建一个socket
        $this->socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);
        //配置socket
        socket_set_option($this->socket, SOL_SOCKET, SO_REUSEADDR, TRUE);
        //绑定接口，最多10个人连接，超过的客户端连接会返回WSAECONNREFUSED错误
        socket_bind($this->socket, $this->host, $this->port);
        //监听接口
        socket_listen($this->socket, $this->maxuser);
        while(TRUE) {
            //获取所有socket连接
            $this->cycle = $this->accept;
            $this->cycle[] = $this->socket;

            //阻塞用，有新连接时才会结束
            socket_select($this->cycle, $write, $except, null);
            foreach ($this->cycle as $k => $v) {
                //当socket运行到连接池最后一位时，开始添加连接
                if($v === $this->socket) {
                    //如果socket连接失败，跳出本次循环
                    if (($accept = socket_accept($v)) < 0) {
                        continue;
                    }
                    //连接成功加入连接池
                    $this->add_accept($accept);
                    continue;
                }

                //在连接池中搜索socket连接ID
                $acceptId = array_search($v, $this->accept);
                //如果连接没有保存至连接池，跳出本次循环
                if ($acceptId === NULL) {
                    continue;
                }
                //没消息的socket就断开
                if (!@socket_recv($v, $data, 1024, 0) || !$data) {
                    $this->close($v);
                    continue;
                }
                //检查是否握手
                if (!$this->isHand[$acceptId]) {
                    //进行握手
                    $this->upgrade($v, $data, $acceptId);
                    continue;
                }
                //将数据进行解码
                $data = $this->decode($data);
                //将信息返回给客户端
                $this->send_to_user($v,$data);
            }
            sleep(1);
        }
    }

    /**
     * 新建一个连接
     * @param $accept 套接号
     */
    private function add_accept($accept) {
        $this->accept[] = $accept;
        $accept = array_keys($this->accept);
        //获取新连接的key值，用于跟握手信息绑定
        $acceptId = end($accept);
        //添加初次连接用户握手信息
        $this->isHand[$acceptId] = FALSE;
    }


    /**
     * 关闭一个连接
     * @param $accept 套接号
     */
    private function close($accept) {
        //在连接池中搜索套接号
        $acceptId = array_search($accept, $this->accept);
        //断开socket连接
        socket_close($accept);
        //销毁变量
        unset($this->cycle[$acceptId]);
        unset($this->accept[$acceptId]);
        unset($this->isHand[$acceptId]);
    }

    /**
     * 响应升级协议，与websocket进行握手
     * @param $accept 套接号
     * @param $data websocket发送的数据
     * @param $acceptId 与套接号绑定的Id
     */
    private function upgrade($accept, $data, $acceptId) {
        //用正则表达式获取websocket传输过来的key值
        if (preg_match("/Sec-WebSocket-Key: (.*)\r\n/",$data,$match)) {
            //服务端生成对应key值返回
            $key = base64_encode(sha1($match[1] . '258EAFA5-E914-47DA-95CA-C5AB0DC85B11', true));
            $upgrade  = "HTTP/1.1 101 Switching Protocol\r\n" .
                "Upgrade: websocket\r\n" .
                "Connection: Upgrade\r\n" .
                "Sec-WebSocket-Accept: " . $key . "\r\n\r\n";  //必须以两个回车结尾
            //向套接口写入数据
            socket_write($accept, $upgrade, strlen($upgrade));
            $this->isHand[$acceptId] = TRUE;
        }
    }

    /**
     * 编码信息
     * @param $data 需要编码的数据
     */
    private function frame($data){
        //将数据转为数组，一个元素长度最高为125
        $array = str_split($data, 125);
        //添加头文件信息，不然前台无法接受
        if (count($array) == 1){
            return "\x81" . chr(strlen($array[0])) . $array[0];
        }
        $ns = "";
        foreach ($data as $v){
            $ns .= "\x81" . chr(strlen($v)) . $v;
        }
        return $ns;
    }

    /**
     * 按照websocket协议进行解码
     * @param $buffer 需要解码的数据
     */
    private function decode($buffer) {
        $len = $masks = $data = $decoded = null;
        //获取传递过来数据长度
        $len = ord($buffer[1]) & 127;
        if ($len === 126) {
            $masks = substr($buffer, 4, 4);
            $data = substr($buffer, 8);

        }
        else if ($len === 127) {
            $masks = substr($buffer, 10, 4);
            $data = substr($buffer, 14);
        }
        else {
            $masks = substr($buffer, 2, 4);
            $data = substr($buffer, 6);
        }
        //
        for ($index = 0; $index < strlen($data); $index++) {
            $decoded .= $data[$index] ^ $masks[$index % 4];
        }
        return $decoded;
    }

    /**
     * 向所有连接至socket的用户发送消息
     * @param $accept 套接号
     * @param $data 发送的数据
     */
    private function send_to_user($accept, $data){
        //添加头文件信息
        $data = $this->frame($data);
        socket_write($accept, $data, strlen($data));

    }
}
调用:
//index.php
require('socket.php');
//设置连接信息
$ws = new socket('192.168.0.114', '8080', 10);
//开启socket服务端
$ws->start_server();







20170930
laya游戏开发!!!
使用layaide,使用javascript开发
发布了的游戏包目录要放到体系完备的web服务器里,通过域名端口登录打开才行, 直接把文件拉到浏览器,并不会很好执行!!!
laya项目结构:
	.laya 		// 编译配置文件夹
	bin		// 项目开发过程中,运行调试执行文件的所在地
	 |---libs	// 可执行文件用到的 js 库,编译后,自动添加必要的库文件
	 |---res	// 放置需要使用的各种资源文件夹
	 |---index.html	// 项目开发过程中,主运行调试执行文件,注意在这里引用了src->LayaSample.js才是真正的游戏源码文件
	libs		// 其他库文件
	release		// 发布的完整游戏包所在文件夹
	src		// 我们开发的游戏的 源代码 文件夹
	 |--LayaSample.js	//新建项目时的默认 游戏源码文件,用户直接从修改这个文件开始 实现游戏!!
以uxi下是一个 完整的laya项目 例子:
/* LayaSample.js start */
(function()
{
	var Sprite  = Laya.Sprite;
	var Stage   = Laya.Stage;
	var Texture = Laya.Texture;
	var Browser = Laya.Browser;
	var Handler = Laya.Handler;
	var WebGL   = Laya.WebGL;

	(function()
	{
		// 不支持WebGL时自动切换至Canvas
		Laya.init(Browser.clientWidth, Browser.clientHeight, WebGL);

		Laya.stage.alignV = Stage.ALIGN_MIDDLE;
		Laya.stage.alignH = Stage.ALIGN_CENTER;

		Laya.stage.scaleMode = "showall";
		Laya.stage.bgColor = "#232628";

		showApe();
	})();

	function showApe()
	{
		// 方法1：使用loadImage
		var ape = new Sprite();
		Laya.stage.addChild(ape);
		ape.loadImage("res/ui/button1.png");

		// 方法2：使用drawTexture
		Laya.loader.load("res/ui/button2.png", Handler.create(this, function()
		{
			var t = Laya.loader.getRes("res/ui/button2.png");
			var ape = new Sprite();
			ape.graphics.drawTexture(t, 0, 0);
			Laya.stage.addChild(ape);
			ape.pos(200, 0);
		}));
	}
})();
/* LayaSample.js end */
项目完整,用户只是修改了 LayaSample.js 和添加了 res里的内容,其中需要调用的 图片.png 放在 bin->res->ui 目录里!!
LayaSample.js 里的代码完整, 是从laya官网截下来 button_api演示 内容!!
由于项目完整,所以,可以正常调试执行和发布成完整游戏包
进一步讨论 LayaSample.js:
(function()){})(); 既定义了函数,又执行了函数:
	function()){} 定了函数, (..)();执行了这个函数
laya引擎库函数架构笔记:
	stage 舞台类,也称背景类.
		注意Laya.Stage 与Laya.stage 指代的内容是不一样的
	sprite 一般显示对象类, 
		注意Laya.Sprite 与Laya.sprite 指代的内容是不一样的
		一个一般显示对象参数一般用 ape 表示
		pos是 ape位置
		pivot 是 ape轴心的位置
		可以相嵌组成 组合的一般显示对象!! 一个一般显示对象参数一般用 ape 表示
		var ape = new Laya.Sprite();	
		var ape1 = new Laya.Sprite();
		ape.addChild(ape1);
	swf,json动画先跳过
	
开发内容:
	1,按键随机步数, 图标去ape 到指定位置!!
	2,即时录音,即时传送,到达音频压入队列,非录音时,即空闲,播放音频,完整播完才销掉,中途被录音操作中断后,重新播放被中断音频
	3,




20170930
layabox 学习:
	基础laya库接口:
	laya.core.js是核心包，封装了显示对象渲染，事件，时间管理，时间轴动画，缓动，消息交互，socket，
		本地存储，鼠标触摸，声音，加载，颜色滤镜，位图字体等。
	laya.webgl.js 封装了webgl渲染管线，如果使用webgl渲染，可以在初始化时调用Laya.init(1136,640,laya.webgl.WebGL);
	laya.ani.js是动画模块，包含了swf动画，骨骼动画等。
	laya.filter.js包含更多webgl滤镜，比如外发光，阴影，模糊以及更多。
	laya.html.js封装了html动态排版功能。
	laya.ui.js 提供了制作UI的各种组件实现。
	laya.tilemap.js 提供tileMap解析支持。
Audio属于dom元素，带有ui界面，在移动端Audio属于边下载边播放，适合声音文件比较大的文件，
	但是Audio在移动端会有手势的限制，gesture-requirement-for-media-playback属性表明必须有用户的手势操作才可以播放。
理解了如何使用 ide 建立ui 并使用到页游里去
	先讨论 ui编辑器的:
		项目框看到我们这个页游建立了的 ui页面 或者是 动画项目,
			右键新建,可以新建 ui页面,动画等可显示项目!!
		层级框看到的是 指定的一个ui页面或者动画项目里的资源列表
			除了典型的 button,checkbox,image,典型组件外,
			还有box, list 等复合容器组件,还可以看到复合组件的层级结构
			例如我做的一个 list 组件是这样的层级结构:
				list
				| box 
				| | image
				| | checkbox
				| | label
				| | label
			即一个列表组组件是由 多个box单元构成的, 在预览窗选中list组件后, 右边的属性框的内容是这个list的属性设置
			repeatX 是指 横向显示多少个 box单元,repeatY 是指纵向显示多少个 box单元,
			一般,repeatX,Y 间接设计了真实情况下这个 list复合组件的显示占用空间,repeatX,Y越大,显示占用空间越大
			但是list复合组件,也有 一个 绝对的占用空间范围,在演示框选中list组件后,调整红框大小设置
			list包含的内容多时,自然需要滚动条, vScrollBarSkin 是设置滚动条皮肤的,
			在这里,我们直接把 资源框里的vscoll.png拉到这个属性框就可以实现了!!
		属性框:
			每个在预览窗选中的 ui组件,右边的属性框都会显示对应的属性设置内容,其中
			var 是重要参数,ui项目上 每个独立组件都需要设置,因为是供程序识别的!!
			    对于 独立的复合组件,一般只要根节点的容器组件需要设置,其字节点的容器组件或者普通组件不需要
			name 在一个 符合组建组件里, 每个子节点的部分一般都需要设置,方便复合组件内的识别
		资源框,
			就是设置ui时用到的内容,关于如何添加自己的内容到里面去,后面探讨
		设计好自己的ui后, F12 提交,然后系统自动根据内容生成ui类
	然后来到代码编辑窗口!!
		程序一般要做的是:
			laya.init()	//初始化环境
			laya.stage.xxxx = xx //设置stage
			laya.loader.load()  //预加载资源
				加载资源很有学问, 许多图片集成一张大图,然后通过,json 或者atlias 分割,
				所以加载指定的 json 或者atlias
				当然也有 独立的资源图片, 这就要加载相关的图片
				例如
				Laya.loader.load("res/atlas/comp.json", Handler.create(this, onLoaded),null, Loader.ATLAS);
				例如
        			Laya.loader.load(["res/atlas/ListPage.atlas","res/atlas/template/ButtonTab.atlas"], Handler.create(this, onLoaded));
				例如
				Laya.loader.load("res/atlas/buttonA.png", Handler.create(this, onLoaded),null, Loader.ATLAS);
			laya.loader.load里 有个 Handler.create( ) 
				表示预加载资源后做什么,很多时候是加载页面的工作了,比如上述例子的 onLoaded,
			onloader就是自定义的加载页面函数,一般内容都是
				Laya.stage.addChild();把内容加载到页面上
		然后看看如何加载 使用 ui编辑器 做好的 ui页面!!
			ui页面做好后 f12键会 自动生成一个函数!!!
			比如做了个 opq.ui 会自动生成一个 opqUI 函数
			像这样我们就可以加载和使用 ui编辑器 做好的 ui页面
				ListDemoView = new opqUI();	//使用opqUI函数启动一个UI页
				Laya.stage.addChild(ListDemoView); //把这个ui页 加载到舞台上!!
			opq.ui建了两个按钮,一个按钮的var称add,一个是del,以下就可以设置按钮点击后的响应内容!
		        //侦听增加按钮点击事件
 		        ListDemoView.add.on(Event.CLICK,this,onAddClick);
		        //侦听删除按钮点击事件
 		        ListDemoView.del.on(Event.CLICK,this,onRemoveClick);
			opq.ui建了一个list 复合组件 var属性值是 _list 以下是关于list组件的相关附加处理内容!
			//我们list的内容单元是box复合组件,array 便是这个box组件数组,这里相当于赋值一个数组,即告诉到底列表里有多少项内容
			ListDemoView._list.array = arr;
			//list渲染函数 实时渲染函数,每时没刻都根据实际情况,构造实时内容
			ListDemoView._list.renderHandler = new Handler(this, onRender);
        		//添加单元格数据源
        		ListDemoView._list.addItem({listNumber: {text:arr.length+1}});
		继承ui启动函数的做法!!!
			function TestUI(){.....}
			Laya.class(TestUI, "test_ui", opqUI);
			Laya.stage.addChild(new TestUI());
			这里 TestUI 是一个独立的函数,但里面只写了一些ui页面组件的响应函数,这是集成前的TestUI()
			class() 把 opqUI这个ui启动函数 集成到 TestUI函数上,即生成一个新的TestUI函数代替旧的TestUI
			然后就可以通过 Laya.stage.addChild(new TestUI()); 而不是 Laya.stage.addChild(new opqUI());
			的方式,启动页面并加载到舞台!!
以下是 加载ui编辑器编出来 的ui,并使用的代码的一个例子:
(function()
{
    var Stage= Laya.Stage;
    var Handler= Laya.Handler;
    var Loader= Laya.Loader;
    var WebGL = Laya.WebGL;

    var Event   = Laya.Event;
    var CheckBox = Laya.CheckBox;


     var ListDemoView;
     var arr;
    (function()
    {
         Laya.init(640,1200,WebGL);
         Laya.stage.bgColor = "#ffffff";
         Laya.stage.scaleMode = Stage.SCALE_SHOWALL;
         //预加载资源文件后执行回调
         Laya.loader.load("res/atlas/comp.json", Handler.create(this, onLoaded),null, Loader.ATLAS);
    })();
    function onLoaded(){
        ListDemoView = new learnUI();
        Laya.stage.addChild(ListDemoView);
        //获得List模拟数据，并渲染
         getListData(); 
        //侦听增加按钮点击事件
         ListDemoView.add.on(Event.CLICK,this,onAddClick);
        //侦听删除按钮点击事件
         ListDemoView.del.on(Event.CLICK,this,onRemoveClick);
    }
    function getListData(){
        //添加list数据
        arr = [];
        for (var i  = 1; i <= 30; i++) {
            arr.push({listNumber: {text:i}});
           }
        //ListDemoView._list.vScrollBarSkin='';//添加list滚动条功能（UI不可显示）
        ListDemoView._list.array = arr;//数据赋值
         //list渲染函数
          ListDemoView._list.renderHandler = new Handler(this, onRender);
         //mouseHandler: list单元格鼠标事件处理器
          ListDemoView._list.mouseHandler = new Handler(this,onMouse);
    }
    function onRender(cell,index){
         //如果索引不再可索引范围，则终止该函数
        if(index < arr.length)return;
        //获取当前渲染条目的数据
        var data = arr[index];
        //根据子节点的名字listNumber，获取子节点对象。         
        var listNumber = cell.getChildByName("listNumber") ;
        //label渲染列表文本（序号）
        listNumber.text=data.listNumber.text;
        //获取当前渲染条目的check组件
        var check=cell.getChildByName("check");
        //根据isCheck的值，确定当前check组件是否为勾选状态（可以避免出现其他多余的选中状态）
        if(data.isCheck)
        {
                check.selected=true;
        }
        else
        {
                check.selected=false;
        }
    }
    function onAddClick(){
         //添加单元格数据源
         ListDemoView._list.addItem({listNumber: {text:arr.length+1}});
    }
    function onRemoveClick(){
      //创建一个新的数组，存放移除条目后的数据
      var temp= [];
      for(var i=0;i<arr.length;i++)
      {
      //将非选中状态的条目数据存储起来
            if(!arr[i].isCheck)
            {
                  temp.push(arr[i]);
            }
      }
      arr = temp;
      //将新的数组赋值给list
      ListDemoView._list.array = arr;
    }
    function onMouse(e,index)
    {
         //鼠标单击事件触发
         if(e.type == Event.CLICK)
         {
              //判断点击事件类型,如果点中的是checkBox组件执行
            if((e.target) instanceof CheckBox)
            {
                 //记录当前条目所包含组件的数据信息(避免后续删除条目后数据结构显示错误)
                var tempObj = arr[index];
                 //根据check的选中状态，设置条目的数据信息
                 if((e.target).selected)
                 {
             ListDemoView._list.setItem(index,{listNumber:{text:tempObj.listNumber.text} ,isCheck:true});
                 }
                 else
                 {
             ListDemoView._list.setItem(index,{listNumber:{text:tempObj.listNumber.text},isCheck:false});
                 }
            }
         }
      }
})();

下一步,JS的跨文档调用学习, JS没有 class import private 概念, typescript 才有
	把js代码单独写个js文件，然后通过<script src="js文件路径"></script>这种方式调用就可以了 
研究了大打地鼠demo,发现
	首先,出现
		var GameStart = (function(_super){
		    function GameStart(a,b,c){
		        GameStart.super(this);
		        this.startBtn.on(Laya.Event.CLICK,this,this.onStartGame)
		    }
		    Laya.class(GameStart,"GameStart",_super);
		    var _proto = GameStart.prototype;
		    _proto.onStartGame = function(){
		        this.removeSelf();     
		        if(!LayaSample.game){
		            LayaSample.game = new Game();
		        }
		        LayaSample.game.gameStart();
		        Laya.stage.addChild(LayaSample.game);
		    }
		    return GameStart;
		})(ui.GameStartUI);
		这里注意 这个 var GameStart 由后面的 function(_super) 执行后得到的信息
		而这个 fuction 
			执行 Laya.class(GameStart,"GameStart",_super)后 function GameStart(a,b,c) 继承了ui.GameStartUI
			执行 var _proto = GameStart.prototype; 是 function GameStart(a,b,c) 添加了内嵌函数入口!!
			_proto.onStartGame = function(),,, 就是 function GameStart(a,b,c) 的 一个内嵌函数
			最后 return 的内容是 function GameStart(a,b,c) 继承各种内容后的同名新版本函数function GameStart(a,b,c)
			为了区别我暂取名新版本函数function GameStart(a,b,c) 为 function GameStartxxx(a,b,c)"
			相当于 var GameStart 定义了一个函数 
			var GameStart = functon GameStartxxx(a,b,c){...};
	之后出现
		LayaSample.gameStart = new GameStart(s,g,h); 中的 new GameStart(s,g,h); 指的是 var GameStart
		由于 var GameStart 就是保存了函数的变量 functon GameStartxxx(a,b,c){...};
		所以相当于 LayaSample.gameStart = new (functon GameStartxxx(s,g,h){...})(); 而s,g,h 是代替a,b,c的参数
		functon GameStartxxx(a,b,c){...} 继承集成好多东西, 但这些东西都不是执行functon GameStartxxx(){...}时直接执行的,
		这些继承集成的内容是由其他地方触发执行,所以执行functon GameStartxxx(s,g,h){...}时,
		实际就是执行旧版的 function GameStart(s,g,h) 里的内容,即只有
			GameStart.super(this); 
				//这里相当于连接继承ui.GameStartUI, 
				//这样Laya.stage.addChild(LayaSample.gameStart); 可以把ui.GameStartUI加载到 舞台上!
		        this.startBtn.on(Laya.Event.CLICK,this,this.onStartGame) 
				//这里就是给functon GameStartxxx(){...}的那些集成的内嵌函数onStartGame 配置触发接口
		由于onStartGame 是 functon GameStartxxx(a,b,c){...} 的内嵌函数,
		我们还可以 这样调用  LayaSample.gameStart.onStartGame()
这里涉及到 js 的 类构造设计,先了解 js 的类是什么鬼,详见 javascript学习
通过上述理解 函数 和 对象!!!
	首先 所有函数 都是 对象, 所以函数都有构造函数的意义
	function a() {};	//一个空函数
	var b = new a() ;	//执行a()函数,也可以称为实例化a(),这个 实例化a() 的行为 便构造了一个新的对象,一个实例a()
				//一个实例a(),即一个初始化的空间存储这个实例a(),而提供了一个指针指向了这个实例a()!!
				//但由于a()是一个空函数,所以,这个初始化空间里除了一个prototype属性指针,什么都没有
				//最后 b 得到这个实例a()对象,即 b 指向了这个初始空间
	function aa(x) {this.nb = x};	//一个含参数,有内容的函数
	var bb = new aa(1998);		//执行aa()函数,也可以称为实例化a(),这个 实例化aa() 的行为 便构造了一个新的对象,一个实例aa()
					//一个实例a(),即一个初始化的空间存储这个实例a(),而提供了一个指针指向了这个实例a()!!
					//而this 就是这空间的指针,表示aa(x)函数可以通过这个指针访问自己这个实例化空间里的内容
					//这个空间除了一个prototype属性指针外,也有一个 nb 的内容
					//函数把参数x内容给了nb 所以nb的内容是 1998
					//最后 bb 得到这个实例aa()对象,即 bb 指向了这个初始空间
	function A(){ 
		function kk(o,p) {this.pp = p+o;}
		return	kk;	
	}			//这是一个内嵌了一个函数的函数
	var c = new A() ;	//执行A()函数,也可以称为实例化A(),这个 实例化A() 的行为 便构造了一个新的对象,一个实例A()
				//一个实例A(),即一个初始化的空间存储这个实例A(),而提供了一个指针指向了这个实例a()!!
				//这个实例A()空间除了一个prototype属性指针外,存放了一个 函数 kk(o,p),
				//至于是什么存放方式未探究(存放整个函数,还是一个指向这个函数的指针)
				//函数最后是return kk ,表示最后 c得到的不是实例A(),而是函数kk(o,p)
				//注意,是函数kk(o,p)本身(应该是函数位置的指针),而不是继续让kk(o,p)执行而得到的一个实例kk(o,p)
	var d = new c (78,90);	//这时的 var c 指向 kk(o,p) 函数本身, 表示 c 就相当于 kk(o,p) 函数了
				//new c (78,90); 相当于new kk(78,90); 了
javascript类中最重要的就是prototype概念了, 详见 javascript类深入学习







20171008
XML 的 DTD:
	DTD一般定义出自定义的xml格式规范的作为特定格式,使易于管理
	DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。
	实例: xxx.xml文件
		<?xml version="1.0"?>
		<!DOCTYPE note [				//定义此文档是 note 类型的文档。
		<!ELEMENT note (to,from,heading,body)>		//定义 note 元素有四个元素："to、from、heading,、body"
		<!ELEMENT to (#PCDATA)>			//定义 to 元素为 "#PCDATA" 类型,意思是被解析的字符数据（parsed character data）
		<!ELEMENT from (#PCDATA)>		//...
		<!ELEMENT heading (#PCDATA)>		//...
		<!ELEMENT body (#PCDATA)>		//...
		]>
		<note>
		<to>Tove</to>
		<from>Jani</from>
		<heading>Reminder</heading>
		<body>Don't forget me this weekend</body>
		</note> 
	DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。
	实例: xxx2.xml文件
		<?xml version="1.0"?>
		<!DOCTYPE note SYSTEM "note.dtd">
		<note>
		  <to>Tove</to>
		  <from>Jani</from>
		  <heading>Reminder</heading>
		  <body>Don't forget me this weekend!</body>
		</note> 
	其中 note.dtd 文件
		<!ELEMENT note (to,from,heading,body)>
		<!ELEMENT to (#PCDATA)>
		<!ELEMENT from (#PCDATA)>
		<!ELEMENT heading (#PCDATA)>
		<!ELEMENT body (#PCDATA)> 
	DTD详细:
	声明元素:
		 <!ELEMENT ggg EMPTY>		//声明 ggg 是空元素,即不含子元素
		 <!ELEMENT ggg (#PCDATA)> 	//声明 ggg 只有 PCDATA 的子元素
		 <!ELEMENT ggg ANY> 		//声明 ggg 带有任何内容的元素
		 <!ELEMENT ggg (to,from,heading,body)>  //声明 ggg 元素有四个元素："to、from、heading,、body"
							//且每个元素必须且只在 ggg 元素里出现一次
		 <!ELEMENT ggg (message)> 	//声明 message 必须且只在 ggg 里出现一次
		 <!ELEMENT ggg (message+)> 	//声明 message 可在 ggg 元素内出现零次或多次。
		 <!ELEMENT note (message?)> 	//声明 message 可在 "note" 元素内出现零次或一次。
		 <!ELEMENT note (to,from,header,(message|body))> //声明了："note" 元素必须包含 "to" 元素、"from" 元素、
								 //"header" 元素，以及非 "message" 元素既 "body" 元素。
		 <!ELEMENT note (#PCDATA|to|from|header|message)*> //声明了："note" 元素可包含出现零次或多次的
								   //PCDATA、"to"、"from"、"header" 或者 "message"
	声明属性:
		 DTD:
		<!ELEMENT square EMPTY>
		<!ATTLIST square width CDATA "0">	//声明了 square 元素内涵的 witth 属性,属性类型为字符数据 (CDATA),默认属性值为0,
		合法的 XML:
		<square width="100" />		//在上面的例子中，"square" 被定义为带有 CDATA 类型的 "width" 属性的空元素。
						//如果宽度没有被设定，其默认值为0,但这里设了100
		属性类型
			CDATA 	值为字符数据 (character data)
			(en1|en2|..) 	此值是枚举列表中的一个值
			ID 	值为唯一的 id
			IDREF 	值为另外一个元素的 id
			IDREFS 	值为其他 id 的列表
			NMTOKEN 	值为合法的 XML 名称
			NMTOKENS 	值为合法的 XML 名称的列表
			ENTITY 	值是一个实体
			ENTITIES 	值是一个实体列表
			NOTATION 	此值是符号的名称
			xml: 	值是一个预定义的 XML 值
		默认属性值 内容可为以下内容 :
			值 		就是直接给一个属性值 作为默认值,
				如上述的 <!ATTLIST square width CDATA "0"> 的"0"
			#REQUIRED 	属性值是必需的,
				如 <!ATTLIST person number CDATA #REQUIRED>声明后,
				<person number ="12" />		//一定添加 number属性 要赋值,这里我们赋了个12的值
			#IMPLIED 	属性不是必需的
				如 <!ATTLIST contact fax CDATA #IMPLIED>声明后,
				<contact />			//不一定要 fax 属性,这里就没有  
			#FIXED value 	属性值是固定的	
				如 <!ATTLIST sender company CDATA #FIXED "Microsoft">
				 <sender company="Microsoft" />//一定添加 company属性且只能是 Microsoft 这个值
			(xx1|xx2|xx3)	属性值只能在之间选
				如 <!ATTLIST payment type (check|cash) "cash"> 声明后  //这里默认是cash
				<payment type="check" /> 或 <payment type="cash" />   //只能是cash 和 check 选
	声明实体:
		DTD 实例:
		<!ENTITY writer "Donald Duck.">
		<!ENTITY copyright "Copyright W3CSchool.cc">
		XML 实例：
		<author>&writer;&copyright;</author> 
	外部实体声明: 这个实体就是整个dtd文件
		<!ENTITY writer SYSTEM "http://www.w3cschool.cc/entities.dtd">
		<!ENTITY copyright SYSTEM "http://www.w3cschool.cc/entities.dtd">
		XML 实例:
		<author>&writer;&copyright;</author> 
		然后,这俩个.dtd的内容会完全拷贝到 &writer 和 &copyright 的占位符位置上





20171020
xml 的 DOM
	DOM 定义了所有文档元素的对象和属性，以及访问它们的方法（接口）。被分为 3 个不同的部分/级别：
		核心 DOM - 用于任何结构化文档的标准模型
		XML DOM - 用于 XML 文档的标准模型
			XML DOM 定义了所有 XML 元素的对象和属性，以及访问它们的方法（接口）。
			换句话说：XML DOM 是用于获取、更改、添加或删除 XML 元素的标准。
		HTML DOM - 用于 HTML 文档的标准模型
			HTML DOM 定义了所有 HTML 元素的对象和属性，以及访问它们的方法（接口）。
	DTD 是定义了 一个xml 里应该 有什么节点 节点都是什么属性, 而 DOM 就是为操作这些节点 及节点内容的一套方法接口.
		主要是通过节点解释器来 处理节点内容
	DOM方式 加载 XML 例如:
		loadxmldoc.js:
			function loadXMLDoc(dname)
			{
			    if (window.XMLHttpRequest)
			    {
			        xhttp=new XMLHttpRequest();
			    }
			    else
			    {
			        xhttp=new ActiveXObject("Microsoft.XMLHTTP");
			    }
			    xhttp.open("GET",dname,false);
			    xhttp.send();
			    return xhttp.responseXML;
			}
		test.html
			<!DOCTYPE html>
			<html>
			<head>
			<script src="loadxmldoc.js"></script>
			</head>
			<body>
			<script>
			xmlDoc=loadXMLDoc("books.xml");		
			document.write(xmlDoc.getElementsByTagName("title")[0].childNodes[0].nodeValue + "<br>");
			document.write(xmlDoc.getElementsByTagName("author")[0].childNodes[0].nodeValue + "<br>");
			document.write(xmlDoc.getElementsByTagName("year")[0].childNodes[0].nodeValue);
			</script>
			</body>
			</html>
			其中 XMLHttpRequest ActiveXObject 就是 xml 的获取,xhttp.send()远程获取xml文件,
			并加载到 xhttp.responseXML 这个DOM对象里
			诸如 xmlDoc.getElementsByTagName("title")[0].childNodes[0].nodeValue 就是典型的 DOM 方法 获取节点内容
		再如:
		oadxmlstring.js 文件代码：
			function loadXMLString(txt) 
			{
			    if (window.DOMParser)
			    {
			        parser=new DOMParser();
			        xmlDoc=parser.parseFromString(txt,"text/xml");
			    }
			    else 
			    {
			        // Internet Explorer
			        xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
			        xmlDoc.async=false;
			        xmlDoc.loadXML(txt); 
			    }
			    return xmlDoc;
			}
		test2.html
			<!DOCTYPE html>
			<html>
			<head>
			<script src="loadxmlstring.js"></script>
			</head>
			<body>
			<script>
			text="<bookstore><book>";
			text=text+"<title>Everyday Italian</title>";
			text=text+"<author>Giada De Laurentiis</author>";
			text=text+"<year>2005</year>";
			text=text+"</book></bookstore>";	
			xmlDoc=loadXMLString(text);
			document.write(xmlDoc.getElementsByTagName("title")[0].childNodes[0].nodeValue);
			document.write("<br>");
			document.write(xmlDoc.getElementsByTagName("author")[0].childNodes[0].nodeValue);
			document.write("<br>");
			document.write(xmlDoc.getElementsByTagName("year")[0].childNodes[0].nodeValue);
			</script>
			</body>
			</html>
			其中 parser.parseFromString loadXML(txt) xmlDoc.loadXML(txt) 都是把一个xml样式的字符串像xml一样加载成 DOM 对象来使用
			其中发现,这里的	return xmlDoc 而不是 return xmlDoc.responseXML; 这是因为,xml斌不是通过http获取的,
			所以这里 xmlDoc 先当于之前的 xhttp.responseXML的内容,都是加载好xml文件的 DOM 对象 !!!
	一些典型的 XML DOM 属性：
		x.nodeName - x 的名称
		x.nodeValue - x 的值
		x.parentNode - x 的父节点
		x.childNodes - x 的子节点
		x.attributes - x 的属性节点
	XML DOM 一般方法
		x.getElementsByTagName(name) - 获取带有指定标签名称的所有元素
		x.appendChild(node) - 向 x 插入子节点
		x.removeChild(node) - 从 x 删除子节点
		从上述例子分析:  xmlDoc.getElementsByTagName("title")[0].childNodes[0].nodeValue
			xmlDoc - 由解析器创建的 XML DOM 对象
			getElementsByTagName("title")[0] - 第一个 <title> 元素
			childNodes[0] - <title> 元素的第一个子节点（文本节点）
			nodeValue - 节点的值（文本本身）
		再如:
		xmlDoc=loadXMLDoc("books.xml");
		x=xmlDoc.getElementsByTagName("title");		
 		for (i=0;i<x.length;i++)
		{
		  document.write(x[i].childNodes[0].nodeValue);
		  document.write("");
		}
		x 是一个 所有 title 节点的数组
		这里是获取每个 title 节点 的第0个字节点的节点值 (夹在头尾节点label 中间的文本内容)
		再如:
		xmlDoc=loadXMLDoc("books.xml");
 		x=xmlDoc.getElementsByTagName("book")[0].attributes; 
		document.write(x.getNamedItem("category").nodeValue);
		document.write("" + x.length);
		x 是 book 节点里 的 多个属性数组
		这里是 得到 book节点里category属性的属性值!!
		再如:
		xmlDoc=loadXMLDoc("books.xml");
		txt=xmlDoc.getElementsByTagName("title")[0].getAttribute("lang"); 
		结果：txt = "en"
		这里是使用 getAttribute 获取属性的属性值
		再如:
		xmlDoc=loadXMLDoc("books.xml");
		x=xmlDoc.getElementsByTagName("title")[0].getAttributeNode("lang");
		txt=x.nodeValue; 
		结果：txt = "en"
		这里是使用 getAttributeNode 先获取属性节点
	一个xml片段:以下讨论与这片段的格式有关:
		book.xml:
		<bookstore>
		    <book category="cooking">
		        <title lang="en">Everyday Italian</title>
		        <author>Giada De Laurentiis</author>
		        <year>2005</year>
		        <price>30.00</price>
		    </book>
		</bookstore>

	XML DOM 补充方法:
		获得属性的属性值:
			xmlDoc=loadXMLDoc("books.xml");
	 		x=xmlDoc.getElementsByTagName("book")[0].attributes; 
			document.write(x.getNamedItem("category").nodeValue);
			document.write("" + x.length);
			x 是 book 节点里 的 多个属性数组
			这里是 得到 book节点里category属性的属性值!!
			再如:
			xmlDoc=loadXMLDoc("books.xml");
			txt=xmlDoc.getElementsByTagName("title")[0].getAttribute("lang"); 
			结果：txt = "en"
			这里是使用 getAttribute 获取属性的属性值
			再如:
			xmlDoc=loadXMLDoc("books.xml");
			x=xmlDoc.getElementsByTagName("title")[0].getAttributeNode("lang");
			txt=x.nodeValue; 
			结果：txt = "en"
			这里是使用 getAttributeNode 先获取属性节点
		改变文本节点的值,如
			xmlDoc=loadXMLDoc("books.xml");
			x=xmlDoc.getElementsByTagName("title")[0].childNodes[0];
			x.nodeValue="Easy Cooking"; 
		改变属性的值,如
			xmlDoc=loadXMLDoc("books.xml");
			x=xmlDoc.getElementsByTagName('book');
			x[0].setAttribute("category","food");
			吧 category 属性的属性值改为 food
			也可以:
			xmlDoc=loadXMLDoc("books.xml");
			x=xmlDoc.getElementsByTagName("book")[0]
			y=x.getAttributeNode("category");
			y.nodeValue="food"; 
		删除元素节点
			xmlDoc=loadXMLDoc("books.xml");
			y=xmlDoc.getElementsByTagName("book")[0];
			xmlDoc.documentElement.removeChild(y); 
		删除自身 - 删除当前的节点
			xmlDoc=loadXMLDoc("books.xml");
			x=xmlDoc.getElementsByTagName("book")[0];
			x.parentNode.removeChild(x); 
		删除文本节点:
			xmlDoc=loadXMLDoc("books.xml");
			x=xmlDoc.getElementsByTagName("title")[0];
			y=x.childNodes[0];
			x.removeChild(y); 
		清空文本节点:
			xmlDoc=loadXMLDoc("books.xml");
			x=xmlDoc.getElementsByTagName("title")[0].childNodes[0];
			x.nodeValue=""; 
		根据名称删除属性节点:
			xmlDoc=loadXMLDoc("books.xml");
			x=xmlDoc.getElementsByTagName("book");
			x[0].removeAttribute("category"); 
			其中 removeAttribute(name) 方法用于根据名称删除属性节点。
		根据对象删除属性节点
			xmlDoc=loadXMLDoc("books.xml");
			x=xmlDoc.getElementsByTagName("book");
			for (i=0;i<x.length;i++)
			{
			  while (x[i].attributes.length>0)
			  {
			    attnode=x[i].attributes[0];
			    old_att=x[i].removeAttributeNode(attnode);
			  }
			}
			例子是删除所有 <book> 元素的所有属性：
			其中 removeAttributeNode(node) 方法通过使用 node 对象作为参数，来删除属性节点。
		替换元素节点
			replaceChild() 方法用于替换节点。
			下面的代码片段替换第一个 <book> 元素：
			xmlDoc=loadXMLDoc("books.xml");		 
			x=xmlDoc.documentElement;			 
			// 创建新的 book 元素, title 元素及 node 节点
			newNode=xmlDoc.createElement("book");
			newTitle=xmlDoc.createElement("title");
			newText=xmlDoc.createTextNode("A Notebook"); 
			// 将 text 节点添加到 title 节点中
			newTitle.appendChild(newText);
			// 将 title 节点添加到  book 节点中
			newNode.appendChild(newTitle);
			y=xmlDoc.getElementsByTagName("book")[0]
			// 使用新节点替换第一个 book 节点
			x.replaceChild(newNode,y);
		替换文本节点中的数据
			replaceData() 方法用于替换文本节点中的数据。
			replaceData() 方法有三个参数：
			    offset - 在何处开始替换字符。offset 值以 0 开始。
			    length - 要替换多少字符
			    string - 要插入的字符串
			实例
			xmlDoc=loadXMLDoc("books.xml");
			x=xmlDoc.getElementsByTagName("title")[0].childNodes[0];
			x.replaceData(0,8,"Easy"); 
		使用 nodeValue 替换文本节点中的数据
			xmlDoc=loadXMLDoc("books.xml");
			x=xmlDoc.getElementsByTagName("title")[0].childNodes[0];
			x.nodeValue="Easy Italian"; 
		创建新的元素节点
			xmlDoc=loadXMLDoc("books.xml");
			newel=xmlDoc.createElement("edition");
			x=xmlDoc.getElementsByTagName("book")[0];
			x.appendChild(newel); 
		创建新的属性节点
			xmlDoc=loadXMLDoc("books.xml");
			newatt=xmlDoc.createAttribute("edition");
			newatt.nodeValue="first";
			x=xmlDoc.getElementsByTagName("title");
			x[0].setAttributeNode(newatt); 
		使用 setAttribute() 创建属性
			xmlDoc=loadXMLDoc("books.xml");
			x=xmlDoc.getElementsByTagName('book');
			x[0].setAttribute("edition","first"); 
		创建文本节点
			xmlDoc=loadXMLDoc("books.xml");
			newel=xmlDoc.createElement("edition");
			newtext=xmlDoc.createTextNode("first");
			newel.appendChild(newtext);
			x=xmlDoc.getElementsByTagName("book")[0];
			x.appendChild(newel); 
			使用 loadXMLDoc() 把 "books.xml" 载入 xmlDoc 中
			创建一个新元素节点 <edition>
			创建一个新的文本节点，其文本是 "first"
			向这个元素节点追加新的文本节点
			向第一个 <book> 元素追加新的元素节点
		创建 CDATA Section 节点
			xmlDoc=loadXMLDoc("books.xml");
			newCDATA=xmlDoc.createCDATASection("Special Offer & Book Sale");
			x=xmlDoc.getElementsByTagName("book")[0];
			x.appendChild(newCDATA); 
			使用 loadXMLDoc() 把 "books.xml" 载入 xmlDoc 中
			创建一个新的 CDATA section 节点
			向第一个 <book> 元素追加这个新的 CDATA section 节点
		创建注释节点
			xmlDoc=loadXMLDoc("books.xml");
			newComment=xmlDoc.createComment("Revised March 2008");
			x=xmlDoc.getElementsByTagName("book")[0];
			x.appendChild(newComment); 
			使用 loadXMLDoc() 把 "books.xml" 载入 xmlDoc 中
			创建一个新的注释节点
			把这个新的注释节点追加到第一个 <book> 元素
		添加节点 - appendChild() 例子见上述
		插入节点 - insertBefore()
			insertBefore()方法用于在指定的子节点之前插入节点。
			实例:
			xmlDoc=loadXMLDoc("books.xml");
			newNode=xmlDoc.createElement("book");
			x=xmlDoc.documentElement;
			y=xmlDoc.getElementsByTagName("book")[3];
			x.insertBefore(newNode,y); 
		向文本节点添加文本 - insertData()
			insertData() 方法将数据插入已有的文本节点中。
			insertData() 方法有两个参数：
			    offset - 在何处开始插入字符（以 0 开始）
			    string - 要插入的字符串
			下面的代码片段将把 "Easy" 添加到已加载的 XML 的第一个 <title> 元素的文本节点：
			实例
			xmlDoc=loadXMLDoc("books.xml");
			x=xmlDoc.getElementsByTagName("title")[0].childNodes[0];
			x.insertData(0,"Easy "); 
		克隆节点:
			xmlDoc=loadXMLDoc("books.xml");
			x=xmlDoc.getElementsByTagName('book')[0];
			cloneNode=x.cloneNode(true);
			xmlDoc.documentElement.appendChild(cloneNode);
			把克隆了的节点又加到里面!!
	实际使用过程中,比较实用的节点关系!!!!
		父节点 parentNode 例如:
			xmlDoc=loadXMLDoc("books.xml");
			x=xmlDoc.getElementsByTagName("book")[0];
			document.write(x.parentNode.nodeName);
		子节点数组 childNodes 例如:
			x=xmlDoc.getElementsByTagName("title")[0];
			y=x.childNodes[0];
			txt=y.nodeValue; 
		第一个子节点 firstChild
		最后一个子节点 lastChild
		下一个节点 nextSibling 例如:
			避免空节点:
			function get_nextSibling(n)
			{
			  y=n.nextSibling;
			  while (y.nodeType!=1)
			  {
			    y=y.nextSibling;
			  }
			  return y;
			}
			元素节点的类型是 1。如果同级节点不是元素节点，就移动到下一个节点，直到找到元素节点为止。
			通过这个办法，在 Internet Explorer 和 Firefox 中，都可以得到相同的结果。
		上一个子节点 previousSibling
	补充, 
		微软浏览器不会把节点里的文本中出现的空格和换行当成一个节点, 但是其他浏览器会
		





20171024
javascript学习  
JavaScript 数据类型   
	字符串（String）、数字(Number)、布尔(Boolean)、数组(Array)、对象(Object)、空（Null）、未定义（Undefined）。
JavaScript 拥有动态类型,这意味着相同的变量可用作不同的类型：
	实例
	var x;               // x 为 undefined
	var x = 5;           // 现在 x 为数字
	var x = "John";      // 现在 x 为字符串
JavaScript 字符串
	字符串可以是引号中的任意文本。您可以使用单引号或双引号：
	实例
	var carname="Volvo XC60";
	var carname='Volvo XC60';
	您可以在字符串中使用引号，只要不匹配包围字符串的引号即可：
	实例
	var answer="It's alright";
	var answer="He is called 'Johnny'";
	var answer='He is called "Johnny"';
JavaScript 只有一种数字类型。数字可以带小数点，也可以不带：
	实例
	var x1=34.00;      //使用小数点来写
	var x2=34;         //不使用小数点来写
	极大或极小的数字可以通过科学（指数）计数法来书写：
	实例
	var y=123e5;      // 12300000
	var z=123e-5;     // 0.00123
JavaScript 布尔（逻辑）只能有两个值：true 或 false。
	var x=true;
	var y=false;
JavaScript 数组 
	实例
	var cars=new Array();
	cars[0]="Saab";
	cars[1]="Volvo";
	cars[2]="BMW";
	或者 (condensed array):
	var cars=new Array("Saab","Volvo","BMW");
	或者 (literal array):
	实例
	var cars=["Saab","Volvo","BMW"];

	定义数组元素，最后不能添加逗号,错误的定义方式：
	points = [40, 100, 1, 5, 25, 10,];
JavaScript 对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔：
	var person={firstname:"John", lastname:"Doe", id:5566};
	上面例子中的对象 (person) 有三个属性：firstname、lastname 以及 id。
	空格和折行无关紧要。声明可横跨多行：
	var person={
	firstname : "John",
	lastname  : "Doe",
	id        :  5566
	};
	对象属性有两种寻址方式：
	实例
	name=person.lastname;
	name=person["lastname"];
Undefined 和 Null
	Undefined 这个值表示变量不含有值。undefined 是指变量为未知类型,不是变量的值
	可以通过将变量的值设置为 null 来清空变量。
	实例
	cars=null;
	person=null;
声明变量类型
	当您声明新变量时，可以使用关键词 "new" 来声明其类型：
	var carname=new String;
	var x=      new Number;
	var y=      new Boolean;
	var cars=   new Array;
	var person= new Object;
还有一种是变量类型是 函数 ??? 在laya项目中发现的
	实例
	var ham = (fuction(_super){.. return bb;})(kk) ; //实际上是执行了 执行后面的函数, 得到的 bb 赋值给 ham 变量
							 //kk 是 函数的变量,即赋给 _super的 
	var cc = new ham ();	//new ham () 中 ham () 是一个函数!!, 但是ham是一个变量,所以是什么回事??
				//原来 (fuction(_super){.. return bb;})(kk) 构造了一个函数,
				//及最后的 bb的内容是 bb = function xxx(){}, 而 var ham = bb
				//所以var cc = new ham (); 就相当于 var cc = new (function xxx(){}) ();
				//如果 (fuction(_super){.. return bb;})(kk) 构造了的函数需要带参数,
				//即 bb = function xxx(a,b,c){}	比如带三个参数位
				//那么 var cc = new ham (o,pp,q); 也要填进去三个参数!!
	注意与以下对比
	function ham(){... return bb;};
	var cc = new ham ();	//这里的的()就是说要传递参数的意思, 因为 ham () 是一个函数	
javascript类学习
Javascript 面向对象编程（一）：封装  http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html
	Javascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。
	但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。
	那么，如果我们要把"属性"（property）和"方法"（method），封装成一个对象，甚至要从原型对象生成一个实例对象，我们应该怎么做呢？

一、 生成实例对象的原始模式
	假定我们把猫看成一个对象，它有"名字"和"颜色"两个属性。
	    　　var Cat = {
	    　　　　name : '',
	    　　　　color : ''
	    　　}
	现在，我们需要根据这个原型对象的规格（schema），生成两个实例对象
	    　　var cat1 = {}; // 创建一个空对象
	    　　　　cat1.name = "大毛"; // 按照原型对象的属性赋值
	    　　　　cat1.color = "黄色";
	    　　var cat2 = {};
	    　　　　cat2.name = "二毛";
	    　　　　cat2.color = "黑色";
	好了，这就是最简单的封装了，把两个属性封装在一个对象里面。但是，这样的写法有两个缺点，
		一是如果多生成几个实例，写起来就非常麻烦；
		二是实例与原型之间，没有任何办法，可以看出有什么联系。
二、 原始模式的改进
	我们可以写一个函数，解决代码重复的问题。
	    　　function Cat(name,color) {	
	    　　　　return {
	    　　　　　　name:name,
	    　　　　　　color:color
	    　　　　}
	    　　}
	然后生成实例对象，就等于是在调用函数：
	    　　var cat1 = Cat("大毛","黄色");
	    　　var cat2 = Cat("二毛","黑色");
	这种方法的问题依然是，cat1和cat2之间没有内在的联系，不能反映出它们是同一个原型对象的实例。
三、 构造函数模式
	为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。
	所谓"构造函数"，其实就是一个普通函数，但是内部使用了this变量。
	对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。
	比如，猫的原型对象现在可以这样写，
	    　　function Cat(name,color){
	    　　　　this.name=name;
	    　　　　this.color=color;
	    　　}
	我们现在就可以生成实例对象了。
	    　　var cat1 = new Cat("大毛","黄色");
	    　　var cat2 = new Cat("二毛","黑色");
	    　　alert(cat1.name); // 大毛
	    　　alert(cat1.color); // 黄色
	这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数。
	    　　alert(cat1.constructor == Cat); //true
	    　　alert(cat2.constructor == Cat); //true
	Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。
	    　　alert(cat1 instanceof Cat); //true
	    　　alert(cat2 instanceof Cat); //true
四、构造函数模式的问题
	构造函数方法很好用，但是存在一个浪费内存的问题。
	请看，我们现在为Cat对象添加一个不变的属性type（种类），再添加一个方法eat（吃）。那么，原型对象Cat就变成了下面这样：
	    　　function Cat(name,color){
	    　　　　this.name = name;
	    　　　　this.color = color;
	    　　　　this.type = "猫科动物";
	    　　　　this.eat = function(){alert("吃老鼠");};
	    　　}
	还是采用同样的方法，生成实例：
	    　　var cat1 = new Cat("大毛","黄色");
	    　　var cat2 = new Cat ("二毛","黑色");
	    　　alert(cat1.type); // 猫科动物
	    　　cat1.eat(); // 吃老鼠
	表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，
	每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。	
	    　　alert(cat1.eat == cat2.eat); //false	
	能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的。
五、 Prototype模式
	Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。
	这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。
	    　　function Cat(name,color){
	    　　　　this.name = name;
	    　　　　this.color = color;
	    　　}
	    　　Cat.prototype.type = "猫科动物";
	    　　Cat.prototype.eat = function(){alert("吃老鼠")};
	然后，生成实例。
	    　　var cat1 = new Cat("大毛","黄色");
	    　　var cat2 = new Cat("二毛","黑色");
	    　　alert(cat1.type); // 猫科动物
	    　　cat1.eat(); // 吃老鼠
	这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。
	    　　alert(cat1.eat == cat2.eat); //true
六、 Prototype模式的验证方法
	为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。，
	6.1 isPrototypeOf()
	这个方法用来判断，某个proptotype对象和某个实例之间的关系。
	    　　alert(Cat.prototype.isPrototypeOf(cat1)); //true
	    　　alert(Cat.prototype.isPrototypeOf(cat2)); //true
	6.2 hasOwnProperty()
	每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。
	    　　alert(cat1.hasOwnProperty("name")); // true
	    　　alert(cat1.hasOwnProperty("type")); // false
	6.3 in运算符
	in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。
	    　　alert("name" in cat1); // true
	    　　alert("type" in cat1); // true
	in运算符还可以用来遍历某个对象的所有属性。
	    　　for(var prop in cat1) { alert("cat1["+prop+"]="+cat1[prop]); }

Javascript面向对象编程（二）：构造函数的继承
今天要介绍的是，对象之间的"继承"的五种方法。
	比如，现在有一个"动物"对象的构造函数。
	    　　function Animal(){
	    　　　　this.species = "动物";
	    　　}
	还有一个"猫"对象的构造函数。
	    　　function Cat(name,color){
	    　　　　this.name = name;
	    　　　　this.color = color;
	    　　}	
	怎样才能使"猫"继承"动物"呢？
一、 构造函数绑定
	第一种方法也是最简单的方法，使用call或apply方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行：
	    　　function Cat(name,color){
	    　　　　Animal.apply(this, arguments);
	    　　　　this.name = name;
	    　　　　this.color = color;
	    　　}
	    　　var cat1 = new Cat("大毛","黄色");
	    　　alert(cat1.species); // 动物	
二、 prototype模式
	第二种方法更常见，使用prototype属性。
	如果"猫"的prototype对象，指向一个Animal的实例，那么所有"猫"的实例，就能继承Animal了。
	    　　Cat.prototype = new Animal();
	    　　Cat.prototype.constructor = Cat;
	    　　var cat1 = new Cat("大毛","黄色");
	    　　alert(cat1.species); // 动物
		代码的第一行，我们将Cat的prototype对象指向一个Animal的实例。
		    　　Cat.prototype = new Animal();
		它相当于完全删除了prototype 对象原先的值，然后赋予一个新值。但是，第二行又是什么意思呢？
		    　　Cat.prototype.constructor = Cat;
		原来，任何一个prototype对象都有一个constructor属性，指向它的构造函数。
		如果没有"Cat.prototype = new Animal();"这一行，Cat.prototype.constructor是指向Cat的；
		加了"Cat.prototype = new Animal();"这一行以后，Cat.prototype.constructor指向Animal。
		    　　alert(Cat.prototype.constructor == Animal); //true
		更重要的是，每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。
		    　　alert(cat1.constructor == Cat.prototype.constructor); // true
		因此，在运行"Cat.prototype = new Animal();"这一行之后，cat1.constructor也指向Animal！
		    　　alert(cat1.constructor == Animal); // true
	这显然会导致继承链的紊乱（cat1明明是用构造函数Cat生成的），
	因此我们必须手动纠正，将Cat.prototype对象的constructor值改为Cat。这就是第二行的意思。
	这是很重要的一点，编程时务必要遵守。下文都遵循这一点，即如果替换了prototype对象，
	    　　o.prototype = {};
	那么，下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。
	    　　o.prototype.constructor = o;
三、 直接继承prototype
	第三种方法是对第二种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。
	所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。
	现在，我们先将Animal对象改写：
	    　　function Animal(){ }	
	    　　Animal.prototype.species = "动物";
	然后，将Cat的prototype对象，然后指向Animal的prototype对象，这样就完成了继承。
	    　　Cat.prototype = Animal.prototype;
	    　　Cat.prototype.constructor = Cat;
	    　　var cat1 = new Cat("大毛","黄色");
	    　　alert(cat1.species); // 动物
	与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Animal的实例了），比较省内存。
	缺点是 Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。
	所以，上面这一段代码其实是有问题的。请看第二行
	    　Cat.prototype.constructor = Cat;
	这一句实际上把Animal.prototype对象的constructor属性也改掉了！
	    　　alert(Animal.prototype.constructor); // Cat
四、 利用空对象作为中介 //关于这个中介的解释还是很鸡肋,建议不要被误导
	由于"直接继承prototype"存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介。
	    　　var F = function(){};
	    　　F.prototype = Animal.prototype;
	    　　Cat.prototype = new F();   //这步关键,
	    　　Cat.prototype.constructor = Cat;
	F是空对象，所以几乎不占内存。因为是F.prototype = Animal.prototype; 而不是F = Animal.prototype;
	又 Cat.prototype = new F();
	所以 Cat.prototype.constructor == F.constructor , 因为 F.constructor 又没东西,只是 F.prototype 有东西
	这时，修改Cat.prototype.constructor，修改了F.constructor,
	没有修改F.prototype.constructor,所以不会影响到Animal的prototype对象。
	    　　alert(Animal.prototype.constructor); // Animal
	我们将上面的方法，封装成一个函数，便于使用。
	    　　function extend(Child, Parent) {
	    　　　　var F = function(){};
	    　　　　F.prototype = Parent.prototype;
	    　　　　Child.prototype = new F();
	    　　　　Child.prototype.constructor = Child;
	    　　　　Child.uber = Parent.prototype;
	    　　}
	使用的时候，方法如下
	    　　extend(Cat,Animal);
	    　　var cat1 = new Cat("大毛","黄色");
	    　　alert(cat1.species); // 动物
		但是读取cat1.species时, 等于的读取 Cat.prototype.spepices 等于读取 F.spepices
		由于 F.spepices 没有东西,
		所以,等于读取 F.prototype.spepices 等于读取 Animal.prototype.spepices
	这个extend函数，就是YUI库如何实现继承的方法。
	另外，说明一点，函数体最后一行
	    　　Child.uber = Parent.prototype;
		意思是为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。
		（uber是一个德语词，意思是"向上"、"上一层"。）这等于在子对象上打开一条通道，
		可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。
五、 拷贝继承
	上面是采用prototype对象，实现继承。我们也可以换一种思路，纯粹采用"拷贝"方法实现继承。
	简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗？这样我们就有了第五种方法。
	首先，还是把Animal的所有不变属性，都放到它的prototype对象上。
	    　　function Animal(){}
	    　　Animal.prototype.species = "动物";
	然后，再写一个函数，实现属性拷贝的目的。
	    　　function extend2(Child, Parent) {
	    　　　　var p = Parent.prototype;
	    　　　　var c = Child.prototype;
	    　　　　for (var i in p) {
	    　　　　　　c[i] = p[i];
	    　　　　　　}
	    　　　　c.uber = p;
	    　　}
	这个函数的作用，就是将父对象的prototype对象中的属性，一一拷贝给Child对象的prototype对象。
	使用的时候，这样写：
	    　　extend2(Cat, Animal);
	    　　var cat1 = new Cat("大毛","黄色");
	    　　alert(cat1.species); // 动物
Javascript面向对象编程（三）：非构造函数的继承
一、什么是"非构造函数"的继承？
	比如，现在有一个对象，叫做"中国人"。
	    　　var Chinese = {
	    　　　　nation:'中国'
	    　　};
	还有一个对象，叫做"医生"。
	    　　var Doctor ={
	    　　　　career:'医生'
	    　　}
	请问怎样才能让"医生"去继承"中国人"，也就是说，我怎样才能生成一个"中国医生"的对象？	
	这里要注意，这两个对象都是普通对象，不是构造函数，无法使用构造函数方法实现"继承"。
二、object()方法
	json格式的发明人Douglas Crockford，提出了一个object()函数，可以做到这一点。
	    　　function object(o) {
	    　　　　function F() {}
	    　　　　F.prototype = o;
	    　　　　return new F();
	    　　}
	这个object()函数，其实只做一件事，就是把子对象的prototype属性，指向父对象，从而使得子对象与父对象连在一起。
	使用的时候，第一步先在父对象的基础上，生成子对象：
	var Doctor = object(Chinese);
	然后，再加上子对象本身的属性：
	    　　Doctor.career = '医生';
	这时，子对象已经继承了父对象的属性了。
	    　　alert(Doctor.nation); //中国
三、浅拷贝
	除了使用"prototype链"以外，还有另一种思路：把父对象的属性，全部拷贝给子对象，也能实现继承。
	下面这个函数，就是在做拷贝：
	    　　function extendCopy(p) {
	    　　　　var c = {};
	    　　　　for (var i in p) {
	    　　　　　　c[i] = p[i];
	    　　　　}
	    　　　　c.uber = p;
	    　　　　return c;
	    　　}
	使用的时候，这样写：
	    　　var Doctor = extendCopy(Chinese);
	    　　Doctor.career = '医生';
	    　　alert(Doctor.nation); // 中国
	但是，这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，
	那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。
	请看，现在给Chinese添加一个"出生地"属性，它的值是一个数组。
	    　　Chinese.birthPlaces = ['北京','上海','香港'];
	通过extendCopy()函数，Doctor继承了Chinese。
	    　　var Doctor = extendCopy(Chinese);
	然后，我们为Doctor的"出生地"添加一个城市：
	    　　Doctor.birthPlaces.push('厦门');
	发生了什么事？Chinese的"出生地"也被改掉了！
	    　　alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门
	    　　alert(Chinese.birthPlaces); //北京, 上海, 香港, 厦门
	所以，extendCopy()只是拷贝基本类型的数据，我们把这种拷贝叫做"浅拷贝"。这是早期jQuery实现继承的方式。
	也就说 父对象的某个属性 是数组 或者 是一个对象(有多个数据)，浅拷贝只是拷贝了 指向地址
四、深拷贝
	所谓"深拷贝"，就是能够实现真正意义上的数组和对象的拷贝。
	由于只是当属性 是数组 或者 是一个对象,拷贝过去的才是一个指针地址,所以
	当遇到的父对象的某个属性 是数组 或者 是一个对象(有多个数据)时,进入这个数组 或者对象 然后在再执行一次浅拷贝
	若又遇到了数组或者对象,则有依次方法递归调用
	最终实现深拷贝
	    　　function deepCopy(p, c) {
	    　　　　var c = c || {};
	    　　　　for (var i in p) {
	    　　　　　　if (typeof p[i] === 'object') {
	    　　　　　　　　c[i] = (p[i].constructor === Array) ? [] : {};
	    　　　　　　　　deepCopy(p[i], c[i]);	
	    　　　　　　} else {
	    　　　　　　　　　c[i] = p[i];
	    　　　　　　}
	    　　　　}
	    　　　　return c;
	    　　}
	使用的时候这样写：
	    　　var Doctor = deepCopy(Chinese);
	现在，给父对象加一个属性，值为数组。然后，在子对象上修改这个属性：
	    　　Chinese.birthPlaces = ['北京','上海','香港'];
	    　　Doctor.birthPlaces.push('厦门');
	这时，父对象就不会受到影响了。
	    　　alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门
	    　　alert(Chinese.birthPlaces); //北京, 上海, 香港
	目前，jQuery库使用的就是这种继承方法。		
	






	

20171027
javascript类深入学习
一：理解构造函数原型(prototype)机制
	prototype是javascript实现与管理继承的一种机制，也是面向对象的设计思想.构造函数的原型存储着引用对象的一个指针，
	该指针指向与一个原型对象，对象内部存储着函数的原始属性和方法；我们可以借助prototype属性，可以访问原型内部的属性和方法。
	当构造函数被实列化后，所有的实例对象都可以访问构造函数的原型成员，如果在原型中声明一个成员，所有的实列方法都可以共享它，
	即 js 函数 有三部分组成内容:
		1,函数代码本身!! 还有函数 因为都能实例化一个对象,所以都可以称为构造函数
		2,js自动为函数 划分一个空间放 函数的prototyte内容,这里称这个空间为函数原型
		3,new 函数() 时,会实例化一个新对象,划分一个新的空间,存放函数执行过程中的生成的所有内容,
		  也含有指向原型(即prototyte内容)的一个指针
	例如:
		// 构造函数A 
		function A(name){
		    this.name = name;
		}
		//函数A 的原型有一个getName方法
		A.prototype.getName = function(){
		    return this.name;
		}
		// 实列化2次后 该2个实列都有原型getName方法；如下代码
		var instance1 = new A("longen1");
		var instance2 = new A("longen2");
		console.log(instance1.getName()); //longen1
		console.log(instance2.getName()); // longen2
	原型具有普通对象结构，可以将任何普通对象设置为原型对象; 
	一般情况下，对象都继承与Object,也可以理解Object是所有对象的超类,
	Object是没有原型的，而构造函数拥有原型，因此实列化的对象也是Object的实列
	例如:
		// 实列化对象是构造函数的实列
		console.log(instance1 instanceof A); //true
		console.log(instance2 instanceof A); // true	
		// 实列化对象也是Object的实列
		console.log(instance1 instanceof Object); //true
		console.log(instance2 instanceof Object); //true
		//Object 对象是所有对象的超类，因此构造函数也是Object的实列
		console.log(A instanceof Object); // true
		// 但是实列化对象 不是Function对象的实列 如下代码
		console.log(instance1 instanceof Function); // false
		console.log(instance2 instanceof Function); // false	
		// 但是Object与Function有关系 如下代码说明
		console.log(Function instanceof Object);  // true
		console.log(Object instanceof Function);  // true
		//Function是Object的实列，也可以是Object也是Function的实列;他们是2个不同的构造器
		//但是实在不知道如何理解
		//我们知道 object 就是我们熟悉的对象, 对象就是一个被划分的空间,存放着各种数据,
		//var 的类型可以是对象, 一个函数实例化 也是对象
		//但是 这里的 function 就真不知道中那么理解
	再看例子://虽然不知道怎么理解 f
		var f = new Function();
		var o = new Object();
		console.log("------------"); 
		console.log(f instanceof Function);  //true
		console.log(o instanceof Function);  // false
		console.log(f instanceof Object);    // true
		console.log(o instanceof Object);   // true
	在原型上增加成员属性或者方法时,增加的内容会被所有的实列化对象所共享
	但如果 实列化对象有成员 和原型的成员 名字相同时，那么优先使用本实列化对象的成员，
	如果 实列对象中没有这个名字的你成员时，那么实列对象会到原型中去查找该成员，
	如果原型找到就返回，否则的会返回undefined
	例如:
		function B(){
		    this.name = "longen2";
		}
		B.prototype.name = "AA";
		B.prototype.getName = function(){
		    return this.name;
		};	
		var b1 = new B();
		// 在本实列查找，找到就返回，否则到原型查找
		console.log(b1.name); // longen2
		// 在本实列没有找到该方法，就到原型去查找
		console.log(b1.getName());//longen2
		// 如果在本实列没有找到的话，到原型上查找也没有找到的话，就返回undefined
		console.log(b1.a); // undefined
		// 现在我使用delete运算符删除本地实列属性，那么取到的是就是原型属性了，如下代码：
		delete b1.name;
		console.log(b1.name); // AA
二：理解原型域链的概念
	原型的优点是能够以对象结构为载体，创建大量的实列，
	这些实列能共享原型中的成员(属性和方法);同时也可以使用原型实现面向对象中的继承机制
		function AA(x){
		    this.x = x;
		}
		function BB(x) {
		    this.x = x;
		}
		BB.prototype = new AA(11);
		console.log(BB.prototype.x); //11
	再如	
		function A(x) {
		    this.x = x;
		}
		A.prototype.x = 0;	// 在A的原型上定义一个属性x = 0
		function B(x) {
		    this.x = x;
		}
		B.prototype = new A(1);
		//实列化A new A(1)的时候 在A函数内this.x =1， 
		//B.prototype = new A(1); 实列化A()这个对象给了B.prototype 相当于B继承于A,
		//那么 B.prototype.x = 1; 
		console.log(B.prototype.x); // 1
	继续
		function C(x) {
		    this.x = x;
		}				// 定义C的构造函数
		C.prototype = new B(2);
		//C.prototype = new B(2); 实列化B()这个对象给了C.prototype 相当于C继承于B,
		//那么C.prototype.x = 2
		console.log(C.prototype.x); // 2
	继续
		var d = new C(3);
		console.log(d.x); // 3
		//这时,删除d.x ,即 实例化C(3) 中的 x 被删掉了,但是实例化C(3)仍然存在,所以 d 还在
		//再访问d.x的时候 本实列对象被删掉，只能从原型上去查找；
		//由于C.prototype = new B(2); 也就是C继承于B，因此C的原型也有x = 2；即C.prototype.x = 2;
		//而d.x 会指向这个 C.prototype.x,而 C.prototype.x 就是 实例化B(2)
		delete d.x;
		console.log(d.x);  //2
	继续
		//这时删除C.prototype.x，我们从上面代码知道，即C.prototype 指向的 实例化B(2)的 x 被删除了!!
		//关系链如下:
		// d.x 寻求 C.prototype.x ,
		// C.prototype.x 就是 实例化B(2)的x, 于是 C.prototype.x被删,就是 实例化B(2)的x 被删
		// 于是 C.prototype.x 寻求 B.prototype.x, 即就是 实例化B(2)的x 寻求 B.prototype.x
		// B.prototype.x = 1, 最后 d.x 也就 等于1
		delete C.prototype.x;
		console.log(d.x);  // 1
	继续
		//这时删除 B.prototype.xx后，即B.prototype 指向的 实例化A(1)的 x 被删除了!!    
		//关系链变成这样:
		// d.x 寻求 C.prototype.x ,
		// C.prototype.x 就是 实例化B(2)的x, 于是 C.prototype.x被删,就是 实例化B(2)的x 被删
		// 于是 C.prototype.x 寻求 B.prototype.x, 即就是 实例化B(2)的x 寻求 B.prototype.x
		// B.prototype.x 就是 实例化A(1)的x, 于是 B.prototype.x被删,就是 实例化A(1)的x 被删
		// 于是 B.prototype.x 寻求 A.prototype.x , 即就是 实例化A(1)的x 寻求 A.prototype.x
		// A.prototype.x = 0 所以最后 d.x 也就 等于0
		delete B.prototype.x;
		console.log(d.x);  // 0
	继续
		//继续删除A的原型x后,即删除 A.prototype.x = 0 
		//依上述分析 A.prototype 并没有继承其他实例化函数,A.prototype.x是直接赋值的,
		//所以A.prototype.x 寻找 x 的工作就此结束, 
		//表示没有 x 这个变量, 所以返回undefined了;
		delete A.prototype.x;
		console.log(d.x);  // undefined
	//难理解的内容:
	javascript中，一切都是对象，Function和Object都是函数的实列;  //Function 和 object 实例的概念难懂
		构造函数的父原型指向于Function原型，
		Function.prototype的父原型指向与Object的原型，
		Object的父原型也指向与Function原型，
		Object.prototype是所有原型的顶层;
	例如:
		Function.prototype.a = function(){
		    console.log("我是父原型Function");
		}
		Object.prototype.a = function(){
		    console.log("我是 父原型Object");
		}
		function A(){
		    this.a = "a";
		}
		A.prototype = {
		    B: function(){
		        console.log("b");
		    }
		}
		//函数A 是 Function 的实例,也是 Object的实列 如下：
		console.log(A instanceof Function);  // true
		console.log(A instanceof Object); // true
		// A.prototype是一个对象，它是Object的实列，但不是Function的实列
		console.log(A.prototype instanceof Function); // false
		console.log(A.prototype instanceof Object); // true
		// Function是Object的实列 同是Object也是Function的实列
		console.log(Function instanceof Object);   // true
		console.log(Object instanceof Function); // true
		/*
		 * Function.prototype是Object的实列 但是Object.prototype不是Function的实列
		 * 说明Object.prototype是所有父原型的顶层
		 */
		console.log(Function.prototype instanceof Object);  //true
		console.log(Object.prototype instanceof Function);  // false
三：理解原型继承机制
	构造函数都有一个指针指向原型，Object.prototype是所有原型对象的顶层，比如如下代码：
		var obj = {};
		Object.prototype.name = "tugenhua";
		console.log(obj.name); // tugenhua
	给Object.prototype 定义一个属性，通过字面量构建的对象的话，都会从父类那边获取Object.prototype的属性；
	从上面代码我们知道，原型继承的方法是：假如A需要继承于B，
	那么A.prototype(A的原型) = new B()（作为B的实列） 即可实现A继承于B; 
	因此我们下面可以初始化一个空的构造函数;然后把对象赋值给构造函数的原型，然后返回该构造函数的实列； 即可实现继承;
	例如
		if(typeof Object.create !== 'function') {
		    Object.create = function(o) {
		        var F = new Function();
		        F.prototype = o;
		        return new F();
		    }
		}
		var a = {
		    name: 'longen',
		    getName: function(){
		        return this.name;
		    }
		};
		var b = {};
		b = Object.create(a);
		console.log(typeof b); //object
		console.log(b.name);   // longen
		console.log(b.getName()); // longen
		//如上代码:我们先检测Object是否已经有Object.create该方法;如果没有的话就创建一个； 
		//该方法内创建一个空的构造器，把参数对象传递给构造函数的原型，最后返回该构造函数的实列，就实现了继承方式；
		//如上测试代码：先定义一个a对象，有成员属性name='longen'，还有一个getName()方法;最后返回该name属性; 
		//然后定义一个b空对象，使用Object.create(a);把a对象继承给b对象，因此b对象也有属性name和成员方法getName();
	理解原型查找原理：对象查找先在该构造函数内查找对应的属性，
	如果该对象没有该属性的话，那么javascript会试着从该原型上去查找，
	如果原型对象中也没有该属性的话，那么它们会从原型中的原型去查找，
	直到查找的Object.prototype也没有该属性的话，那么就会返回undefined;
	因此我们想要仅在该对象内查找的话，为了提高性能，我们可以使用hasOwnProperty()来判断该对象内有没有该属性，(并不会查找原型)
	如果有的话，就执行代码(使用for-in循环查找)：
	例子:
		var obj = {
		    "name":'tugenhua',
		    "age":'28'
		};
		// 使用for-in循环
		for(var i in obj) {
		    if(obj.hasOwnProperty(i)) {
		        console.log(obj[i]); //tugenhua 28
		    }
		}
		//如上使用for-in循环查找对象里面的属性，
		//但是我们需要明白的是：for-in循环查找对象的属性，它是不保证顺序的，
		//for-in循环和for循环；最本质的区别是：for循环是有顺序的，for-in循环遍历对象是无序的，
		//因此我们如果需要对象保证顺序的话，可以把对象转换为数组来，然后再使用for循环遍历即可;
	下面我们来谈谈原型继承的优点和缺点 
	例子:
		// 先看下面的代码：
		// 定义构造函数A，定义特权属性和特权方法
		function A(x) {
		    this.x1 = x;
		    this.getX1 = function(){
		        return this.x1;
		    }
		}
		// 定义构造函数B，定义特权属性和特权方法
		function B(x) {
		    this.x2 = x;
		    this.getX2 = function(){
		        return this.x1 + this.x2;
		    }
		}
		B.prototype = new A(1);
	B.prototype = new A(1);这句代码执行的时候,B的原型继承于A，
	因此B.prototype也有A的属性和方法,即：B.prototype.x1 = 1; B.prototype.getX1 方法；
	但是B也有自己的特权属性x2和特权方法getX2;
	继续
		function C(x) {
		    this.x3 = x;
		    this.getX3 = function(){
		        return this.x3 + this.x2;
		    }
		}
		C.prototype = new B(2);
	C.prototype = new B(2);这句代码执行的时候,C的原型继承于B，因此C.prototype.x2 = 2; 
	C.prototype.getX2方法且C也有自己的特权属性x3和特权方法getX3,
	继续
		var b = new B(2);
		var c = new C(3);
		console.log(b.x1);  // 1
		console.log(c.x1);  // 1
		console.log(c.getX3()); // 5
		console.log(c.getX2()); // 3
		var b = new B(2); 
	实列化B的时候 b.x1 首先会在构造函数内查找x1属性，没有找到，
	由于B的原型继承于A，因此A有x1属性，因此B.prototype.x1 = 1找到了;
	var c = new C(3); 实列化C的时候，从上面的代码可以看到C继承于B，B继承于A，
	因此在C函数中没有找到x1属性，会往原型继续查找，直到找到父元素A有x1属性，
	因此c.x1 = 1;c.getX3()方法; 返回this.x3+this.x2 this.x3 = 3;
	this.x2 是B的属性，因此this.x2 = 2;c.getX2(); 查找的方法也一样，不再解释
	所以prototype的缺点与优点如下：
		优点是：能够允许多个对象实列共享原型对象的成员及方法，
		缺点是：1. 每个构造函数只有一个原型，因此不直接支持多重继承;
		       2. 不能很好地支持多参数或动态参数的父类。在原型继承阶段，用户还不能决定以什么参数来实列化构造函数。
四：理解使用类继承(继承的更好的方案)
	类继承也叫做构造函数继承，在子类中执行父类的构造函数；
	实现原理是：可以将一个构造函数A的方法赋值给另一个构造函数B，
	然后调用该方法，使构造函数A在构造函数B内部被执行，这时候构造函数B就拥有了构造函数A中的属性和方法，
	这就是使用类继承实现B继承与A的基本原理；
	例如:
		function A(x) {
		    this.x = x;
		    this.say = function(){
		        return this.x;
		    }
		}
		function B(x,y) {
		    this.m = A; // 把构造函数A作为一个普通函数引用给临时方法m
		    this.m(x);  // 执行构造函数A;
		    delete this.m; // 清除临时方法this.m
		    this.y = y;
		    this.method = function(){
		        return this.y;
		    }
		}
		var a = new A(1);
		var b = new B(2,3);
		console.log(a.say()); 	 // 输出1, 在执行构造函数A中的say方法
		console.log(b.say());    // 输出2, 能执行该方法说明被继承了A中的方法
					 // this.m(x);时,已经实例化了一个对象,并内嵌存到 b对象里
					 // delete this.m; 只是清除了 this.m 这个对象数据,并不会把刚刚的实例化对象也删掉
		console.log(b.method()); // 输出3， 构造函数也拥有自己的方法
	上面的代码实现了简单的类继承的基础，但是在复杂的编程中是不会使用上面的方法的，
	因为上面的代码不够严谨；代码的耦合性高；我们可以使用更好的方法如下：//这个方法从代码上看不好理解!!
	例如:
		function A(x) {
		    this.x = x;
		}
		A.prototype.getX = function(){
		    return this.x;
		}
		// 实例化A
		var a = new A(1);
		console.log(a.x); // 1
		console.log(a.getX()); // 输出1
		// 现在我们来创建构造函数B，让其B继承与A，如下代码：
		function B(x,y) {
		    this.y = y;
		    A.call(this,x);	
		}
		B.prototype = new A();  // 原型继承,这里居然不带参数好迷惑!!
		console.log(B.prototype.constructor); // 输出构造函数A，指针指向与构造函数A
		B.prototype.constructor = B;          // 重新设置构造函数，使之指向B
		console.log(B.prototype.constructor); // 指向构造函数B
		B.prototype.getY = function(){
		    return this.y;
		}
		var b = new B(1,2);
		console.log(b.x); // 1
		console.log(b.getX()); // 1
		console.log(b.getY()); // 2
		// 下面是演示对构造函数getX进行重写的方法如下：
		B.prototype.getX = function(){
		    return this.x;
		}
		var b2 = new B(10,20);
		console.log(b2.getX());  // 输出10
	下面我们来分析上面的代码：
	在构造函数B内，使用A.call(this,x);这句代码的含义是：我们都知道使用call或者apply方法可以改变this指针指向，
	从而可以实现类的继承，因此在B构造函数内，把x的参数传递给A构造函数，并且继承于构造函数A中的属性和方法；
	使用这句代码：B.prototype = new A();  可以实现原型继承，也就是B可以继承A中的原型所有的方法；
	console.log(B.prototype.constructor); 打印出输出构造函数A，指针指向与构造函数A；
	我们明白的是，当定义构造函数时候，其原型对象默认是一个Object类型的一个实例，其构造器默认会被设置为构造函数本身，
	如果改动构造函数prototype属性值，使其指向于另一个对象的话，那么新对象就不会拥有原来的constructor的值，
	比如第一次打印console.log(B.prototype.constructor); 指向于被实例化后的构造函数A，
	重写设置B的constructor的属性值的时候，第二次打印就指向于本身B；
	因此B继承与构造A及其原型的所有属性和方法，当然我们也可以对构造函数B重写构造函数A中的方法，
	如上面最后几句代码是对构造函数A中的getX方法进行重写，来实现自己的业务~；
五：建议使用封装类实现继承
	封装类实现继承的基本原理：
	先定义一个封装函数extend；该函数有2个参数，Sub代表子类，Sup代表超类；
	在函数内，先定义一个空函数F, 用来实现功能中转，
	先设置F的原型为超类的原型，然后把空函数的实例传递给子类的原型，
	使用一个空函数的好处是：避免直接实例化超类可能会带来系统性能问题，比如超类的实例很大的话，实例化会占用很多内存；
	例如:
		function extend(Sub,Sup) {
		    //Sub表示子类，Sup表示超类
		    // 首先定义一个空函数
		    var F = function(){};
		    // 设置空函数的原型为超类的原型
		    F.prototype = Sup.prototype; 
		    // 实例化空函数，并把超类原型引用传递给子类
		    Sub.prototype = new F();           
		    // 重置子类原型的构造器为子类自身
		    Sub.prototype.constructor = Sub;        
		    // 在子类中保存超类的原型,避免子类与超类耦合
		    Sub.sup = Sup.prototype;	
		    if(Sup.prototype.constructor === Object.prototype.constructor) {
		        // 检测超类原型的构造器是否为原型自身
		        Sup.prototype.constructor = Sup;
		    }	
		}
	测试代码如下：
		// 下面我们定义2个类A和类B，我们目的是实现B继承于A
		function A(x) {
		    this.x = x;
		    this.getX = function(){
		        return this.x;
		    }
		}
		A.prototype.add = function(){
		    return this.x + this.x;
		}
		A.prototype.mul = function(){
		    return this.x * this.x;
		}
		// 构造函数B
		function B(x){
		    A.call(this,x); // 继承构造函数A中的所有属性及方法
		}
		extend(B,A);  // B继承于A
		var b = new B(11);
		console.log(b.getX()); // 11
		console.log(b.add());  // 22
		console.log(b.mul());  // 121
	注意：在封装函数中，有这么一句代码：Sub.sup = Sup.prototype; 我们现在可以来理解下它的含义：
	比如在B继承与A后，我给B函数的原型再定义一个与A相同的原型相同的方法add();
	继续
		extend(B,A);  // B继承于A
		var b = new B(11);
		B.prototype.add = function(){
		    return this.x + "" + this.x;
		}
		console.log(b.add()); // 1111
	那么B函数中的add方法会覆盖A函数中的add方法；因此为了不覆盖A类中的add()方法，且调用A函数中的add方法；可以如下编写代码：
		B.prototype.add = function(){
		    //return this.x + "" + this.x;
		    return B.sup.add.call(this);
		}
		console.log(b.add()); // 22
	B.sup.add.call(this); 中的B.sup就包含了构造函数A函数的指针，因此包含A函数的所有属性和方法；因此可以调用A函数中的add方法；
	如上是实现继承的几种方式，类继承和原型继承，
	但是这些继承无法继承DOM对象，也不支持继承系统静态对象，静态方法等；比如Date对象如下：
		// 使用类继承Date对象
		function D(){
		    Date.apply(this,arguments); // 调用Date对象，对其引用，实现继承
		}
		var d = new D();
		console.log(d.toLocaleString()); // [object object]
	如上代码运行打印出object，我们可以看到使用类继承无法实现系统静态方法date对象的继承，
	因为他不是简单的函数结构，对声明，赋值和初始化都进行了封装，因此无法继承；
	下面我们再来看看使用原型继承date对象；
		function D(){}
		D.prototype = new D();
		var d = new D();
		console.log(d.toLocaleString());//[object object]
	我们从代码中看到，使用原型继承也无法继承Date静态方法；但是我们可以如下封装代码继承：
		function D(){
		    var d = new Date();  // 实例化Date对象
		    d.get = function(){ // 定义本地方法，间接调用Date对象的方法
		        console.log(d.toLocaleString());
		    }
		    return d;
		}
		var d = new D();
		d.get(); // 2015/12/21 上午12:08:38
		//也就说 Date() 只有可以被实例化,不能被直接继承,只能被继承实例化的内容
六：理解使用复制继承
	复制继承的基本原理是：先设计一个空对象，然后使用for-in循环来遍历对象的成员，
	将该对象的成员一个一个复制给新的空对象里面;这样就实现了复制继承了;如下代码：
	例如:
		function A(x,y) {
		    this.x = x;
		    this.y = y;
		    this.add = function(){
		        return this.x + this.y;
		    }
		}
		A.prototype.mul = function(){
		    return this.x * this.y;
		}
		var a = new A(2,3);
		var obj = {};
		for(var i in a) {
		    obj[i] = a[i];
		}
		console.log(obj); // object
		console.log(obj.x); // 2
		console.log(obj.y); // 3
		console.log(obj.add()); // 5  从这里更好理解 obj是一个实例化A()对象,因为.add() 和 .mul()也是当中的内嵌对象,
		console.log(obj.mul()); // 6  虽然本能认为这两个是函数,没能接受他们也是个对象数据
					//而这些函数里的用到参数,也在这个实例化A()对象!!!!这是重点,所以有输出结果
	如上代码：先定义一个构造函数A，函数里面有2个属性x,y,还有一个add方法，
	该构造函数原型有一个mul方法，首先实列化下A后，再创建一个空对象obj，遍历对象一个个复制给空对象obj，
	从上面的打印效果来看，我们可以看到已经实现了复制继承了;对于复制继承，我们可以封装成如下方法来调用:
		// 为Function扩展复制继承方法
		Function.prototype.extend = function(o) {
		    for(var i in o) {
		        //把参数对象的成员复制给当前对象的构造函数原型对象
		        this.constructor.prototype[i] = o[i];
		    }
		}
		// 测试代码如下：
		var o = function(){};
		o.extend(new A(1,2));
		console.log(o.x);  // 1
		console.log(o.y);  // 2
		console.log(o.add()); // 3
		console.log(o.mul()); // 2
	上面封装的扩展继承方法中的this对象指向于当前实列化后的对象，而不是指向于构造函数本身，
	因此要使用原型扩展成员的话，就需要使用constructor属性来指向它的构造器，然后通过prototype属性指向构造函数的原型；
	复制继承有如下优点：
	 1. 它不能继承系统核心对象的只读方法和属性
	 2. 如果对象数据非常多的话，这样一个个复制的话，性能是非常低的;
	 3. 只有对象被实列化后，才能给遍历对象的成员和属性，相对来说不够灵活;	
	 4. 复制继承只是简单的赋值，所以如果赋值的对象是引用类型的对象的话，
	    可能会存在一些副作用;如上我们看到有如上一些缺点，下面我们可以使用clone(克隆的方式)来优化下：
	基本思路是：为Function扩展一个方法，该方法能够把参数对象赋值赋值一个空构造函数的原型对象，
	然后实列化构造函数并返回实列对象，这样该对象就拥有了该对象的所有成员;代码如下：
		Function.prototype.clone = function(o){
		    function Temp(){};
		    Temp.prototype = o;
		    return Temp();
		}
		// 测试代码如下：
		Function.clone(new A(1,2));
		console.log(o.x);  // 1
		console.log(o.y);  // 2
		console.log(o.add()); // 3
		console.log(o.mul()); // 2










20171028
分析跑页游 记录
	BcakGround 比较简单不参与交互,自个在循环变化!!!
	mapfloor 地板是重点!! 从独立js 看不出是什么乾坤 还有 floor !!!!! 原来是两个结合使用的
	energybar 看不到重点
	player 也看不到重点!!!







20171030
laya_demo (js)
https://ask.layabox.com/question/317 打飞机	(分析完)
http://blog.csdn.net/chenluliang/article/details/77879291	DNF	(分析中)
https://ask.layabox.com/question/629	跑酷	(学习分析完)
https://github.com/lanbomo/laya-snakes 贪吃蛇	(TS 的,所以先不分析)
https://ask.layabox.com/question/548	跑酷改	(分析完)
https://ask.layabox.com/question/5889 打地鼠	(分析完)







20171101
小结一下: 
	1,
	laya 都先加载一个 onloading 的 spite 界面, 然后才继续加载其他游戏资源的
	laya.stage.addchild();每使用一次,就会加载一个界面,而且会覆盖之前界面
	2,
	游戏的移动实现,通过spite 对象的 坐标变化实现, 基础的碰撞检测也是基于 spite 坐标的检测
	3,
	作为一个网游,需要源源不断地发送 数据到服务端,服务端又发到其他链接上的客户端
	这个交互数据工作,使用 websocket 实现,所以 
接下来要掌握的内容是: 
	websocket多人连接,还有各种测试
	图集图片的制作
		分解 gif 
		打包 图片等等!!!
websocket继续深入:
	html5_learn/php_learn/websocket 里的 server 只能与一位用户连接,而且客户端与服务器的地址一定要一样,哪怕是127.0.0.1 !!!
	html5_learn/php_learn/websoket-php-chat 里的server 与能与多位用户链接,但是 server地址你不能127,否则内网其他机子连不上
	重点分析 websoket-php-chat 里的server
	从 server 端中学到的一些 php 内容:
		语法1:(关于数组的语法)
		...
	        $this->users[$key]=array(
	          'socket'=>$client,  //记录新连接进来client的socket信息
	          'shou'=>false       //标志该socket资源没有完成握手
	        );
		...
	        //根据socket在user池里面查找相应的$k,即健ID
	        $k=$this->search($sock);
		....
		function search($sock){
			foreach ($this->users as $k=>$v){
				if($sock==$v['socket'])
				return $k;
			}
			return false;
		}
		//首先这里 $client 和 $sock 是同一个文件描述符, 
		//search 功能是 通过 $client 找到对应的 users[$key] 里的 $key
		//foreach中 $k 表示的是users数组的成员标识[]里的内容, $v代表内嵌数组!!!!
		//$v['socket'] 表示内嵌数组中,成员标识为字符串'socket'的成员
		语法2:(关于数组的语法)
		$this->sockets=array($this->master);
		foreach($this->users as $v){
			$this->sockets[]=$v['socket'];
		}
		//数组的初始化 一般可以这样子 :
		//	var bb = array(); 	//初始化 bb 是一个数组变量
		//	var bb = array($ddd); 	//也可以这样 初始化 bb 是一个数组变量并塞入第一个成员 $ddd, 
		//	var bb[] = $ddd1;	//往数组 bb 继续塞成员 $ddd1 []表示成员指定数组标识!!!
		//	var bb[78] = array('df'=>$ghj , 'ok'=>$lll);
		//	//表示数组 bb中 数字变量78标识的成员是一个内嵌数组成员
		//	//内嵌数组成员中 字符串'df'标识的成员是$ghj,字符串'ok'标识的成员是$lll,
	server本身关于websocket 建立的概念内容:
		//创建socket操作
		$server = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);
		socket_set_option($server, SOL_SOCKET, SO_REUSEADDR, 1);//1表示接受所有的数据包
		socket_bind($server, $address, $port);
		socket_listen($server);
		return $server;		//最后得到的是一个监听状态,等待连接的socket文件描述符
					//注意这个返回的 socket是个监听 连接的socket
					//也就是说,我们创建的 socket 只用来监听 连接信息,并不会进行连接后的数据交互活动 
		/*
		socket_select ($sockets, $write = NULL, $except = NULL, NULL);
    		这个函数是同时接受多个连接的关键，这个函数是监视所有 正在监听数据的socket, 所以一直阻塞程序
		直到有socket收到了数据,返回
		$sockets是一个数组，这个数组中存放的是文件描述符。一开始,这个数组里 包含说有 正在监听数据的socket
			返回时,$sockets数组只含有那些监听得到数据的 socket,然后供程序进一步处理
			重新执行 socket_select前, 要把 $sockets 改回来 包含说有 正在监听数据的socket
		$write是监听是否有客户端写数据，传入NULL是不关心是否有写变化。
		$except是$sockets里面要被排除的元素，传入NULL是”监听”全部。
		最后一个参数是超时时间
			如果为0：则立即结束
			如果为n>1: 则最多在n秒后结束，如遇某一个连接有新动态，则提前返回
			如果为null：如遇某一个连接有新动态，则返回
		*/
		$changes=$this->sockets;	//表示 要监视的是 所有监听中的socket
		socket_select($changes,$write,$except,NULL);	//开始监视并 阻塞等待!!
		//第一次socket_select返回时,必定是有机子想连进服务器来,然后会执行socket_accept 
		$client=socket_accept($this->master); 
			//使用 $this->master 是那个一开始初始化,只监听连接信息的socket
			//socket_accept会先拷贝一个新socket,会把所有请求连接的缓存信息都剪切到这个socket.
			//返回这个socket,但是还没有完成来连接
			//把给这个新 socket 提供一个 新 key
			//        $this->users[$key]=array(
			//          'socket'=>$client,  //记录新连接进来client的socket信息
			//          'shou'=>false       //标志该socket资源没有完成握手
			//        );
		//然后重新监视所有socket,由于这个新socket 本身就有被拷贝过来的缓存信息,未处理,所以socket_select又返回
		//然后跳到处理这个新socket缓存数据,执行握手连接操作!!
		//拷贝过来的缓存信息里,有一个 机子发来的 key
			$key  = trim(substr($buf,0,strpos($buf,"\r\n")));
		//我们吧可以用 sha1 方式编码
			$new_key = base64_encode(sha1($key."258EAFA5-E914-47DA-95CA-C5AB0DC85B11",true));	
		//注意,握手就是,发送一段返回信息,包括这个 sha1 编码的 key,然后就算成功握手了!!! 		   
			$new_message .= "Sec-WebSocket-Accept: " . $new_key . "\r\n\r\n";	
			socket_write($this->users[$k]['socket'],$new_message,strlen($new_message));
		//然后下次这个新socket收到的数据就是就是我们实际上用户交互的数据了!!!!
	websocket 连接上后,数据交互的内容内容,重点
		假设 socket_select 返回后,得到一个 获得了内容的socket
		我们要吧内容从socket里提出来, 多次调用 socket_recv;
			socket_recv($sock,$buf,1000,0);	
			//表示一次预期从 $sock文件描述符指向的 socket文件里 读出 1000个字节到 buf上
			//成功后,返回实际读取到了多少个字节到 buf上!!
		把每次socket_recv读出的 buf 内容,拼接放入 buffer ,最终得到完整的 socket文件的内容
		这是一段压缩的 编码了的内容,但是并不是使用key或者 sha1 加密的内容
		只需要解压,解码就可以.
	从中学到的 php 函数
		$msg = unpack('H*',$str); //以十六进制高思位在前的形式解压内容
		$head = substr($msg[1],0,2); //返回 内容里的头信息, 这里的 $msg数组只有一个成员,而且标记是数字1,而不是数字0!! 
		hexdec() 函数把十六进制转换为十进制
		parse_str(string,array); //把字符串string 以&分割符号拆分成成员,再存到 array数组里
			parse_str("name=Bill&age=60");
			echo $name."<br>";
			echo $age;
		unset — 释放给定的变量






20171108
网游实验(所有基本功能!):
	建立图集动画,并按键移动
	初始化,(各种屏幕适应)
	加背景,(直接用 Sprite drawTexture)
	加按钮,(使用系统自动带的 按钮套件)
	按钮事件, 全局变量通过承接指针得到控制变量的入口给按钮事件处理
	加人物,(使用继承Sprite,方式)
	人物frameonloop.
	加弹窗(使用UI),复习下UI编辑窗口的操作
		UI编辑器新建 view
		每个添加到 viewUI 上的套件最好加上 var 变量,方便调用
	`	还有把资源文件夹拖到 UI编辑器左下的资源框可以添加资源,
		按f12后,会自动为这个资源包打包成 json和图包png 到res/atlas中去
		但是要使用这个UI时,代码中还是要把要用到的资源包加入loader.load上!!
	如何建立数组,每个成员都是新增一个类成员!!! 例子:
		var scr = Array();
		var i = 0;
		for(...){
			i += 1 ;
			var scr[i] = new xxxUI();	//[]中的标签除了是数字变量外,也可以是字符串变量
		}
	建立客户端和服务端!!
		假设是在 win wampserver64 上运行
			假设像聊天软件一样有客户端,服务端两套代码,机子上肯定要先运行服务端程序的,然后在通过浏览器浏览客户端
			现在虽然 安装了wampserver服务器集成环境,但是环境运作后,只能做 浏览器访问客户端的操作,
			却不知道怎么打开服务端,wampserver服务器集成环境也简称服务端,常常互相混混淆
			wampserver服务器集成环境,主要提供服务器功能,可以存放网站!!!供远程机子访问
			聊天软件的服务端,只是聊天软件这个项目的一个在服务器上默默执行的后台程序!!!
			那么,怎么执行这个后台程序? 未知如何塞到 wampserver服务器集成环境里,让他捆绑启动!!!
			但有一种方法, 通过 cmd 命令行:
				由于安装了wampserver服务器集成环境,所以自带了php解析器,找到所在路径:
				例如:C:\wamp64\bin\php\php5.6.31
				右击我的电脑->属性->高级系统设置->环境变量->修改 PATH 的值,往后添加;C:\wamp64\bin\php\php5.6.31->确定
				然后打开 cmd.exe 输入指令
				php C:\wamp64\www\websoket-php-chat\websocket.php   成功执行软件的服务端后台程序
				然后浏览器登录 client.html 成功登录!!
		解释如何部署使用 客户端和服务端, 开始移植到游戏里!!
		js客户端重点:
			xx = new WebSocket(...)		//建立连接
			xx.onopen = function(){..}	//连接后做的第一件事,也就是说成功建立打开socket后用户定义要做的事
			xx.onclose = function(){...}	//断开连接后做的事,即 关闭socket时,用户定义要做的事
			xx.onmessage = function(msg){...}	//当收到数据后,就触发的事情
			xx.onerror = function(){...}	//出错时,中断处理	
			//注意由于使用laya,更方便调试,可使用 console.log("djdjdjdj");
			//特别是 onmessage 会得到一个参数,给 xx.onmessage = function(msg){...}中的 msg
			//而 msg.data就是 监听得到的字符串内容,注意,是字符串,一般是json格式的文本,
			//现在demo是一条信息一个弹窗!!
			//所以需要对文本进行处理,提取处理相关数据!!(后面再分析处理)
			//layai项目上的客户端例子:
				function client(){
				    var url = 'ws://127.0.0.1:8000';
				    var n = "jack";
				    var ws = false;
				    var scr = Array();
				    var i = 0;

				    ws = new WebSocket(url);
				    ws.onopen = function (){
				        if( ws.readyState ==1 )
				            ws.send('type=uu&ming='+n);
				    }
				    ws.onclose = function (){
				        console.log("C");
				        ws = false;
				    }
				    ws.onmessage = function (msg){
				        console.log("M");
				        //弹出弹窗
				        i += 1;
				        scr[i] = new tanchuangUI();
				        scr[i].txt.text = msg.data;
				        scr[i].x = 200;
				        scr[i].y = 200;
				        Laya.stage.addChild(scr[i]);
				        scr[i].out.on(Event.CLICK,this,onout1Click);
				    }
				    ws.onerror = function (){
				        console.log("E");
				    }
				    function onout1Click () {
				        Laya.stage.removeChild(scr[i]);
				        i -= 1;
				    }
				}
			//然后在主程序上调用					
		js的数据websocket数据处理:
			例如:
			{"type":"rmove","nrong":"5a02ace5d7ec9","code1":"all","code":false,"time":"11-08 09:05:04"}
			或者例如:
			{"nrong":"fghjkl","code1":"all","code":"5a02ace5d7ec9","time":"11-08 08:40:39"}
			这是一段收到的完整的json内容 放在onmessage的变量 msg.data上!!!
			eval('var da='+msg.data);	//把字符串解析成js命令执行,并返回字符串长度.
			执行的命令也就是 var da = {"nrong":"fghjkl","code1":"all","code":"5a02ace5d7ec9","time":"11-08 08:40:39"}
			直接把json文本转成 da 数组
			最后只不过是处理数组的问题
		php服务端重点:
			由于是参考 websoket-php-chat\websocket.php,
			握手,连接建立socket 的地方都是通用的, 注意这里会给没一个远程连接的socket分配一个独一无二的 $key
			然后就是内容的传递
			uncode()也是通用的,这里不是内容解密,而是内容编码的解码,什么16进制转10进制之类
			uncode后得到 就是真正得到的内容!!! 以字符串形式存在!!
			注意得到的内容一般是这种格式 aa=kkkk&uu=ghj&opl=yuioio
			笔记 users[] 数组变量:记录连接的用户
			this->users[$key] = array(
				'socket'=>$client,	//远程客户端对应服务端这边该连接的socket
				'shou'=>true,		//标记是否 握手连接了
				'name'=>'jack',		//远程客户端登录的用户名
			)
			那么,$this->users[$key]['socket'] 指的就是 $client这个变量	
			然后就是 需要自定义的 send函数!!
			先把接收的数据拆分成变量放到 $g 数组里: parse_str($string,$g);
			然后, 建立一个数组 $ar,把要发送出去的成员都赋值到里面去
			然后, json_encode($ar); 把数组打包成一个json文本格式的 字符串
			然后, code(这个字符串)；其实就是进制之间的编码,得到一个编码后的字符串.
			最后,socket_write($client_socket,$编码后的字符串,字符串长度)!!
	加入数据库和用户管理系统!!!
		使用ui,建立一个登录界面!
		js php 相互调用操作,
		其实就是了解通过 js 直接提交数据给php文本,然后php返回处理结果直接給js,并不会通过html脚本的方式来实现!!
		js直接 调用 PHP 斌没有什么好的例子,
		实际上问题的本质是应该如何实现 laya 上传递 get post 请求到 服务端php上!!!!!
		使用laya 提供的 httprequest 解决问题:
		剩下问题就是移植用户管理系统了!!		
	
注意点:
	虽然同一个js文件中,函数定义和函数调用位置顺序可以乱,
		但是如果是执行跨文件执行的函数时,是有顺序之分的,执行函数的文件要发在定义文件的函数之后
		<script src="../函数定义.js"></script>
		<script src="../函数执行.js"></script>
	加载资源时,
		asset.push({
		    url : ["res/atlas/comp.json"],	//json
		    type : Laya.Loader.ATLAS		//但是资源的类别是ATLAS
		})
		加载了json后,因为json记录了图包中的位置,所以后面的使用图片数据时直接加载就是了
		var btn = new Laya.Button("comp/button.png");








20171110
直播技术:
	RTMP 推流器，RTMP播放器（秒开）







20171113
ubuntu14.04 android_studio
方法1:(不推荐)
	$ sudo apt-add-repository ppa:paolorotolo/android-studio
	[sudo] password for infortech-ubuntu-1404: 
	 Automatic builds for Android Studio by Google packaged for Ubuntu.
	 更多信息： https://launchpad.net/~paolorotolo/+archive/ubuntu/android-studio
	按回车继续或者 Ctrl+c 取消添加	
	gpg: 钥匙环‘/tmp/tmp5z8v9dbp/secring.gpg’已建立
	gpg: 钥匙环‘/tmp/tmp5z8v9dbp/pubring.gpg’已建立
	gpg: 下载密钥‘7B9B74AA’，从 hkp 服务器 keyserver.ubuntu.com
	gpg: /tmp/tmp5z8v9dbp/trustdb.gpg：建立了信任度数据库
	gpg: 密钥 7B9B74AA：公钥“Launchpad PPA for Paolo Rotolo”已导入
	gpg: 合计被处理的数量：1
	gpg:               已导入：1  (RSA: 1)
	OK
	sudo apt-get update
	sudo apt-get install android-studio
方法2:(推荐)
	到这里下载最新版安装包: (进入网站要翻墙,但是下载不用!!!!)
		https://developer.android.com/		
		android-studio: android-studio-ide-171.4408382-linux.zip
		NDK包:android-ndk-r15c-linux-x86_64.zip	(下载了但没用到,因为直接使用ide安装了所有包!)
	安装studio!!
		安装支持包: sudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386 lib32z1 libbz2-1.0:i386
		解压studio安装包,
		./android-studio/bin/studio.sh
			没有自己的配置,所以不选择
			没有sdk,所以先cancel
			wizard,注意更改 sdk 的存放路径!!
	新建一个project ,安卓程序需要 gradle 编译器,而pc上斌没有安装,不要紧, 这时studio系统会自动安装更新gradle
	但是需要使用 http proxy 因为访问国外的网络!!!
	发现,dl.google.com 地址的不用翻墙
	原来之前是 gradle 编译器因为没有翻强的原因而没有被studio正确安装,
		所以导致后续一系列问题,如打开不了AVD manager 等!!
	终于使用 gradle build好了project, 准备建立一个虚拟设备(AVD)来调试!!,但是发现没有KVM!!!
	sudo apt-get install cpu-checker		//cpu检查工具
	kvm-ok						//cpu检查工具的命令
	sudo apt-get install qemu-kvm libvirt-bin ubuntu-vm-builder bridge-utils	//装 qemu-kvm
	sudo modprobe kvm_intel				//加载kvm驱动!!
	都没有用,然后 重启 seting bios 的 Virtualization, VT for Direst I/O Access 就好
	初始化虚拟设备还是不行, openGLES问题,其实 graphics 选择 software-gles就好了
	总之环境都搭好了!!







20171114
android 软件框架:
	manifest/Androidmanifest.xml (软件的综合配置文档)
	        <activity
	            android:name=".MainActivity"
	            android:label="@string/app_name">
	            <intent-filter>
	                <action android:name="android.intent.action.MAIN" />	//指定了app打开时执行的地一个activity
	                <category android:name="android.intent.category.LAUNCHER" />
	            </intent-filter>
	        </activity>
		//如果程序中没有声明了MAIN action 或者LAUNCHER category的activity，那么在设备的主界面列表里面不会呈现app图标
	rea/layout: 放置 activity的布局文件 xml,而xml里的内容一般有:
		<LinearLayout> : ViewGroup子类 属于主布局句柄 用于放置水平垂直子视图部件
		<RelativeLayout> : 属于主布局句柄 放置子视图部件比较灵活的布局
		<TextView .../>	, <Button .../> 等这些都属于子视图句柄,表示显示在activity上,并遵循指定布局的子部件视图,
		android:id="@+id/xxx" ,android:layout_width="wrap_content" ,android:layout_height="wrap_content"
			等等都是 句柄内的属性内容,设定了 布局/子视图 的位置,大小等属性
		常用属性:
		android:id :唯一标识符号,当需要从 XML 里引用资源对象时，必须使用 @ 符号。紧随 @ 之后的是资源的类型（这里是 id），
			    然后是资源的名字（这里使用的是 edit_message
		android:layout_width,android:layout_height,android:layout_weight :大小尺寸,权重
			属性参数例如有"wrap_content","0dp","1",等等,先不深究 
		android:hint :当文本框为空时,默认显示的内容!!
	res/values: 放置一些 指定值资源的 xml文件,例如 strings.xml,专门放置字符串资源!!
		例子:
		rea/layout/activity_main.xml 有个TextView部件,有个android:text属性:
			android:text="@string/interstitial_ad_sample"
		res/values/strings.xml 有个字符串资源:
			<string name="interstitial_ad_sample">Interstitial Ad Sample in william</string>
		最后仿真时会看到 那个 TextView子部件显示: Interstitial Ad Sample in william
	res/menu:
		跟集成的actionbar有关系用来布局在actionbar上的功能按键的 xml文件
		anctionbar在屏幕的上方,典型的action按键有 返回键, 搜索键, 其他功能按键下拉列表
	project树java/com.example.xxx/放置 activity 的地方:
		
activity 的概念:
	三个状态: 
		Resumed(活跃状态,正在显示,用户可交互操作), 
		Paused(被暂时阻塞,什么都不干一般表现屏幕上被弹窗activity遮蔽着其中部分,弹窗activity处于REsumed状态,)
		Stoped(完全不可见,处于后台,也是被阻塞着,什么都不干)
	状态的变换:
		oncreate()->onstart()->onResume()          onPause()	     onStop()        onDestroy()
	打开app ---------------------------------->Resumed ---------> Paused -------> Stoped ----------->已完全关闭
						     ^	^		|		|			
						     |	|  onResume()	|		|
						     |	|_______________|		|
						     |__________________________________|

							onResume()<-onRestart()
		一旦onCreate 操作完成，系统会迅速调用onStart() 与onResume()方法。
		我们的activity不会在Created或者Started状态停留。
		技术上来说, activity在onStart()被调用后开始被用户可见，
		但是 onResume()会迅速被执行使得activity停留在Resumed状态，
		直到一些因素发生变化才会改变这个状态。例如接收到一个来电，用户切换到另外一个activity，或者是设备屏幕关闭。
		重构的onCreate里 先执行的 super.onCreate()先执行父类的oncreate初始化.
		onDestroy 一般不用重构,
		但当onCreate时创建了后台线程,或者其他出现内存泄漏的可以问题时,就要自己重构清理
		有几个场景中，Activity是由于正常的程序行为而被Destory的。
		例如当用户点击返回按钮或者是Activity通过调用finish()来发出停止信号。
		系统也有可能会在Activity处于stop状态且长时间不被使用，
		或者是在前台activity需要更多系统资源的时关闭后台进程，以图获取更多的内存。
		当Activity是因为用户点击Back按钮或者是activity通过调用finish()结束自己时，
		系统就丢失了对Activity实例的引用，因为这一行为意味着不再需要这个activity了。
		然而，如果因为系统资源紧张而导致Activity的Destory， 
		系统会在用户回到这个Activity时有这个Activity存在过的记录，
		系统会使用那些保存的记录数据（描述了当Activity被Destory时的状态）来重新创建一个新的Activity实例。
		那些被系统用来恢复之前状态而保存的数据被叫做 "instance state" ，
		它是一些存放在Bundle对象中的key-value pairs。(请注意这里的描述，这对理解onSaveInstanceState执行的时刻很重要)
	(保存状态信息)onSaveInstanceState:
		当activity开始Stop，系统会调用 onSaveInstanceState() ，
		Activity可以用键值对的集合来保存状态信息。这个方法会默认保存Activity视图的状态信息，
		如在 EditText 组件中的文本或 ListView 的滑动位置。
		为了给Activity保存额外的状态信息，你必须实现onSaveInstanceState() 并增加key-value pairs到 Bundle 对象中，
		例如：
			static final String STATE_SCORE = "playerScore";
			static final String STATE_LEVEL = "playerLevel";
			...
			@Override	
			public void onSaveInstanceState(Bundle savedInstanceState) {	//重构onSaveInstanceState
			    // Save the user's current game state
			    savedInstanceState.putInt(STATE_SCORE, mCurrentScore);	//添加额外要保存的信息
			    savedInstanceState.putInt(STATE_LEVEL, mCurrentLevel);
			    ...	
			    // Always call the superclass so it can save the view hierarchy state
			    super.onSaveInstanceState(savedInstanceState);	//执行父类onSaveInstanceState函数实现保存
			}
	恢复Activity状态
		当Activity从Destory中重建，我们可以从系统传递的Activity的Bundle中恢复保存的状态。 
		onCreate() 与 onRestoreInstanceState() 回调方法都接收到了同样的Bundle，里面包含了同样的实例状态信息。
		由于 onCreate() 方法会在第一次创建新的Activity实例与重新创建之前被Destory的实例时都被调用，
		我们必须在尝试读取 Bundle 对象前检测它是否为null。
		如果它为null，系统则是创建一个新的Activity实例，而不是恢复之前被Destory的Activity。
		下面是一个示例：演示在onCreate方法里面恢复一些数据：

			@Override
			protected void onCreate(Bundle savedInstanceState) {
			    super.onCreate(savedInstanceState); // Always call the superclass first
			
			    // Check whether we're recreating a previously destroyed instance
			    if (savedInstanceState != null) {
			        // Restore value of members from saved state
			        mCurrentScore = savedInstanceState.getInt(STATE_SCORE);
			        mCurrentLevel = savedInstanceState.getInt(STATE_LEVEL);
			    } else {
			        // Probably initialize members with default values for a new instance
			    }
			    ...
			}			
		我们也可以选择实现 onRestoreInstanceState() ，而不是在onCreate方法里面恢复数据。 
		onRestoreInstanceState()方法会在 onStart() 方法之后执行.
		系统仅仅会在存在需要恢复的状态信息时才会调用 onRestoreInstanceState() ，因此不需要检查 Bundle 是否为null。
			public void onRestoreInstanceState(Bundle savedInstanceState) {
			    // Always call the superclass so it can restore the view hierarchy
			    super.onRestoreInstanceState(savedInstanceState);			
			    // Restore state members from saved instance
			    mCurrentScore = savedInstanceState.getInt(STATE_SCORE);
			    mCurrentLevel = savedInstanceState.getInt(STATE_LEVEL);
			}
Fragment 概念:
	内容组合块,一个activity上可以加入多个相互独立的内容组合块,各有自己的 UI布局, 
	每个fragment 都对应自己的 .java 和 .xml,
	把 fragment 放入activity,
		第一种方法是在activity的xml 里加入 <fragment...../> 字节点,并不需要修改 activity.java
		第二种方法是在activity的xml建立有id号标记的layout,然后在activity.java里给指定layout导入fragment
同一个app中,的数据交互 (preference文件)
	打开一个仅当前activity可访问的preference文件,没有会自动新建一个:
		SharedPreferences spref = getPreferences(MODE_PRIVATE);	
	打开一个同app里,所有activity都可访问的preference文件,没有会自动建一个
		//所有activity都可访问的preference文件可以很多个,所以要设置KEY标记文件
		public static final String KEY = "com.my.package.app";
		//打开这个指定 KEY 值的 preference文件,没有看就自动建一个
		SharedPreferences spref = getApplication().getSharedPreference(KEY, Context.MODE_PRIVATE); 
	读写 preference:
		//把打开的 preference 建立一个 editor对象
		SharedPreferences.Editor editor = spref.edit();
		//刷写请求
		editor.clear();		//清空 preference 文件内容 
		editor.putBoolean("KEY_BOOLxx", true);	//写入boolean数据
		editor.putFloat("KEY_FLOATxx", 18);	//写入float数据
		editor.putLong("KEY_LONGxx", 100);	//写入long数据
		editor.putString("KEY_STRINGxx", "Android 開發"); //写入string数据
		HashSet<String> hs = new HashSet<String>();	//写入组合数据
		hs.add("一月"); hs.add("二月");
		editor.putStringSet("KEY_STR_SET", hs);
		editor.remove("KEY_STRINGxx");		//删除 key值为KEY_STRINGxx 的数据
		//提交请求刷写 preference
		editor.apply();
		//提交请求刷写 preference,保留edtior对象,但释放其他资源,表示完成对preference的写操作
		editor.commit();
		//读取操作(不用透过 editor 对象实现)
		boolean booValue = spref.getBoolean("KEY_BOOL", true);
		float floatValue = spref.getFloat("KEY_FLOAT", 0);
		long longValue = spref.getLong("KEY_LONG", 0);
		String strValue = spref.getString("KEY_STRING", null);
		HashSet<String> hs = (HashSet<String>) spref.getStringSet("KEY_STR_SET", null);
		boolean exists = spref.contains("KEY_STRING")
文件数据存储:
	Internal storage:
	        总是可用的
	        这里的文件默认只能被我们的app所访问。
	        当用户卸载app的时候，系统会把internal内该app相关的文件都清除干净。
	        Internal是我们在想确保不被用户与其他app所访问的最佳存储区域。
	External storage:
	        并不总是可用的，因为用户有时会通过USB存储模式挂载外部存储器，当取下挂载的这部分后，就无法对其进行访问了。
	        是大家都可以访问的，因此保存在这里的文件可能被其他程序访问。
	        当用户卸载我们的app时，系统仅仅会删除external根目录（getExternalFilesDir()）下的相关文件。
	        External是在不需要严格的访问权限并且希望这些文件能够被其他app所共享或者是允许用户通过电脑访问时的最佳存储区域。
		Public files :
			这些文件对与用户与其他app来说是public的，当用户卸载我们的app时，这些文件应该保留。
			例如，那些被我们的app拍摄的图片或者下载的文件。
		Private files: 
			这些文件完全被我们的app所私有，它们应该在app被卸载时删除。尽管由于存储在external storage，
			那些文件从技术上而言可以被用户与其他app所访问，但实际上那些文件对于其他app没有任何意义。
			因此，当用户卸载我们的app时，系统会删除其下的private目录。例如，那些被我们的app下载的缓存文件。
    	app是默认被安装到internal storage的，
		可以通过在程序的manifest文件中声明android:installLocation 属性来指定程序安装到external storage。
		更多安装信息见App Install Location。
	External storage 读写权限声明:
		<manifest ...>
		    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
	            <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
		    ...
		</manifest>
		允许写权限,也就默许了读权限
	关于Internal目录里的文件操作的一些重点函数:
		//新建一个文件,getFilesDir()返回一个File，代表了我们app的internal目录
		File file = new File(context.getFilesDir(), filename);	
		//执行openFileOutput() 打开internal目录的filename文件,
	  	outputStream = openFileOutput(filename, Context.MODE_PRIVATE);
	  	outputStream.write(string.getBytes());
	  	outputStream.close();
		//打开一个缓存文件
		file = File.createTempFile(fileName, null, context.getCacheDir());
	在External目录里的文件操作重点:
		//检测权限,是否可读
		 /* Checks if external storage is available for read and write */
		public boolean isExternalStorageWritable() {
		    String state = Environment.getExternalStorageState();
		    if (Environment.MEDIA_MOUNTED.equals(state)) {
		        return true;
		    }
		    return false;
		}
		/* Checks if external storage is available to at least read */
		public boolean isExternalStorageReadable() {
		    String state = Environment.getExternalStorageState();
		    if (Environment.MEDIA_MOUNTED.equals(state) ||
		        Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {
		        return true;
		    }
		    return false;
		}
		//想将文件以public形式保存在external storage中，用getExternalStoragePublicDirectory()获取一个 File 对象
		File file = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES), albumName);
		//想将文件以private形式保存在external storage中，用getExternalFilesDir() 获取相应的目录，
		File file = new File(context.getExternalFilesDir(Environment.DIRECTORY_PICTURES), albumName);
			getExternalFilesDir() 方法会创建的目录会在app被卸载时被系统删除。
			如果我们的文件想在app被删除时仍然保留，请使用getExternalStoragePublicDirectory().
			无论是使用 getExternalStoragePublicDirectory() 来存储可以共享的文件，
			还是使用 getExternalFilesDir() 来储存那些对于我们的app来说是私有的文件，
			有一点很重要，要使用那些类似DIRECTORY_PICTURES 的API的常量。那些目录类型参数可以确保那些文件被系统正确的对待。
			例如，那些以DIRECTORY_RINGTONES 类型保存的文件就会被系统的media scanner认为是ringtone而不是音乐。
	查询剩余空间: 
		getFreeSpace() or getTotalSpace()
	删除文件:
		myFile.delete();
		如果文件是保存在internal storage，我们可以通过Context来访问并通过执行deleteFile()进行删除
		myContext.deleteFile(fileName);
数据库操作:
	这是在设备本身建立访问数据库,不太常用,暂时不看
app间交互!!!(intent概念)
	Intent() 的参数有多个种类:
		没有参数的;
		Intent类对象;
		string变量;
		string变量,URI变量;	(唤醒其他app执行,属于 implicit intent )
		Context packetContext,Class; (传递给同app,别的activity执行,属于explicit intent Context packetContext填this !! )
		sting变量,URI变量,Context packetContext,Class;
	不论是打开别的app,还是app自己的其他activity,建立的intent 最终通过 startActivity 发给系统来实现!!
	也有Intent交互是需要得到result的,这时用 startActivityForResult(xxIntent, PICK_CONTACT_REQUEST);
	得到result后的处理一般这样子:
		@Override
		protected void onActivityResult(int requestCode, int resultCode, Intent data) {
		    // Check which request we're responding to
		    if (requestCode == PICK_CONTACT_REQUEST) {	//PICK_CONTACT_REQUEST 请求标记
		        // Make sure the request was successful
		        if (resultCode == RESULT_OK) {		//RESULT_OK 成功得到result
		            // The user picked a contact.
		            // The Intent's data Uri identifies which contact was selected.
		
		            // Do something with the contact here (bigger example below)
		        }
		    }
		}
	一个app 如果要响应Intent交互的,需要在manifest文件中的<activity>标签下添加<intent-filter>的属性,例如:
		<activity android:name="ShareActivity">
		    <!-- filter for sending text; accepts SENDTO action with sms URI schemes -->
		    <intent-filter>
		        <action android:name="android.intent.action.SENDTO"/>	   //app会响应的对应intent的信号
		        <category android:name="android.intent.category.DEFAULT"/> //所有implicit intents都默认是CATEGORY_DEFAULT 类型的
		        <data android:scheme="sms" />	//intent传来的数据
		        <data android:scheme="smsto" />	//intent传来的数据
		    </intent-filter>
		    <!-- filter for sending text or images; accepts SEND action and text or image data -->
		    <intent-filter>
		        <action android:name="android.intent.action.SEND"/>
		        <category android:name="android.intent.category.DEFAULT"/>
		        <data android:mimeType="image/*"/>
		        <data android:mimeType="text/plain"/>
		    </intent-filter>
		</activity>
	响应了intent的app这样子取得交互信息
		Intent intent = getIntent();
		Uri data = intent.getData();
	有些响应了intent的app还要返回result,返回result的一般操作是建立另一个intent发出
		Intent result = new Intent("com.example.RESULT_ACTION", Uri.parse("content://result_uri");
		setResult(Activity.RESULT_OK, result);
		finish();	//主动结束app 或者activity
网络操作
	manifest 文件中添加以下权限：
		<uses-permission android:name="android.permission.INTERNET" />	//允许应用程序打开网络套接字
		<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />	//允许应用程序访问网络连接信息
	ConnectivityManager：它会回答关于网络连接的查询结果，并在网络连接改变时通知应用程序。
	NetworkInfo：描述一个给定类型（就本节而言是移动网络或 Wi-Fi）的网络接口状态。
	以下片段检查了 wifi 和 移动网络的连接情况
		private static final String DEBUG_TAG = "NetworkStatusExample";
		...
		ConnectivityManager connMgr = (ConnectivityManager)
		        getSystemService(Context.CONNECTIVITY_SERVICE);
		NetworkInfo networkInfo = connMgr.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
		boolean isWifiConn = networkInfo.isConnected();
		networkInfo = connMgr.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
		boolean isMobileConn = networkInfo.isConnected();
		Log.d(DEBUG_TAG, "Wifi connected: " + isWifiConn);
		Log.d(DEBUG_TAG, "Mobile connected: " + isMobileConn); 
	一个更简洁的检查网络是否可用的示例如下。
		getActiveNetworkInfo() 方法返回一个 NetworkInfo 实例，它表示可以找到的第一个已连接的网络接口，
		如果返回 null，则表示没有已连接的网络接口(意味着网络连接不可用)：
		public void myClickHandler(View view) {
		    ...
		    ConnectivityManager connMgr = (ConnectivityManager)
		        getSystemService(Context.CONNECTIVITY_SERVICE);
		    NetworkInfo networkInfo = connMgr.getActiveNetworkInfo();	//获取网络情况
		    if (networkInfo != null && networkInfo.isConnected()) {	//检查网络是否连接
		        // fetch data
		    } else {
		        // display error
		    }
		    ...
		}
	一个单独的线程中执行网络操作例子:
		public class HttpExampleActivity extends Activity {
		    private static final String DEBUG_TAG = "HttpExample";
		    private EditText urlText;
		    private TextView textView;	//对 class HttpExampleActivity 全体可视的类对象!!
		    @Override
		    public void onCreate(Bundle savedInstanceState) {
		        super.onCreate(savedInstanceState);
		        setContentView(R.layout.main);
		        urlText = (EditText) findViewById(R.id.myUrl);
		        textView = (TextView) findViewById(R.id.myText);
		    }
		    // 按键处理函数,会触发一个线程 AsyncTask(异步任务)
		    public void myClickHandler(View view) {
		        String stringUrl = urlText.getText().toString();  // 从 uriText 文本框中 获取填写的 URL
		        ConnectivityManager connMgr = (ConnectivityManager)
		            getSystemService(Context.CONNECTIVITY_SERVICE);
		        NetworkInfo networkInfo = connMgr.getActiveNetworkInfo();
		        if (networkInfo != null && networkInfo.isConnected()) {	//检查网络连接
		            new DownloadWebpageText().execute(stringUrl);	//传递url 执行下载线程
		        } else {
		            textView.setText("No network connection available.");
		        }
		    }
		     // Uses AsyncTask to create a task away from the main UI thread. This task takes a
		     // URL string and uses it to create an HttpUrlConnection. Once the connection
		     // has been established, the AsyncTask downloads the contents of the webpage as
		     // an InputStream. Finally, the InputStream is converted into a string, which is
		     // displayed in the UI by the AsyncTask's onPostExecute method.
		     private class DownloadWebpageText extends AsyncTask {	//下载线程
		        @Override
		        protected String doInBackground(String... urls) {
		            // params comes from the execute() call: params[0] is the url.
		            try {
		                return downloadUrl(urls[0]);	//连接url 并执行下载操作!!
		            } catch (IOException e) {
		                return "Unable to retrieve web page. URL may be invalid.";
		            }
		        }
		        // onPostExecute displays the results of the AsyncTask.
		        @Override
		        protected void onPostExecute(String result) {	//下载完,接收结果字符串并把它显示到 UI textView 上
		            textView.setText(result);	
		       }
		    }
		    ...
			// Given a URL, establishes an HttpUrlConnection and retrieves
			// the web page content as a InputStream, which it returns as
			// a string.
		    private String downloadUrl(String myurl) throws IOException {	//下载操作
		        InputStream is = null;
			// Only display the first 500 characters of the retrieved
			// web page content.
			int len = 500;
			try {
			        URL url = new URL(myurl);	//建立URL数据对象
			        HttpURLConnection conn = (HttpURLConnection) url.openConnection(); //建立http连接请求对象
			        conn.setReadTimeout(10000 /* milliseconds */);		//设置读取超时
			        conn.setConnectTimeout(15000 /* milliseconds */);	//设置连接超时
			        conn.setRequestMethod("GET");				//设置请求类型
			        conn.setDoInput(true);					//??
			        // Starts the query
			        conn.connect();			//开始连接到 URL 地址
			        int response = conn.getResponseCode();
			        Log.d(DEBUG_TAG, "The response is: " + response);
			        is = conn.getInputStream();		//下载获取的 InputStream 数据
			        // Convert the InputStream into a string
			        String contentAsString = readIt(is, len);	//把InputStream 数据 转为字符串
			        return contentAsString;		
		        // Makes sure that the InputStream is closed after the app is
		        // finished using it.
		        } finally {
			        if (is != null) {
			            is.close();
		        	}
		    	}
		    }
		    //把InputStream 数据 转为字符串 的函数
		    public String readIt(InputStream stream, int len) throws IOException, UnsupportedEncodingException {
		        Reader reader = null;
		        reader = new InputStreamReader(stream, "UTF-8");
		        char[] buffer = new char[len];
		        reader.read(buffer);
		        return new String(buffer);
		    }
		    //扩展知识, 假设下载的是图片,显示图片.
		    public void imageshow( InputStream stream ){
			Bitmap bitmap = BitmapFactory.decodeStream(stream);
			ImageView imageView = (ImageView) findViewById(R.id.image_view);
			imageView.setImageBitmap(bitmap);			
		    }
		}
通知 notification:(讲的好烂,没有例子,不知道怎么理解,特别是,更想知道没有打开app情况下如何出通知的!!)	

用户输入:
	gestureinput相关

后台,唤醒,闹钟
	应用打开时,设置的后台,后台,唤醒,闹钟会保存在系统正常工作,即使应用退出了也不影响!!
多线程:
	Thread和Runnable只是两个基本的线程类，通过他们能发挥的作用有限，但是他们是强大的Android线程类的基础类，
	例如Android中的HandlerThread, AsyncTask和IntentService都是以它们为基础。Thread和Runnable同时也是ThreadPoolExecutor类的基础。
	ThreadPoolExecutor类能自动管理线程和任务队列，甚至可以并行执行多个线程。
	一个app 有一个UI线程 和多个后台线程, (ui与后台线程交互):
	这里所谓的交互是 后台把数据准备后,发系统通知,让UI线程通过 Handler,handlerMessage处理

重点实践
新建一个 activity:
	在activity布局里添加一个 button 子视图, 且android:onClick="nac"
	在java/com.example.xxx/MainActivity: 主activity类上添加一个函数:
		import android.content.Intent;
		public class MainActivity extends AppCompatActivity {...
		    public static String EXTRA_MESSAGE;		//设置一个信号标记
		    public void nac(View view){
		        //new activity
		        Intent in1 = new Intent(this,SecondActivity.class); 	//新建一个信号
		        TextView Tx1 =(TextView) findViewById(R.id.app_title);	//寻找id为app_title 的TextView 子视图,并为其新建一个类对象
		        String mes1 = Tx1.getText().toString();	//获取这个TextView 预置的 Text内容
		        in1.putExtra(EXTRA_MESSAGE,mes1);	//添加信号内容
		        startActivity(in1);	//启动一个 activity
		    }
		...
		}
	在project树java/com.example.xxx/右键->new->Activity->Basic activity新建一个activity
		Activity Name : SecondActivity
		Layout Name : activity_second
		Title : NO2
		Hierarchiral Parent :com.example.xxx.my1,MainActivity	//设置从属的父activity,从属关系与导航有关!!
		finish
	在manifests/AndroidManifest.xml可以查看得到新的activity的相关部署配置
		如果之前的 Hierarchiral Parent 没有设置,也可以在这里补充
	        <activity
	            android:name=".SecondActivity"
	            android:label="@string/title_activity_second"
	            android:parentActivityName=".MainActivity">		//设置从属的父activity 另一方法
	            <meta-data
	                android:name="android.support.PARENT_ACTIVITY"
	                android:value=".MainActivity"/>
	        </activity>
	修改java/com.example.xxx/SecondActivity:
		import android.support.constraint.ConstraintLayout;		//需要用到这个 layout类
		public class SecondActivity extends AppCompatActivity {
		    ...
		    @Override
		    protected void onCreate(Bundle savedInstanceState) {
			....
		        //william
		        Intent in2 = getIntent();	//获取信号,
		        String mes2 = in2.getStringExtra(MainActivity.EXTRA_MESSAGE);//筛选信号,注意这个要在onCreate里执行,不能在之外执行
		        TextView tx2 = new TextView(this);
		        tx2.setTextSize(90);
		        tx2.setText(mes2);
		        ConstraintLayout lay2 = (ConstraintLayout) findViewById(R.id.include);//找到 id为include 的ConstraintLayout
		        lay2.addView(tx2); 	//给这个layout里额外添加一个TextView对象
		        TextView mes1 = (TextView) findViewById(R.id.textView3);	//找到id为textView3 的TextView
		        mes1.setText("i love bilibili");	//改变他的text内容为 i love bilibili
		    }
		}
	这时,我们更要注意对应的 res/layout中的 activity_second.xml
		<?xml version="1.0" encoding="utf-8"?>
		<android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android"
		    xmlns:app="http://schemas.android.com/apk/res-auto"
		    xmlns:tools="http://schemas.android.com/tools"
		    android:layout_width="match_parent"
		    android:layout_height="match_parent"
		    tools:context="com.example.kingders.my1.SecondActivity">
		    ...
		    <include
		        android:id="@+id/include"
		        layout="@layout/content_second"		//这个内嵌include 使用的布局content_second.xml
		        android:layout_height="162dp"
		        tools:layout_editor_absoluteY="405dp" />
		    ....
		</android.support.design.widget.CoordinatorLayout>
		其中又内嵌了一个 content_second.xml 布局:
		<?xml version="1.0" encoding="utf-8"?>
		<android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
		    xmlns:app="http://schemas.android.com/apk/res-auto"
		    xmlns:tools="http://schemas.android.com/tools"
		    android:layout_width="match_parent"
		    android:layout_height="match_parent"
		    app:layout_behavior="@string/appbar_scrolling_view_behavior"
		    tools:context="com.example.kingders.my1.SecondActivity"
		    tools:layout_editor_absoluteY="81dp"
		    tools:showIn="@layout/activity_second">
		    ...
		    <TextView
		        android:id="@+id/textView3"
		        android:layout_width="162dp"
		        android:layout_height="61dp"
		        android:text="TextView"
		        tools:layout_editor_absoluteX="111dp"
		        tools:layout_editor_absoluteY="212dp" />
		    ...
		</android.support.constraint.ConstraintLayout>
	对比,我们寻找 对象的过程,
		TextView mes1 = (TextView) findViewById(R.id.textView3);
		ConstraintLayout lay2 = (ConstraintLayout) findViewById(R.id.include);
		发现,布局layout的id 和 子视图例如TextView的id 定义的位置不一样

添加actionbar:(android4.0以上的方法)		
	修改res/menu/menu_main.xml:
		<menu ....>
		    <item				//添加搜索按键
		        android:id="@+id/ac_search"
		        android:icon="@drawable/ic_action_search"	//按键图标ic_action_search.png放到drawable文件夹
		        android:title="@string/action_search"
		        app:showAsAction="ifRoom"	//显示在actionabar上
		            />
		    <item
		        android:id="@+id/action_settings"
		        android:orderInCategory="100"
		        android:title="@string/action_settings"
		        app:showAsAction="never" />	//不显示在actionbar,集成到下拉按键列表
		</menu>
	修改java/com.example.xxx/SecondActivity 和 MainActivity,显示按键到actionbar,并添加 menu按键事件
		    @Override
		    public boolean onCreateOptionsMenu(Menu menu) {		//添加显示
		        // Inflate the menu; this adds items to the action bar if it is present.
		        getMenuInflater().inflate(R.menu.menu_main, menu);
		        return true;
		    }	
		    @Override
		    public boolean onOptionsItemSelected(MenuItem item) {	//按键事件
		        // Handle action bar item clicks here. The action bar will
		        // automatically handle clicks on the Home/Up button, so long
		        // as you specify a parent activity in AndroidManifest.xml.
		        int id = item.getItemId();
		
		        switch(item.getItemId()) {
		            case R.id.ac_search:
		                //openSearch();
		                return true;
		            case R.id.action_settings:
		                return true;
		            default:
		                return super.onOptionsItemSelected(item);
		        }
		    }
	由于 SecondActivity 和 MainActivity 有从属关系,在SecondActivity的 onCreate()添加:
	        getSupportActionBar().setDisplayHomeAsUpEnabled(true);
		即实现了SecondActivity actionbar 添加返回键,返回到上级 activity,即 MainActivity
		前提是public class Secondactivity extends AppCompatActivity	//继承 AppCompatActivity

添加fragment重点:
	先建立一个例子fragment: 对应xml 和 java
		// res/layout/fragment_hello.xml:
			<?xml version="1.0" encoding="utf-8"?>
			<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
			    android:layout_width="match_parent"
			    android:layout_height="match_parent"
			    android:orientation="vertical" >
			
			    <EditText
			        android:layout_width="match_parent"
			        android:layout_height="wrap_content"
			        android:hint="请输入内容"/>
			    <RatingBar
			        android:id="@+id/ratingBar1"
			        android:layout_width="wrap_content"
			        android:layout_height="wrap_content" />
			</LinearLayout>
		// java/com/example/kingders/my1/HelloFragment.java	(这是这个自定义 fragment 的源码)
			package com.example.kingders.my1;
			import android.app.Fragment;
			import android.os.Bundle;
			import android.view.LayoutInflater;
			import android.view.View;
			import android.view.ViewGroup;		
			public class HelloFragment extends Fragment {		
			    @Override
			    public void onCreate(Bundle savedInstanceState) {
			        super.onCreate(savedInstanceState);
			    }
			    @Override
			    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
			        View view = inflater.inflate(R.layout.fragment_hello, null);  
				// View android.view.LayoutInflater.inflate(int resource, ViewGroup root)
			        return view;
			    }
			    @Override
			    public void onPause() {
			        super.onPause();
			    }
			}
	把fragment加入到 activity 里
		第一种方法:直接在 activity.xml里 加入fragment 节点
			    <fragment					//加入fragment 节点
			        android:id="@+id/fragment_hello"	//设置fragment 节点 id
			        android:name="com.example.kingders.my1.HelloFragment"	//这个 fragment 使用的 源码
			        android:layout_width="wrap_content"
			        android:layout_height="wrap_content" />
			    <fragment					//加入第二个fragment 节点
			        android:id="@+id/fragment_hello2"	//第二个fragment 节点 id
			        android:name="com.example.kingders.my1.HelloFragment"	//这个 fragment 使用的 源码
			        android:layout_width="wrap_content"
			        android:layout_height="wrap_content" />
		第二种方法:先在	activity.xml里设定一个 有 id 的 layout
			    <LinearLayout
			        android:id="@+id/fragment_hello3"
			        android:layout_width="wrap_content"
			        android:layout_height="wrap_content"
			        android:layout_weight="1"
			        android:background="#00FFFF">
			    </LinearLayout>
			然后在activity.java 加入插入代码:例如在 onCreate里加入
			package com.example.kingders.my1;
			import android.app.Activity;
			import android.app.FragmentManager;
			import android.app.FragmentTransaction;
			import android.os.Bundle;
			public class thirdActivity extends Activity {
			    @Override
			    protected void onCreate(Bundle savedInstanceState) {
			        super.onCreate(savedInstanceState);
			        setContentView(R.layout.activity_third);
				//在 id 为fragment_hello3 的layout里 插入一个 Fragment
			        FragmentManager fragmentManager =getFragmentManager();
			        FragmentTransaction fragmentTransaction =fragmentManager.beginTransaction();
			        HelloFragment helloFragment = new HelloFragment();
			        fragmentTransaction.add(R.id.fragment_hello3,helloFragment);
			        fragmentTransaction.commit();
			    }
			}
		更换fragment,建立在第二种方法的基础上.
		        //在activity.xml上加一个按钮,
			    <Button
			        android:id="@+id/changefrag"
			        android:layout_width="wrap_content"
			        android:layout_height="wrap_content"
			        android:text="changefragment"/>
			//然后在onCreate()加上这一段
		        Button button = (Button) findViewById(R.id.changefrag);
		        button.setOnClickListener(new View.OnClickListener() {
		            @Override
		            public void onClick(View v) {
				//建立一个新FragmentManager对象,不要用原来的,onCreate上建立的,因为区域问题
		                FragmentManager fragmentManager1 =getFragmentManager();
		                FragmentTransaction fragmentTransaction1 =fragmentManager1.beginTransaction();
		                BiliFragment biliFragment = new BiliFragment();
				//替换fragment
		                fragmentTransaction1.replace(R.id.fragment_hello3,biliFragment);
				//回栈
		                fragmentTransaction1.addToBackStack(null);
				//提交显示
		                fragmentTransaction1.commit();
		            }
		        });
XML操作(未实际操作过):
	一个例子xml
	<?xml version="1.0" encoding="utf-8"?>
	<feed xmlns="http://www.w3.org/2005/Atom" xmlns:creativeCommons="http://backend.userland.com/creativeCommonsRssModule" ...">
	<title type="text">newest questions tagged android - Stack Overflow</title>
	...
	    <entry>
	    ...
	    </entry>
	    <entry>
	        <id>http://stackoverflow.com/q/9439999</id>
	        <re:rank scheme="http://stackoverflow.com">0</re:rank>
	        <title type="text">Where is my data file?</title>
	        <category scheme="http://stackoverflow.com/feeds/tag?tagnames=android&sort=newest/tags" term="android"/>
	        <category scheme="http://stackoverflow.com/feeds/tag?tagnames=android&sort=newest/tags" term="file"/>
	        <author>
	            <name>cliff2310</name>
	            <uri>http://stackoverflow.com/users/1128925</uri>
	        </author>
	        <link rel="alternate" href="http://stackoverflow.com/questions/9439999/where-is-my-data-file" />
	        <published>2012-02-25T00:30:54Z</published>
	        <updated>2012-02-25T00:30:54Z</updated>
	        <summary type="html">
	            <p>I have an Application that requires a data file...</p>
	
	        </summary>
	    </entry>
	    <entry>
	    ...
	    </entry>
	...
	</feed>
	先实例化一个分析器
	public List parse(InputStream in) throws XmlPullParserException, IOException {	//in 是网上收到的InputStream数据,
	    try {										//是关于 一个xml文件 的数据!!
	        XmlPullParser parser = Xml.newPullParser();
	        parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, false);
                parser.setInput(in, null);
	        parser.nextTag();
	        return readFeed(parser);	//读取xml数据
	    } finally {
	        in.close();
	    }
	}
	读取xml里的数据
	private static final String ns = null;		//不知道是什么namespace 
	private List readFeed(XmlPullParser parser) throws XmlPullParserException, IOException {
	    List entries = new ArrayList();		//初始化一个数组
	    parser.require(XmlPullParser.START_TAG, ns, "feed");	//找到 feed 节点
	    while (parser.next() != XmlPullParser.END_TAG) {	//parser.next()扒到下一个节点
	        if (parser.getEventType() != XmlPullParser.START_TAG) {
	            continue;
	        }
	        String name = parser.getName();
	        // Starts by looking for the entry tag
	        if (name.equals("entry")) {		//找到 一个/下一个 entry节点
	            entries.add(readEntry(parser));	//读取这个entry节点的内容,构成一个 entry 类对象,然后放入数组
	        } else {
	            skip(parser);
	        }
	    }
	    return entries;
	}
	读取节点内容的具体实现
	public static class Entry {		//节点 entry 类 声明
	    public final String title;
	    public final String link;
	    public final String summary;
	
	    private Entry(String title, String summary, String link) {
	        this.title = title;
	        this.summary = summary;
	        this.link = link;
	    }
	}
	//读取entry节点的内容 ,最终构成 entry 类对象
	private Entry readEntry(XmlPullParser parser) throws XmlPullParserException, IOException { 
	    parser.require(XmlPullParser.START_TAG, ns, "entry");	
	    String title = null;
	    String summary = null;
	    String link = null;
	    while (parser.next() != XmlPullParser.END_TAG) {
	        if (parser.getEventType() != XmlPullParser.START_TAG) {
	            continue;
	        }
	        String name = parser.getName();
	        if (name.equals("title")) {
	            title = readTitle(parser);
	        } else if (name.equals("summary")) {
	            summary = readSummary(parser);
	        } else if (name.equals("link")) {
	            link = readLink(parser);
	        } else {
	            skip(parser);
	        }
	    }
	    return new Entry(title, summary, link);
	}
	//读取entry节点 的 title节点 内容
	private String readTitle(XmlPullParser parser) throws IOException, XmlPullParserException {
	    parser.require(XmlPullParser.START_TAG, ns, "title");
	    String title = readText(parser);
	    parser.require(XmlPullParser.END_TAG, ns, "title");
	    return title;
	}
	//读取entry节点 的 link节点 内容
	private String readLink(XmlPullParser parser) throws IOException, XmlPullParserException {
	    String link = "";
	    parser.require(XmlPullParser.START_TAG, ns, "link");
	    String tag = parser.getName();
	    String relType = parser.getAttributeValue(null, "rel");
	    if (tag.equals("link")) {
	        if (relType.equals("alternate")){
	            link = parser.getAttributeValue(null, "href");
	            parser.nextTag();
	        }
	    }
	    parser.require(XmlPullParser.END_TAG, ns, "link");
	    return link;
	}

	//读取entry节点 的 summary节点 内容
	private String readSummary(XmlPullParser parser) throws IOException, XmlPullParserException {
	    parser.require(XmlPullParser.START_TAG, ns, "summary");
	    String summary = readText(parser);
	    parser.require(XmlPullParser.END_TAG, ns, "summary");
	    return summary;
	}

	//读取文本内容的的方法
	private String readText(XmlPullParser parser) throws IOException, XmlPullParserException {
	    String result = "";
	    if (parser.next() == XmlPullParser.TEXT) {
	        result = parser.getText();
        parser.nextTag();
		    }
	    return result;
	}
	  ...
	}
	//跳过不关心的节点
	private void skip(XmlPullParser parser) throws XmlPullParserException, IOException {
	    if (parser.getEventType() != XmlPullParser.START_TAG) {
	        throw new IllegalStateException();
	    }
	    int depth = 1;
	    while (depth != 0) {
	        switch (parser.next()) {
	        case XmlPullParser.END_TAG:
	            depth--;
	            break;
	        case XmlPullParser.START_TAG:
	            depth++;
	            break;
	        }
	    }
	}
分析官方的 threadsample 来认识 多线程处理,后台线程建立!! (android/project/threadsample.zip)
	移植中遇到的问题google可解决:
	属于运行在UI线程的有 activity, photofra gment-photoview-phototask-photomanager
	属于运行在后台线程的有 photodecoderrunnable,photodownloadrunnable
	首先,photomanager运行在ui线程的一个后台线程管理,他建立了线程池队列,并实现了把任务加入到线程池队列执行的操作!
		然后整个app只有一个 photomanager类的实例对象,因为类参数几乎都是static 标记,
		相当于整个app只有一个 后台线程管理器!
		public class PhotoManager {
		    private static PhotoManager sInstance = null;
		    static {
		        
		        // The time unit for "keep alive" is in seconds
		        KEEP_ALIVE_TIME_UNIT = TimeUnit.SECONDS;
		        
		        // Creates a single static instance of PhotoManager
		        sInstance = new PhotoManager();
		    }
		    /**
		     * Constructs the work queues and thread pools used to download and decode images.
		     */
		    private PhotoManager() {
		    ...
		    }
		}
		观察 photomanager类声明,但app启动时,会实例化一个photomanager类,这时会执行static{...}的代码
		然而这 static{...}的代码 又会递归实例化一个新的photomanager类,先称这是第二次实例化
		第二次实例化,有些不同,并不会再执行一次static{...}的代码,因为第一次已经做了,
		还有因为photomanager类里很多参数都是static前缀的,第一次实例化时就存在了,
		第二次实例化,并不会新建一个,而是共用第一次实例化生成的参数对象,
		然后,第二次实例化继续执行重构的构造函数private PhotoManager(),给各个共用的参数对象初始化赋值!!!
		完成了第二次实例化,回到第一次实例化!!
		第一次实例化,又执行了一遍构造函数private PhotoManager(),可以认为又初始化一遍.
		所以特别注意这种诡异的实例化行为的写法!!
	每个后台执行的线程 的任务 都是实现 Runnable 接口的类
		class PhotoDecodeRunnable implements Runnable {
		...
		    /*
		     * 定义要后台线程执行的 这个任务中的代码
		     */
		    @Override
		    public void run() {
		        // 把当前的线程变成后台执行的线程
		        android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
		        ...
		        //在PhotoTask实例中存储当前线程状态，
		        mPhotoTask.setImageDecodeThread(Thread.currentThread());
		        ...
			if (Thread.interrupted()) {	//在执行亢长内容前主动检测有没有被中断
			    return;
			}
			...
			//解码一张bitmap 图片 (CPU-intensive)
			BitmapFactory.decodeByteArray(
			        imageBuffer, 0, imageBuffer.length, bitmapOptions);
			...
		    }
		...
		}
		run()就是塞给后台线程执行的任务内容,
		后台线程运行的任务在等待内容,或者没有任务时,会处于等待状态,
		这时,可以中断这个后台线程释放占用某个cpu直接去干其他事
		但当后台线程正在运转任务时,ui线程传来的中断信号并不会停止后台线程正在的工作,
		所以后台线程上执行的任务,要主动检测是否得到中断信号,特别是在进入亢长的操作前先保存状态,检查有没有中断信号
		这样可以让响应更敏捷
	继续看phhotomanager后台线程管理细节!
		public class PhotoManager {
		    //获取可用的线程数(即有多少个cpu可用)
		    private static int NUMBER_OF_CORES = Runtime.getRuntime().availableProcessors();
		    ...
		    //实例化 PhotoManager 时执行的这个构造函数建立了 一个任务队列, 一个线程池
		    private PhotoManager() {
		        ...
		        // A queue of Runnables 建立了 一个下载任务的队列, 
		        private final BlockingQueue<Runnable> mDownloadWorkQueue;
		        ...
		        // Instantiates the queue of Runnables as a LinkedBlockingQueue 实例化队列
		        mDownloadWorkQueue = new LinkedBlockingQueue<Runnable>();
		        ...
		        // Sets the amount of time an idle thread waits before terminating
		        private static final int KEEP_ALIVE_TIME = 1;
		        // Sets the Time Unit to seconds
		        private static final TimeUnit KEEP_ALIVE_TIME_UNIT = TimeUnit.SECONDS;
		        // Creates a thread pool manager 为下载任务的队列 建立了一个线程池
		        mDownloadThreadPool = new ThreadPoolExecutor(
		                NUMBER_OF_CORES,       // Initial pool size
		                NUMBER_OF_CORES,       // Max pool size
		                KEEP_ALIVE_TIME,
		                KEEP_ALIVE_TIME_UNIT,
		                mDownloadWorkQueue);
		    }
		    // Called by the PhotoView to 新建一个下载任务加入到线程池 (去下载一张图片)
		    static public PhotoTask startDownload(
		        PhotoView imageView,
		        boolean cacheFlag) {
		        ...
		        // 添加一个 下载任务 到 后台下载线程池,让后台下载线程的run()执行
		        sInstance.mDownloadThreadPool.execute(downloadTask.getHTTPDownloadRunnable());
		        ...
		    }
	            // Defines a Handler object that's attached to the UI thread (与ui线程交互相关)
		    // 即这个handler 会由UI线程执行
	            mHandler = new Handler(Looper.getMainLooper()) {
	                /*
	                 * handleMessage() defines the operations to perform when
	                 * the Handler receives a new Message to process.
	                 */
		        @Override
		        public void handleMessage(Message inputMessage) {
		            // Gets the image task from the incoming Message object.
		            PhotoTask photoTask = (PhotoTask) inputMessage.obj;
		            ...
		        }
		    ...
		    }
		...
		}
		重点关注 Handler 
		Handler属于Android系统的线程管理框架的一部分。一个Handler对象用于接收消息和执行处理消息的代码。
		一般情况下，如果你为一个新线程创建了一个Handler，你还需要创建一个Handler，让它与一个已经存在的线程关联，
		用于这两个线程之间的通信。如果你把一个Handler关联到UI线程，处理消息的代码就会在UI线程中执行。
		你可以在一个用于创建你的线程池的类的构造方法中实例化一个Handler对象，并把它定义为全局变量，
		然后通过使用Handler (Looper) 这一构造方法实例化它，用于关联到UI线程。
		Handler(Looper)这一构造方法需要传入了一个Looper对象，它是Android系统的线程管理框架中的另一部分。
		当你在一个特定的Looper实例的基础上去实例化一个Handler时，这个Handler与Looper运行在同一个线程里。
	再讨论 UI线程 与 后台线程的交互!!
		从源码分析
		//ui线程
		photoManager startdownload 开始, 实例化了一个 phototask
		 一个实例化的 phototask里又实例化了 一个PhotoDecodeRunnable和PhotoDownloadRunnable
		另外重点的是,phototask类声明了自己是一个接口类, 
		PhotoDecodeRunnable和PhotoDownloadRunnable 各实例了一个接口对象,可以直接访问phototask实例里的接口函数 !
		然后的回到 photoManager startdownload,继续,把 phototask.PhotoDownloadRunnable 任务扔到后台下载线程池,
		//后台下载线程
		phototask.PhotoDownloadRunnable.run()
		mPhotoTask是一个接口对象,可直接访问phototask实例的内容!!
		mPhotoTask.setDownloadThread(Thread.currentThread()); //保存当前所处线程以及相关当前运行状态信息,为中断服务
			注意, 现在是运行在后台下载线程的任务,却通过接口对象mPhotoTask,使用了在UI线程实例化的phototask实例的函数
			并且修改了 在UI线程实例化的phototask实例 的mCurrentThread参数对象
			即 在UI线程实例化的phototask实例 直接被执行在后台下载线程的任务 访问了函数并修改了内容
		接下来陆续做了一系列工作,也通过接口对象mPhotoTask,访问修改了 phototask实例的其他内容
		下载完成了,
		mPhotoTask.setByteBuffer(byteBuffer);	//把下载的原始数据放到了 phototask实例
		mPhotoTask.handleDownloadState(HTTP_STATE_COMPLETED);
			调用了phototask.handleDownloadState->phototask.handleState->PhotoManager.handleState
			辗转把标记递到 实例PhotoManager.handleState处理,然后把PhotoDecodeRunnable扔到后台解码线程池
			注意,虽然用到了实例PhotoManager的函数,但依然在后台下载线程里执行.
			这里是在 后台下载线程,把PhotoDecodeRunnable扔到后台解码线程池
			至此 mPhotoTask.handleDownloadState 才真正结束
		PhotoDownloadRunnable任务也告一段落!!
		//后台解码线程
		phototask.PhotoDecodeRunnable.run()
		mPhotoTask是一个接口对象,可直接访问phototask实例的内容!!
		mPhotoTask.setImageDecodeThread(Thread.currentThread());//保存当前所处线程以及相关当前运行状态信息,为中断服务
		由于这个runnable 和上面谈论的 downloadrunnable 都是那同一个phototask实例里的子实例,
		所以这里修改的还是同一个 实例phototask 的mCurrentThread参数对象
		然后也是执行亢长的解码操作,中途也会他也会用过接口对象修改 phototask实例的内容
		解码完成: 
		mPhotoTask.setImage(returnBitmap);	//把解码后图片放到了 phototask实例
                mPhotoTask.handleDecodeState(DECODE_STATE_COMPLETED);
			调用了phototask.handleDecodeState->phototask.handleState->PhotoManager.handleState
			辗转把标记递到 实例PhotoManager.handleState处理,
			把 放在phototask实例上的图片数据 放到一个 LruCache 类实例上去
			然后, 为 photomanger 上的 Handler实例 获取一个消息 obj = photomanager.Handler.obtainmessage();
			把消息发到系统上去: obj.sendToTarget();
			至此 mPhotoTask.handleDecodeState 才真正结束
		//ui线程
		android系统收到一个消息,又把它发给了 UI线程中执行的 Photomanager实例中的 Handler 的 handlerMessage处理
		从收到的 obj中找到了 相对应的那一个 phototask实例,
		把phototask实例中 缓存的 的图片 直接 放上View显示,
		(注意,虽然图片也被缓存到 LruCache上,但这里并没有使用Cache上的内容)
		//最后
		纵观整个过程,虽然 在UI线程中 实例的photoManager,photoTask的内容和类函数,可以在后台线程中被各种调用
		后台线程的decode任务 把内容放到 photoTask实例中去,然后给系统发个通知,
		然后UI线程才把图片显示到显示屏上,
		后台线程是无法执行 localView.setImageBitmap这样的函数的,所以是后台线程通知UI线程数据已经准备好,让UI线程执行
后台服务,与多线程同一个例子,
	上面解析如何建立 后台线程池,把后台任务放进去执行,
	这里后台服务的做法不一样!!	 		
	官方例子有内容缺失,先不管
	一般建立后台service步骤:
		mainfest 添加例如像以下的内容
		        <service android:name=".ServiceXXX"	//ServiceXXX指ServiceXXX.class
		            android:label="@string/app_name">
		        </service>
		启动后台的activity代码要添加例如以下内容:
			Intent i = new Intent(Service_without_UI.this,ServiceXXX.class);
			startService(i);
		后台代码像这样(这个后台是播放音乐):
			public class ServiceXXX extends Service {
			 MediaPlayer m;
			 /* 必须重写的IBinder,未知作用!!!
			  * @see android.app.Service#onBind(android.content.Intent)
			  */
			 @Override
			 public IBinder onBind(Intent arg0) {
			  // TODO Auto-generated method stub
			  return null;
			 }

			 @Override
			 public void onCreate() {
			  // TODO Auto-generated method stub
			  super.onCreate();
			 }

			 @Override
			 public void onStart(Intent intent, int startId) {
			  Toast.makeText(this, "Service start", Toast.LENGTH_SHORT).show();		
			  if (m!=null) m.stop();
			  m = MediaPlayer.create(this, R.raw.deal); //raw是放mp3的資料夾,deal是mp3的檔名
			  m.start();
			 }

			 @Override
			 public void onDestroy() {
			  Toast.makeText(this, "Service stop", Toast.LENGTH_SHORT).show();
			  m.stop();
			  m.release();
			 }
			}	
	service返回数据消息的操作,通过广播:
		在需要接收反馈内容的acticity添加例如以下内容
		     //声明类实例, 这个类定义内容,可嵌入到自己的activity类里,也可以在外面一个独立.java文件重新定义
		     private ServiceXXX msgReceiver;  
		     //动态注册广播接收器  
		     msgReceiver = new MsgReceiver();  
		     IntentFilter intentFilter = new IntentFilter();  
		     intentFilter.addAction("com.example.communication.RECEIVER");  //消息标记
		     registerReceiver(msgReceiver, intentFilter);  
		    // 广播接收器  类定义
		    public class MsgReceiver extends BroadcastReceiver{  
		  
		        @Override  
		        public void onReceive(Context context, Intent intent) {  
		            //拿到进度，更新UI  
		            int progress = intent.getIntExtra("progress", 0);  //得到int数据,这里填入参数是 {String:数据名, int数据A}
			    //int数据A是默认值,万一没有 String:数据名 那么默认就返回这个默认值
		            mProgressBar.setProgress(progress);  	//更新进度条view
		        }  
		    } 
		修改 serviceXXX.class 添加一些内容:
		    //建立 Intent
		    private Intent intent = new Intent("com.example.communication.RECEIVER");  			
		    //发送Action为com.example.communication.RECEIVER的广播  
                    intent.putExtra("progress", progress);  //这里填入参数是 {String:数据名, 数据内容}
                    sendBroadcast(intent);  
	activity 直接交互 service 的数据的第二种操作,通过binder(这里的建立和执行service与上述的有所不同)
		//相当复杂,需要实证
		service 文件加入例如以下内容:
		    public class MyBinder extends android.os.Binder{	//service建立一个binder,里面是client访问service内容的方法
		        public void getData(){		//activity 得到 service 内部数据接口
		            return ServiceXXX.this.data;
		        }
		        public void setData(String data){	//activity 修改 service 内部数据接口
		            ServiceXXX.this.data = data;
		        }
		        public MyService getService(){		//返回 binder实例 所在的 service类实例(返回指针)
		            return ServiceXXX.this;
		        }
		    }

		    @Override
		    public IBinder onBind(Intent intent) {	//必须重写的IBinder 在service实例化一个MyBinder类,并返回
		        // TODO: Return the communication channel to the service.
		        System.out.println("ServiceXXX.onBind()");
		        return new MyBinder();	//返回的实例作为 activity 里 onServiceConnected中的第二个参数
		    }
		activity文件添加例如以下内容:
		    //声明一个 ServiceXXX 对象
		    private ServiceXXX msgService;  
		    //绑定Service,并启动
		    //注意, 一般建立后台service步骤:启动后台的activity代码像这样的:
		    //	Intent i = new Intent(Service_without_UI.this,ServiceXXX.class);
		    //	startService(i);
		    //startService 和 bindService, 区别:startService适合不使用binder交互的情形,
		    //但是这个通过 binder 交互的 方式 启动后台的方式却是这样的
		    @Override  
		    protected void onCreate(Bundle savedInstanceState) { 		
			    Intent intent = new Intent(Service_without_UI.this,ServiceXXX.class);
			    bindService(intent, conn, Context.BIND_AUTO_CREATE); 
		    ...}
		    //新建一个连接实例
		    ServiceConnection conn = new ServiceConnection() {  
		        @Override  
		        public void onServiceDisconnected(ComponentName name) {  
		           ...   
		        }  
		          
		        @Override  
		        public void onServiceConnected(ComponentName name, IBinder binder) {  
		            //service onBind() 返回一个 MyBinder实例给 binder, 
			    //通过 MyBinder.getService()的得到 binder 所在 service
		            msgService = ((ServiceXXX.MyBinder)binder).getService();  
		              
		        }  
		    }; 
		    //activity 读写 service 内容
		    func {...
		        dataxx = msgService.Mybinder.getdata();
		        msgService.Mybinder.setdata(dataxx);
		    }
		这个例子代码乱,有必要记下代码的执行思路:
			activity启动前,会实例化化这个activity,所以会实例化ServiceConnection conn
			然后 activity启动,执行oncreate(),会执行bindservice,
				serviceXXX实例化,肯定会执行 onBind(),最后返回 MyBinder()实例的指针
				bind后,会唤醒 activity 实例中的ServiceConnection实例conn.onServiceConnected
				这样,就获得service的指针,并返回到activity里
			然后 activity所属的UI线程就可以访问 后台线程的 serviceXXXX 的 数据,甚至函数!!
easytouch分析!!
	注意app 和 activity 的概念, 一个运行的app会建立多个activity,即使所有activity都关闭,不代表app就已经退出.
	Activity类中的finish()、onDestory()和System.exit(0) 三者的区别：
		finish是Activity的类，仅仅针对Activity，当调用finish()时，只是将活动推向后台，
		并没有立即释放内存，活动的资源并没有被清理；当调用System.exit(0)时，杀死了整个进程，这时候活动所占的资源也会被释放。
		Activity.finish()
			Call this when your activity is done and should be closed. 
			在你的activity动作完成的时候，或者Activity需要关闭的时候，调用此方法。
			当你调用此方法的时候，系统只是将最上面的Activity移出了栈，并没有及时的调用onDestory（）方法，
			其占用的资源也没有被及时释放。因为移出了栈，所以当你点击手机上面的“back”按键的时候，也不会找到这个Activity。
			finish是Activity的类，仅仅针对Activity，当调用finish()时，只是将活动推向后台，
			并没有立即释放内存，活动的资源并没有被清理；
		Activity.Onstop()
			OnStop(){}是指在Activity结束时调用什么东西，可以重写的，这两个完全不一样，简单的说就是finish()时会调用OnStop里的方法
		Activity.onDestory()
			the system is temporarily destroying this instance of the activity to save space.
			系统销毁了这个Activity的实例在内存中占据的空间。
			在Activity的生命周期中，onDestory()方法是他生命的最后一步，资源空间什么的都没有咯~~。
			当重新进入此Activity的时候，必须重新创建，执行onCreate()方法。
		System.exit(0)
			这玩意是退出整个应用程序的，是针对整个Application的。将整个进程直接KO掉。
			当调用System.exit(0)时，杀死了整个进程，这时候活动所占的资源也会被释放。
			使用时，可以写在onDestory()方法内，亦可直接在想退出的地方直接调用：
			如：System.exit(0); 或 android.os.Process.killProcess(android.os.Process.myPid());
	后台服务service分析见上面
	Binder
		这是一个android ipc ,以client/server的方式实现
		具体是实现原理不深究,先认识一般是使用方法:
		1.继承 Binder 使用 例子:
		    在service类中，创建一个满足以下任一要求的Binder实例：
		        包含客户端可调用的公共方法
		        返回当前Service实例，其中包含客户端可调用的公共方法
		        返回由当前service承载的其他类的实例，其中包含客户端可调用的公共方法
			例如:
			    public class MyBinder extends android.os.Binder{	//service建立一个binder,里面是client访问service内容的方法
			        public void getData(){		//activity 得到 service 内部数据接口
			            return ServiceXXX.this.data;
			        }
			        public void setData(String data){	//activity 修改 service 内部数据接口
			            ServiceXXX.this.data = data;
			        }
			        public MyService getService(){		//返回当前Service实例的方法
			            return ServiceXXX.this;
			        }
			    }
		    在service类中onBind()方法中返回这个Binder实例
			    @Override
			    public IBinder onBind(Intent intent) {
			        return new MyBinder();	//返回的实例作为 activity 里 onServiceConnected中的第二个参数
			    }
		    在客户端activity中通过onServiceDisconnected()方法接收传过来的Binder实例，
			    //新建一个连接实例
			    ServiceConnection conn = new ServiceConnection() {  
			        @Override  
			        public void onServiceDisconnected(ComponentName name) {  
			        }  
			        @Override  
			        public void onServiceConnected(ComponentName name, IBinder binder) {  
			            msgService = ((ServiceXXX.MyBinder)binder).getService();  
			        }  
			    }; 
		    在客户端activity中,bindservice
			    bindService(intent, conn, Context.BIND_AUTO_CREATE); 
			    bindservice第一个参数是 intent,用来指定启动那个service,以及传递一些数据
			    第二个参数是 ServiceConnection,
			    第三个参数是 flag,
				通常应该是 BIND_AUTO_CREATE，以便创建尚未激活的服务。 
				其他可能的值为 BIND_DEBUG_UNBIND 和 BIND_NOT_FOREGROUND，或 0（表示无）。
		    然后就可以通过binder接口提供的方法进行后续操作,访问service 的内容!!
		        dataxx = msgService.Mybinder.getdata();
		        msgService.Mybinder.setdata(dataxx);
		2,使用message 
		    在service类中，创建一个满足以下任一要求的 Handler实例：
			    static final int MSG_SAY_HELLO = 1;
			    class ServiceHandler extends Handler {
			        @Override
			        public void handleMessage(Message msg) {
			            switch (msg.what) {
			                case MSG_SAY_HELLO:                    
			                    Toast.makeText(getApplicationContext(), "hello!", Toast.LENGTH_SHORT).show();
			                    break;
			                default:
			                    super.handleMessage(msg);
			            }
			        }
			    }
		    在service类中,把这个Handler实例映射到一个消息实例:
			    //当service收到消息的时候就会自动执行 ServiceHandler().handleMessage内容
			    final Messenger mMessenger = new Messenger(new ServiceHandler());
		    在service类中onBind()方法中返回这个Messenger自带的Binder实例
			    @Override
			    public IBinder onBind(Intent intent) {
			        return mMessenger.getBinder();
			    }
		    在客户端activity中通过onServiceDisconnected()方法接收传过来的Binder实例，
			    //新建一个连接实例
			    private ServiceConnection mConnection = new ServiceConnection() {
			        public void onServiceConnected(ComponentName className, IBinder service) {	            
			            mService = new Messenger(service);	//为这个传来的binder在客户端里又新建一个 Messenger实例
			            mBound = true;
			        }
			        public void onServiceDisconnected(ComponentName className) {
			            mService = null;
			            mBound = false;
			        }
			    };
		    在客户端activity里 bindserver
		        Intent intent = new Intent();
		        intent.setAction("com.lypeer.messenger");
		        bindService(intent, mConnection, Context.BIND_AUTO_CREATE);
		    这时,客户端activity发送的message ,会被service收到并处理!!
		        Message msg = Message.obtain(null, MSG_SAY_HELLO, 0, 0);
	                mService.send(msg);
		    完整代码例子:
			//acctivity.java
			public class ActivityMessenger extends Activity {
			
			    static final int MSG_SAY_HELLO = 1;
			
			    Messenger mService = null;
			    boolean mBound;
			
			    private ServiceConnection mConnection = new ServiceConnection() {
			        public void onServiceConnected(ComponentName className, IBinder service) {
			            
			            mService = new Messenger(service);
			            mBound = true;
			        }
			
			        public void onServiceDisconnected(ComponentName className) {
			            mService = null;
			            mBound = false;
			        }
			    };
			   
			    public void sayHello(View v) {
			        if (!mBound) return;
			        
			        Message msg = Message.obtain(null, MSG_SAY_HELLO, 0, 0);
			        try {
			            mService.send(msg);
			        } catch (RemoteException e) {
			            e.printStackTrace();
			        }
			    }
			
			    @Override
			    protected void onCreate(Bundle savedInstanceState) {
			        super.onCreate(savedInstanceState);
			        setContentView(R.layout.activity_main);
			    }
		
			    @Override
			    protected void onStart() {
			        super.onStart();
			        
			        Intent intent = new Intent();
			        intent.setAction("com.lypeer.messenger");
			        bindService(intent, mConnection, Context.BIND_AUTO_CREATE);
			    }
			
			    @Override
			    protected void onStop() {
			        super.onStop();
			        
			        if (mBound) {
			            unbindService(mConnection);
			            mBound = false;
			        }
			    }
			}

			//Messenger.java
			public class MessengerServiceDemo extends Service {
			
			    static final int MSG_SAY_HELLO = 1;
			
			    class ServiceHandler extends Handler {
			        @Override
			        public void handleMessage(Message msg) {
			            switch (msg.what) {
			                case MSG_SAY_HELLO:
			                    
			                    Toast.makeText(getApplicationContext(), "hello!", Toast.LENGTH_SHORT).show();
			                    break;
			                default:
			                    super.handleMessage(msg);
			            }
			        }
			    }
			
			    final Messenger mMessenger = new Messenger(new ServiceHandler());
			
			    @Nullable
			    @Override
			    public IBinder onBind(Intent intent) {
			        Toast.makeText(getApplicationContext(), "binding", Toast.LENGTH_SHORT).show();
			        
			        return mMessenger.getBinder();
			    }
			}
		3,通过 AIDL:(安卓接口定义语言)	
	toast
		其实就是弹窗消息,先不深究
	context
		加载资源、启动一个新的Activity、获取系统服务、获取内部文件（夹）路径、创建View操作时等都需要Context的参与
		是一个抽象类,Activity、Service、Application都是继承自ContextWrapper，
		而ContextWrapper内部会包含一个base context，由这个base context去实现了绝大多数的方法
		BroadcastReceiver ContentProvider 并不继承context类,他们持有的context 是其他地方传过去
		在需要Context的时候，如果是在Activity中，大多直接传个this，
		当在匿名内部类的时候，因为this不能用，需要写XXXActivity.this，很多人偷懒，直接就来个getApplicationContext。
		但XXXActivity.this和getApplicationContextu有区别
		XXXActivity和getApplicationContext返回的肯定不是一个对象，一个是当前Activity的实例，一个是项目的Application的实例。
		既然区别这么明显，那么各自的使用场景肯定不同，乱使用可能会带来一些问题。
		例如以下一个例子
			import android.content.Context;  
			public class CustomManager  	
			{  
			    private static CustomManager sInstance;  	//sInstance是一个static量
			    private Context mContext;  
			    private CustomManager(Context context)  
			    {  
			        this.mContext = context;  
			    }  	  
			    public static synchronized CustomManager getInstance(Context context)  
			    {  
			        if (sInstance == null)  
			        {  
			            sInstance = new CustomManager(context);  
			        }  
			        return sInstance;  
			    }  	      
			    //some methods   
			    private void someOtherMethodNeedContext()  
			    {  ...	          
			    }  
			}	
			在XXXactivity里 调用 CustomManager.getInstance(this)时,
			我们传递了 XXXactivity的实例A 的context 给 CustomManager的一个实例sInstance 的 mContext对象
			因为 sInstance是一个static量, 即一直存在与 application同生命存在
			就是说当 XXXactivity的实例A 需要 destory 的时候,
			由于XXXactivity的实例A 的context 被实例sInstance 的 mContext对象持有,导致无法释放,
			导致整个 XXXactivity的实例A所占空间没有被释放
			当 XXXactivity的实例B 调用 CustomManager.getInstance(this)时,
			sInstance 的 mContext对象持有XXXactivity的实例B 的context
			而 XXXactivity的实例A所占空间 会变成占据内存的死块一直存在 (这就是内存泄漏)
			正确的做法是:
				sInstance = new CustomManager(context.getApplicationContext());
			这样的的话,在XXXactivity里 调用 CustomManager.getInstance(this)时,
			我们传递了 XXXactivity的实例A 的context 给 CustomManager的一个实例sInstance,
			实例sInstance 会从 XXXactivity的实例A 的context 找到 application的context,然后赋给 mContext
			即实例sInstance 的 mContext对象 引用了 application的context,
			appliacation退出的时候,先释放实例sInstance,再释放自己,
			这样就不存在 sInstance 的 mContext对象持有application的context,而导致无法释放造成内存泄漏
		需要获取 context 的应用行为有:
		show a dialog,start an activity,layout inflation,...
		例如 建立一个新activity的应用行为 最好是获取当前 activity实例的content作为引用
		一些补充:
		getBaseContext() 返回的是 contexttimpl类实例
			Context类本身是一个纯abstract类，它有两个具体的实现子类：ContextImpl和ContextWrapper。
			其中ContextWrapper类，如其名所言，这只是一个包装而已，ContextWrapper构造函数中必须包含一个真正的Context引用，
			同时ContextWrapper中提供了attachBaseContext（）用于给ContextWrapper对象中指定真正的Context对象，
			调用ContextWrapper的方法都会被转向其所包含的真正的Context对象。ContextThemeWrapper类，
			如其名所言，其内部包含了与主题（Theme）相关的接口，
			这里所说的主题就是指在AndroidManifest.xml中通过android：theme为Application元素或者Activity元素指定的主题。
			当然，只有Activity才需要主题，Service是不需要主题的，因为Service是没有界面的后台场景，
			所以Service直接继承于ContextWrapper，Application同理。
			而ContextImpl类则真正实现了Context中的所以函数，应用程序中所调用的各种Context类的方法，其实现均来自于该类。
			一句话总结：Context的两个子类分工明确，其中ContextImpl是Context的具体实现类，ContextWrapper是Context的包装类。
			Activity，Application，Service虽都继承自ContextWrapper（Activity继承自ContextWrapper的子类ContextThemeWrapper），
			但它们初始化的过程中都会创建ContextImpl对象，由ContextImpl实现Context中的方法。。
		getApplication()和getApplicationContext()区别:
			getApplication()只能在activity/service类函数调用
			getApplicationContext()则可以在其他例如上述例子,例如 BoardcastReceiver
	popupwindow
		5.1以后,系统自带的似乎不能显示在桌面之上,未知问题出在哪.
		在5.1设备后工作出错,不提倡使用!! 建议通过 windowmanager addview实现
	Intent:
		(意图)有隐形意图implicit和显性意图explicit两个概念!
		它可以通过 startActivity 来启动一个活动，
		broadcastIntent 来发送广播到任何对它感兴趣的广播接受器组件，
		startService(Intent) 或者bindService(Intent， ServiceConnection, int) 来与后台服务通讯
		显性意图例子:
			// 通过指定类名的显式意图,
			//第一个参数context: FirstActivity.this 表示这个意图来源于 FirstActivity 
			//的二个参数是 一个activity class,显然这个意图是给 SecondAcitivity 的
			Intent i = new Intent(FirstActivity.this, SecondAcitivity.class);
			//传递这个意图给系统,系统根据这个意图直接打开启动 同app 的SecondAcitivity
			startActivity(i);
		隐性意图例子1:
			//第一个参数是标记 android.content.Intent.ACTION_VIEW
			//第二个参数是数据: Uri.parse("http://www.uprogrammer.cn")
			Intent i = new Intent(android.content.Intent.ACTION_VIEW, Uri.parse("http://www.uprogrammer.cn"));
			//传递这个意图给系统,系统会筛选出一堆接受ACTION_VIEW的 activity(不一定是同一个app),
			//然后在根据后面的 Uri数据选择最合适的 activity启动 
                	startActivity(i);
			//就是说 隐式意图之所以是隐式是因为.传递的意图只有标记和数据,要通过标记和数据来筛选出activity来启动!!
		隐性意图例子2:
		    app1:
			//建立一个android.content.Intent.ACTION_VIEW 标记的意图, 
	                Intent i = new Intent(android.content.Intent.ACTION_VIEW,Uri.parse("http://www.uprogrammer.cn"));
	                startActivity(i);
			//建立一个cn.uprogrammer.intentfilter.LAUNCH 标记的意图,(这个标记是自己定义的) 
	                Intent i = new Intent("cn.uprogrammer.intentfilter.LAUNCH",Uri.parse("http://www.uprogrammer.cn"));
	                startActivity(i);
		    app2:
			//CustomActivity.java
			import android.app.Activity;
		        import android.net.Uri;
		        import android.os.Bundle;
		        import android.widget.TextView;
		
			public class CustomActivity extends Activity {
			    @Override
			    public void onCreate(Bundle savedInstanceState) {
			        super.onCreate(savedInstanceState);
			        setContentView(R.layout.custom_view);
			        TextView label = (TextView) findViewById(R.id.show_data);
			        Uri url = getIntent().getData();
			        label.setText(url.toString());
			    }
			}
			//AndroidManifest.xml
			//app要设置相关过滤器</intent-filter> 才可以接收到相关的隐式意图
		        <activity android:name="cn.uprogrammer.intentfilter.CustomActivity"
		            android:label="@string/app_name">	
			        <intent-filter>
			            <action android:name="android.intent.action.VIEW" />
			            <action android:name="cn.uprogrammer.intentfilter.LAUNCH" />
			            <category android:name="android.intent.category.DEFAULT" />
			            <data android:scheme="http" />
			        </intent-filter>		
		        </activity>
			假设 app1 向系统发送了一个 Intent		
			app2 的 AndroidManifest.xml中设置了CustomActivity的 intent-filter 表示:
				当系统收到 android.intent.action.VIEW 时
				都会初步筛选到 app2.CustomActivity, 和浏览器的activity,和其他合适的activity
				进一步分析 intent里带有的参数Uri.parse("http://www.uprogrammer.cn"),
				根据 <data android:scheme="http" /> 进一步筛选出,app2.CustomActivity, 和浏览器的activity
				然后弹出弹窗让用户选择其中一个 来打开,并传给他Intent!!
				当系统收到 cn.uprogrammer.intentfilter.LAUNCH 时
				都会初步只筛选到 app2.CustomActivity,然后直接打开,并传给他Intent!!
	broadcastReceiver:
		例子:
		   //app1建立一个 MyReceiver.java
			public class MyReceiver extends BroadcastReceiver {
			    @Override
			    public void onReceive(Context context, Intent intent) {
			        Toast.makeText(context, "检测到意图。", Toast.LENGTH_LONG).show();
			    }
			}
		  //app1 的 AndroidManifest.xml 添加注册 receiver
		        <receiver android:name="MyReceiver">
		            <intent-filter>
		                <action android:name="cn.programmer.CUSTOM_INTENT">	//设置意图过滤器
		                </action>
		            </intent-filter>		
		        </receiver>				    
		  //另一个app2 的activity 发送意图
			public void broadcastIntent(View view){
			     Intent intent = new Intent();
			     intent.setAction("cn.programmer.CUSTOM_INTENT");
			     sendBroadcast(intent);
			}
		 这时,系统接收到一个意图,根据cn.programmer.CUSTOM_INTENT标记筛选到了app1.MyReceiver,然后打开并传递了intrnt
	contentprovider
		app1,为其他app可共同访问app1建立的sqlite数据库的数据,所提供的一个接口方法
		contentprovider是基于 URL 访问的,所以要建立对应的 uri 透过uri访问
		uri格式例子: content://cn.scu.myprovider/User/7
			content:// 安卓规定contentprovider使用的标识段
			cn.scu.myprovider 域名 用来定位要访问的是哪个 contentprovider
			User  一个对象集合,比如contentprovider映射的 sqlite数据库的 User的这个表单
			7	表单中 id 为 7 那条数据记录!!!
		例子:
		  所有app要访问 app1 contentprovider 自身都应该有一个这样的 常量类 content.java!!!
			import android.net.Uri;  
			public class Constant {  
			    public static final String TABLE_NAME = "user";  
			    public static final String COLUMN_ID = "_id";  
			    public static final String COLUMN_NAME = "name";  
			    public static final String AUTOHORITY = "cn.scu.myprovider";  
			    public static final int ITEM = 1;  
			    public static final int ITEM_ID = 2; 
			    //以下两条与 MIME 相关 
			    	public static final String CONTENT_TYPE = "vnd.android.cursor.dir/user";  
			    	public static final String CONTENT_ITEM_TYPE = "vnd.android.cursor.item/user";  
			    public static final Uri CONTENT_URI = Uri.parse("content://" + AUTOHORITY + "/user");  
			}  
			//常量类告诉各个app, 访问 app1 contentprovider 需要用到的一些 句柄常量什么的.
		  app1 持有 contentprovider需要一个DBHelper接口来操作sqlite数据库,
			import android.database.sqlite.SQLiteDatabase;
			import android.database.sqlite.SQLiteOpenHelper;
			import android.content.Context;  
			import android.database.SQLException;  
			  
			public class DBHelper extends SQLiteOpenHelper {  
			    private static final String DATABASE_NAME = "finch.db";    
			    private static final int DATABASE_VERSION = 1;    

			    public DBHelper(Context context) {  
			        super(context, DATABASE_NAME, null, DATABASE_VERSION);  
			    } 
 	  
			    @Override  
			    public void onCreate(SQLiteDatabase db)  throws SQLException {  
			        //打开数据库,不存在就新建
			        db.execSQL("CREATE TABLE IF NOT EXISTS "+ Constant.TABLE_NAME + "("+ Constant.COLUMN_ID 
					+" INTEGER PRIMARY KEY AUTOINCREMENT," + Constant.COLUMN_NAME +" VARCHAR NOT NULL);");  
			    }  
			  
			    @Override  
			    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)  throws SQLException {  
			        //更新数据库  
			        db.execSQL("DROP TABLE IF EXISTS "+ Constant.TABLE_NAME+";");  
			        onCreate(db);  
			    }  
			} 
		  app1 的 contentprovider 内容	
			//主要提供 delete() insert() query() update() getType()外部访问接口,	
			import android.content.ContentProvider;    
			import android.content.ContentUris;    
			import android.content.ContentValues;    
			import android.content.UriMatcher;    
			import android.database.Cursor;    
			import android.database.SQLException;    
			import android.database.sqlite.SQLiteDatabase;    
			import android.net.Uri;        
			public class MyProvider extends ContentProvider {    
			    
			    DBHelper mDbHelper = null;    
			    SQLiteDatabase db = null;    
			    
			    private static final UriMatcher mMatcher; //文本筛选器
			    static{    
			        mMatcher = new UriMatcher(UriMatcher.NO_MATCH);  
				//添加筛选筛选项,
				//当 match()匹配 content://cn.scu.myprovider/user时, 返回1
			        mMatcher.addURI(Constant.AUTOHORITY,Constant.TABLE_NAME, Constant.ITEM);    
				//当 match()匹配 content://cn.scu.myprovider/user/#时, 返回2
			        mMatcher.addURI(Constant.AUTOHORITY, Constant.TABLE_NAME+"/#", Constant.ITEM_ID);    
			    }    
			    
			    @Override    
			    public int delete(Uri uri, String selection, String[] selectionArgs) {    
			        // TODO Auto-generated method stub    
			        return 0;    
			    }    
			    
			    @Override    
			    public String getType(Uri uri) {  //这个函数一般 返回当前uri所代表的数据的 MIME 类型  
			        switch (mMatcher.match(uri)) {    
			        case Constant.ITEM:    
			            return Constant.CONTENT_TYPE;    
			        case Constant.ITEM_ID:    
			            return Constant.CONTENT_ITEM_TYPE;    
			        default:    
			            throw new IllegalArgumentException("Unknown URI"+uri);    
			        }    
			    }    
			    
			    @Override    
			    public Uri insert(Uri uri, ContentValues values) {    
			        // TODO Auto-generated method stub    
			        long rowId;    
			        if(mMatcher.match(uri)!=Constant.ITEM){    
			            throw new IllegalArgumentException("Unknown URI"+uri);    
			        }    
			        rowId = db.insert(Constant.TABLE_NAME,null,values);    
			        if(rowId>0){    
			            Uri noteUri=ContentUris.withAppendedId(Constant.CONTENT_URI, rowId);    
			            getContext().getContentResolver().notifyChange(noteUri, null);    
			            return noteUri;    
			        }    
			    
			        throw new SQLException("Failed to insert row into " + uri);    
			    }    
			    
			    @Override    
			    public boolean onCreate() {    
			        // TODO Auto-generated method stub    
			        mDbHelper = new DBHelper(getContext());    
			    
			        db = mDbHelper.getReadableDatabase();    
			    
			        return true;    
			    }    
			    
			    @Override    
			    public Cursor query(Uri uri, String[] projection, String selection,    
			            String[] selectionArgs, String sortOrder) {    
			        // TODO Auto-generated method stub    
			        Cursor c = null;    
			        switch (mMatcher.match(uri)) {    
			        case Constant.ITEM:    
			            c =  db.query(Constant.TABLE_NAME, projection, selection, selectionArgs, null, null, sortOrder);    
			            break;    
			        case Constant.ITEM_ID:    
			            c = db.query(Constant.TABLE_NAME, projection,Constant.COLUMN_ID + "="+uri.getLastPathSegment(), selectionArgs, null, null, sortOrder);    
			            break;    
			        default:    
			            throw new IllegalArgumentException("Unknown URI"+uri);    
			        }    
			    
			        c.setNotificationUri(getContext().getContentResolver(), uri);    
			        return c;    
			    }    
			    
			    @Override    
			    public int update(Uri uri, ContentValues values, String selection,    
			            String[] selectionArgs) {    
			        // TODO Auto-generated method stub    
			        return 0;    
			    }    
			    
			}    
		  app1 的 Androidmanifest.xml 添加这个:
		        <provider android:name="MyProvider" android:authorities="cn.scu.myprovider" />
			给系统注册了这个 contentprovider 的 域名,其他app访问这位个provider要通过这个域名
		  要访问 app1 contentprovider 的 app 的activity,都需要的内容
			//建立一个 ContentResolver 类实例
			private ContentResolver mContentResolver = null; 	
			mContentResolver = getContentResolver();
			//给  contentprovider 添加数据
		        ContentValues values = new ContentValues();  //新建一个ContentValues
	                values.put(Constant.COLUMN_NAME, "fanrunqi"+i);  //添加内容,这里添加的是 name:fanrunqi 
                        mContentResolver.insert(Constant.CONTENT_URI, values);	//上传到 contentprovider
			注意,ContentResolver.insert会根据 uri Constant.CONTENT_URI(constant.java定义的常量)
			而且 Constant.CONTENT_URI直接指向了 user的这张数据表单
			找到了 app1 的contentprovider 的insert, 然后添加数据到 sqlite数据库
			//查询 contentprovider的内容, 即查询 sqlite数据库的内容
			private Cursor cursor = null;  
			cursor = mContentResolver.query(Constant.CONTENT_URI, 
				new String[]{Constant.COLUMN_ID,Constant.COLUMN_NAME}, null, null, null);  
			同样ContentResolver.query会根据 uri Constant.CONTENT_URI(constant.java定义的常量)
			找到了 app1 的contentprovider 的query, 查询sqlite数据库 相关数据
			源码例子:
			import android.app.Activity;
			import android.content.ContentResolver;
			import android.content.ContentValues;
			import android.database.Cursor;
			import android.os.Bundle;
			import android.widget.TextView;

			public class MainActivity extends Activity {
			    private ContentResolver mContentResolver = null; 
			    private Cursor cursor = null;  
			         @Override
			        protected void onCreate(Bundle savedInstanceState) {
			        	// TODO Auto-generated method stub
			        	super.onCreate(savedInstanceState);
			        	setContentView(R.layout.activity_main);
			        	
			        	   TextView tv = (TextView) findViewById(R.id.tv);
							
			        		mContentResolver = getContentResolver();  
			        		tv.setText("ÌíŒÓ³õÊŒÊýŸÝ ");
			                for (int i = 0; i < 10; i++) {  
			                    ContentValues values = new ContentValues();  
		                    values.put(Constant.COLUMN_NAME, "fanrunqi"+i);  
			                    mContentResolver.insert(Constant.CONTENT_URI, values);  
			                } 
			                
			            	tv.setText("²éÑ¯ÊýŸÝ ");
			                cursor = mContentResolver.query(Constant.CONTENT_URI, new String[]{Constant.COLUMN_ID,Constant.COLUMN_NAME}, null, null, null);  
			                if (cursor.moveToFirst()) {
			                	String s = cursor.getString(cursor.getColumnIndex(Constant.COLUMN_NAME));
			                	tv.setText("µÚÒ»žöÊýŸÝ£º "+s);
			                }
			        }
			         
			}  		
cleanfloat 进阶版 easytouch, 有以下可学习点!!! (http://blog.csdn.net/hello_1995/article/details/52984309)
	android studio 项目 的 project管理文件是 .iml
	这里使用windowmanager显示浮动按钮,浮动按钮按下后,使用新activity显示操作窗口
	使用trigger 触发是否显示 浮动按钮
	还有所谓的 task, 创建新activity用 NEW_TASK标记,还有在在linearlayout使用startactivity!!
	移植测试,需要注意,除了修改 .java 头 com.xxx.xxx 为自己的名字外,
		特别注意,这里自己新建了一个 自定义view 可视部件, 需要在layout用到这个可视部件的xml上做需要的头修改
		<com.xxx.xxx.Wave_view  >
		学习如何自定义view 可视部件
    	getSystemService(Context.ACTIVITY_SERVICE) 使用!!!
	判断是否在桌面
	    获取 系统管理activity的后台服务 接口实例
		ActivityManager mActivityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
	    获取 运行着的的任务们的名称, 并插入到队列里,(这里只获取一个,只获取正在执行着的)
		List<RunningTaskInfo> rti = mActivityManager.getRunningTasks(1);
	    获取 管理应用包 接口实例
		PackageManager packageManager = this.getPackageManager(); //this指调用次函数所在的activity class 或者service class
	    通过接口实例 通过 intent 唤起进程搜索机子装的所有应用包并把返回的对应ResolveInfo插入到队列里
		Intent intent = new Intent(Intent.ACTION_MAIN);
	        intent.addCategory(Intent.CATEGORY_HOME);	//其实只搜与home有关的应用包
	        List<ResolveInfo> resolveInfo = packageManager.queryIntentActivities(intent,
                PackageManager.MATCH_DEFAULT_ONLY);
	    把应用包的名字加入到 队列
	        for (ResolveInfo ri : resolveInfo) {
		    List<String> names = new ArrayList<String>();
	            names.add(ri.activityInfo.packageName);
	        }
	    通过contains比较安装的桌面相关的应用包里,是否有正在执行的任务(桌面任务)
		List<String>.contains(rti.get(0).topActivity.getPackageName());	//contains是比较函数
        runnable的一种用法:
		    private Handler handler = new Handler();
		    private Runnable runnable = new Runnable() {
		        @Override
		        public void run() {
				....
		            }
		        }
		    };	
	            handler.post(runnable); //给ui线程添加这个的runnable执行 一次,把runnable发到handler执行
       	            handler.postDelayed(runnable, 1000); //1秒后才把runnable发到handler执行
               	    handler.removeCallbacks(runnable); //如果 runable在handler队列里,移除出handler列表,如果正在执行,立即停止并移除!
	读取内存情况:
	    通过读取 linux 内核信息得到 内存信息(这里获取内存总大小)
		String dir = "/proc/meminfo";
	        FileReader fr = new FileReader(dir);
	        BufferedReader br = new BufferedReader(fr, 2048);
	        String memoryLine = br.readLine();
	        String subMemoryLine = memoryLine.substring(memoryLine.indexOf("MemTotal:"));	//读取总内存大小
	        br.close();
	        totalMemorySize = Long.parseLong(subMemoryLine.replaceAll("\\D+", "")) * 1024;	//转换数据格式
	    获取得知可用内容大小
                ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo(); 
			//获取 内存信息 接口实例
                ActivityManager manager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
			//获取 系统管理activity的后台服务 接口实例
                manager.getMemoryInfo(memoryInfo);
                ret = memoryInfo.availMem; 	//得到可用呢内存信息
	亮度:
		import android.provider.Settings;
		//获得此刻的亮度模式
		Settings.System.getInt(aContentResolver,Settings.System.SCREEN_BRIGHTNESS_MODE)	
		//设置自动亮度模式
	        Settings.System.putInt(activity.getContentResolver(),
		    Settings.System.SCREEN_BRIGHTNESS_MODE,
                    Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
		//设置常规亮度模式
 	        Settings.System.putInt(activity.getContentResolver(),
                    Settings.System.SCREEN_BRIGHTNESS_MODE,
                    Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL);
		//获取屏幕亮度
		Settings.System.getInt(resolver, Settings.System.SCREEN_BRIGHTNESS);
		//设置屏幕亮度
		参数 activity, brightness
                WindowManager.LayoutParams lp = activity.getWindow().getAttributes();
                lp.screenBrightness = Float.valueOf(brightness) * (1f / 255f);
                activity.getWindow().setAttributes(lp);
		//保存亮度设置状态
		参数 ContentResolver resolver, int brightness
	        Uri uri = Settings.System.getUriFor("screen_brightness");
                Settings.System.putInt(resolver, "screen_brightness", brightness);
                resolver.notifyChange(uri, null);
		

	windowmanager 加载浮动view的重点 
	easyview的
            mTouchView = LayoutInflater.from(mContext).inflate(R.layout.easy_touch_view, null);   //获取整个layout 整view文件
            mIconImageView = (ImageView) mTouchView.findViewById(R.id.easy_touch_view_imageview); //获取 整view文件里的莫个view
	cleanfloat的 (注意区别!!!)
            LayoutInflater.from(context).inflate(R.layout.float_window, this);
            View view = findViewById(R.id.window_layout);
	
图片裁剪 https://github.com/chendongMarch/PictureEditor

		


20171124
ubuntu 根目录空间不足: 因为长年累月的log挤爆了空间!!!
	su到 root
	echo > /var/log/syslog.1	//清空syslog文件
	echo > /var/log/kernlog		//清空kernlog文件
ubuntu安装 apk (插入手机后)
	adb start-server
	adb devices		//查看设备 得到设备号 xxxcccxxxccc
	adb -s xxxcccxxxccc install ~/temp/app/xxxx.apk		//安装apk
ubuntu 编译反编译apk工具 
	apktool (提取apk)
		Quick Check  
		    Is at least Java 1.7 installed?
		    Does executing java -version on command line / command prompt return 1.7 or greater?
		    If not, please install Java 7+ and make it the default.
		Linux:   (http://blog.csdn.net/u012207345/article/details/77834025)
		    Download Linux wrapper script (Right click, Save Link As apktool)
		    Download apktool-2 (find newest here)
		    Rename downloaded jar to apktool.jar
		    Move both files (apktool.jar & apktool) to /usr/local/bin (root needed) 
		    对应的命令：sudo mv apktool apktool.jar /usr/local/bin
		    Make sure both files are executable (chmod +x) 
		    对应的命令：sudo chmod +x apktool 验证：如果文件可执行，ls出的文件名以绿色字体显示
		    Try running apktool via cli	
		Note - Wrapper scripts are not needed, but helpful so you don’t have to type java -jar apktool.jar over and over.
	dex2jar (把class.dex反译为jar)
	ubuntu 14.04 反编译apk
		需要两个程序：dex2jar和jd-gui.
		下载：
		http://code.google.com/p/dex2jar/downloads/detail?name=dex2jar-0.0.9.15.zip
		http://jd.benow.ca/jd-gui/downloads/jd-gui-0.3.5.linux.i686.tar.gz
		先将apk文件修改为zip然后解压，再解压dex2jar，然后用其中的dex2jar.sh脚本将apk里面的classes.dex转换为jar包：
		./dex2jar.sh classes.dex
		运行后生成classes_dex2jar.jar再用jd-gui打开jar包就能看到源码了。
		ubuntu 14.04运行jd-gui需要安装一些包：
		sudo apt-get install gtk2-engines-murrine:i386 libgtk2.0-0:i386 libcanberra-gtk-module:i386 \
		libgtk2.0-0:i386 libxxf86vm1:i386 libsm6:i386 lib32stdc++6 lib32ncurses5 lib32bz2-1.0 \
		libgtk2.0-0:i386 libxxf86vm1:i386 libsm-dev:i386 libcanberra-gtk3-module:i386
	
浮译:
	easytouch: 桌面上的按钮!
		 : 截屏





20171209
mario android-game
	移植相关
		添加 libs, 把要用到的.jar 放到 libs里,并在 project structure -> dependencies -> 把相关库加入
		应用除了用到res的资源以外还有assets, assets必须和res同一阶目录里
		遇到 > java.lang.RuntimeException: com.android.builder.dexing.DexArchiveMergerException: Unable to merge 
			表示重用了库文件,在 project structure -> dependencies -> 把相关库移除
			例如中这里dependencies里添加的gameapi.jar库就有support.v4库,
			如果这时在dependencies里再添加一个support.v4库就发生冲突了
	thread runnable 新用法:
		public class LoadActivity extends GameActivity  implements Runnable
		{
			@Override
			protected void onCreate(Bundle savedInstanceState) 
			{
				new Thread(this).start();
				...
			}
		
			@Override
			public void run() 
			{
				...		
				Intent i = new Intent(this,MenuActivity.class);
				this.startActivity(i);
				this.finish();
			}
		}		
	这里的activity 没有显示 res/layout的模板,
		而是自己super.setContentView(new XXXView(this)); 来显示 XXXView 的内容
		而 XXXView 就是继承View 的 游戏画面i子集
	
android_studio 装 tensorflow
	git clone https://github.com/tensorflow/tensorflow/
	然后 android_studio 打开一个工程, tensorflow/tensorflow/examples/android,注意只是android只是一个文件夹
		但是打开后 studio会通过 gradle配置好一切得到一个可用项目,gradle配置时需要翻墙联网
	编译调试运行,出错:Error:Execution failed for task ':buildNativeBazel'.
		> A problem occurred starting process 'command '/usr/local/bin/bazel''
		tensorflow通过 bazel编译的,需要按装bazel:(ubuntu14.04)
			//安装jdk 8
			sudo add-apt-repository ppa:webupd8team/java
			sudo apt-get update && sudo apt-get install oracle-java8-installer
			//apt-get安装 bazel (需要翻强)
			echo "deb [arch=amd64] http://storage.googleapis.com/bazel-apt stable jdk1.8" | sudo tee /etc/apt/sources.list.d/bazel.list
			curl https://bazel.build/bazel-release.pub.gpg | sudo apt-key add -
			sudo apt-get update && sudo apt-get install bazel			
	bazel编译问题:https://github.com/bazelbuild/bazel/issues/2333 (未解决)
		//android_studio编译:
		Error:org.gradle.process.internal.ExecException: Process 'command '/usr/bin/bazel'' finished with non-zero exit value 1
		//尝试主动编译
		bazel build -c opt /home/kingders/android/project/tensorflow/tensorflow/tensorflow/examples/android:tensorflow_demo
		WARNING: ignoring http_proxy in environment.
		ERROR: The 'build' command is only supported from within a workspace.








20171215
重新 android_studio 装 tensorflow 因为太多错误!!!
	源码安装 bazel: (先apt-get remove掉 之前装的bazel ) http://blog.csdn.net/masa_fish/article/details/54096996
		下载 bazel-0.8.1-installer-linux-x86_64.sh
		chmod +x bazel-0.8.3-installer-linux-x86_64.sh
		./bazel-0.8.1-installer-linux-x86_64.sh --user
		设置Bazel 环境变量
			sudo gedit ~/.bashrc
			在 ~/.bashrc文件的末尾添加:export PATH=$PATH:$/home/kingders/bin
		添加其他依赖
			sudo apt-get install python-numpy python-dev python-wheel
			sudo apt-get install libcupti-dev
	下载 tensorflow (源码):
		git clone https://github.com/tensorflow/tensorflow
		移植安卓项目前需要先到 tensorflow 根目录 ./configure一下, 
		甚至编译一下:
		编译CPU版：
			bazel build --config=opt //tensorflow/tools/pip_package:build_pip_package
			(注意bazel是源码安装版本,apt-get安装版本这里会出错!!)
		编译GPU版：
			bazel build --config=opt --config=cuda //tensorflow/tools/pip_package:build_pip_package
			bazel-bin/tensorflow/tools/pip_package/build_pip_package  /tmp/tensorlflow_pkg
		安装 tensorflow.whl包:(出错)
			cd /tmp/tensorlflow_pkg
			sudo pip install tensorflow-1.4.0-cp27-cp27mu-linux_x86_64.whl
The directory '/home/kingders/.cache/pip/http' or its parent directory is not owned by the current user and the cache has been disabled. Please check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.
The directory '/home/kingders/.cache/pip' or its parent directory is not owned by the current user and caching wheels has been disabled. check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.
tensorflow-1.4.0-cp27-cp27mu-linux_x86_64.whl is not a supported wheel on this platform.
		先不管,因为甚至也不知道怎么用!!
		事时上,只要./configure 后,就会给android建立相关的 bazel workspace,就可以在studio上编译了!!
	android studio 编译 demo
		然后 android_studio 打开一个工程, tensorflow/tensorflow/examples/android,注意只是android只是一个文件夹
		这时studio会自动生成一个项目
		build.gradle 修改:bazel路径
			def bazelLocation = '/home/kingders/bin/bazel'
		---/tensorflow/tensorflow/WORKSPACE修改:
			android_sdk_repository(
			    name = "androidsdk",
			    api_level = 23,
			    # Ensure that you have the build_tools_version below installed in the
			    # SDK manager as it updates periodically.
			    build_tools_version = "26.0.1",
			    # Replace with path to Android SDK on your system
			    path = "/home/kingders/android/Sdk",
			)
			android_ndk_repository(
			    name="androidndk",
			    path="/home/kingders/android/Sdk/ndk-bundle",
			    # This needs to be 14 or higher to compile TensorFlow.
			    # Please specify API level to >= 21 to build for 64-bit
			    # archtectures or the Android NDK will automatically select biggest
			    # API level that it supports without notice.
			    # Note that the NDK version is not the API level.
			    api_level=14)
		注意,编译时自动下载tensorflow的demo学习模型并不成功,所以人工下载(翻强)
			模型地址可以从---/tensorflow/tensorflow/WORKSPACE看到:
			浏览器分别打开:
			http://storage.googleapis.com/download.tensorflow.org/models/inception5h.zip
			http://storage.googleapis.com/download.tensorflow.org/models/object_detection/ssd_mobilenet_v1_android_export.zip
			http://storage.googleapis.com/download.tensorflow.org/models/mobile_multibox_v1a.zip
			http://storage.googleapis.com/download.tensorflow.org/models/stylize_v1.zip
			http://storage.googleapis.com/download.tensorflow.org/models/speech_commands_v0.01.zip
			都解压到:
			/home/kingders/android/project/tensorflow/tensorflow/tensorflow/examples/android/assets
			然后 build.gardle注释掉这段:
				//apply from: "download-models.gradle"
				这样就会编译过程中执行下载解压model的操作了
		成功编译运行demo 到 google手机!!
		
	通过这次demo,还认识到,
		一个application,有多个activity,除了我们通常只有一个activity是这个app的入口,并在桌面上设有图标
		但是,如果在androidmanifest.xml,的多个activity 都设置以下特性:
	            <intent-filter>
	                <action android:name="android.intent.action.MAIN" />
	                <category android:name="android.intent.category.LAUNCHER" />
	            </intent-filter>
		这个activity就会在桌面上拥有自己的启动图标,点击打开进入对应activity
		就是说,同一个app 可拥有多个桌面图标,拥有多个入口!!!









20171219
tensorflow 常用内容(python):
Tensor的意思是张量，其实就是指矩阵。Tensor的生成方式有很多种，最简单的就如
	import tensorflow as tf # 在下面所有代码中，都去掉了这一行，默认已经导入
	a = tf.zeros(shape=[1,2])
	注意,在训练开始前，所有的数据都是抽象的概念，就是说，此时a只是表示这应该是个1*2的零矩阵，
	并没有实际赋值，也没有分配空间，所以如果此时 print(a); ,就会出现如下情况:
		#===>Tensor("zeros:0", shape=(1, 2), dtype=float32)
	只有在训练过程开始后，才能获得a的实际值
		sess = tf.InteractiveSession()
		print(sess.run(a))
		#===>[[ 0.  0.]]
Variable 变量,例如 y=Relu(Wx+b),Y = W × x + b 等在矩阵方程中, W矩阵,b向量 就属于变量
	W = tf.Variable(tf.zeros(shape=[1,2]))	//声明一个 1*2 零矩阵,把这个变成变量W,然后这个1*2 零矩阵就是W变量的初始状态,
	此时W一样是一个抽象的概念，而且与Tensor不同，Variable必须初始化以后才有具体的值:
		tensor = tf.zeros(shape=[1,2])
		variable = tf.Variable(tensor)
		sess = tf.InteractiveSession()
		# print(sess.run(variable))  # 会报错
		sess.run(tf.initialize_all_variables()) # 对variable进行初始化
		print(sess.run(variable))
		#===>[[ 0.  0.]]
placeholder占位符 用于表示输入输出数据的格式,现在没法得到具体数值
	x = tf.placeholder(tf.float32,[1, 5],name='input')	//声明x占位符号,是一个 1*5 的矩阵,即一个5维向量x
	y = tf.placeholder(tf.float32,[None, 5],name='input')	//声明y占位符号,是一个 ?*5 的矩阵,
	第一种x，表示输入是一个[1,5]的横向量。
	第二种形式，表示输入是一个[?,5]的矩阵。那么什么情况下会这么用呢?就是需要输入一批[1,5]的数据的时候。
	比如我有一批共10个数据，那我可以表示成[10,5]的矩阵。
	如果是一批5个，那就是[5,5]的矩阵。tensorflow会自动进行批处理
Session 会话。session是抽象模型的实现者。
	模型是抽象的嘛，只有实现了模型以后，才能够得到具体的值。
	同样，具体的参数训练，预测，甚至变量的实际值查询，都要用到session

例子分析:
官方 mnist数据集的分类 
	使用 feedfroward 模型:
		z=Wx+b
		a=softmax(z)
	模型建立:
		x = tf.placeholder(tf.float32, [None, 784]) # 输入占位符  x是图片数据相当于 28*28=784维向量x 
		y = tf.placeholder(tf.float32, [None, 10])  # 输出占位符  是一个10维向量y,是已知输出!!!
		W = tf.Variable(tf.zeros([784, 10]))        # 784*10 矩阵
		b = tf.Variable(tf.zeros([10]))
		a = tf.nn.softmax(tf.matmul(x, W) + b)      # z是实际输出,a是实际输出的归一化结果
		# 定义损失函数和训练方法
		cross_entropy = tf.reduce_mean(-tf.reduce_sum(y * tf.log(a), reduction_indices=[1])) # 损失函数为交叉熵
		optimizer = tf.train.GradientDescentOptimizer(0.5) # 梯度下降法，学习速率为0.5
		train = optimizer.minimize(cross_entropy)  # 训练目标：最小化损失函数
		模型中的所有元素(图结构，损失函数，下降方法和训练目标)都已经包括在train里面,所以train叫做训练模型	
	实际训练
		sess = tf.InteractiveSession()      # 建立交互式会话
		tf.initialize_all_variables().run() # 所有变量初始化
		for i in range(1000):
		    batch_xs, batch_ys = mnist.train.next_batch(100)    # 获得一批100个数据
		    train.run({x: batch_xs, y: batch_ys})   # 给训练模型提供输入和输出
		print(sess.run(accuracy,feed_dict={x:mnist.test.images,y:mnist.test.labels}))
		在模型搭建完以后，我们只要为模型提供输入和输出，模型就能够自己进行训练和测试了。
		中间的求导，求梯度，反向传播等等繁杂的事情，tensorflow都会帮你自动完成。
	模型检测:
		correct_prediction = tf.equal(tf.argmax(a, 1), tf.argmax(y, 1))
		accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))
		就是比较 a 与 y 的相似, tf.equal把 a归一向量与 y向量 按位与操作,得到结果向量 orrect_prediction
		tf.cast将boolean数组转成int数组，最后求平均值，得到分类的准确率

20171218
分析 android tensorflow demo 项目
	该项目有三个项目目录:
		org.tensorflow
		org.tensorflow.contrib.android
		org.tensorflow.demo
		各自源码目录位置可以从 build.gradle,找到!!!
	    sourceSets {
	        main {
	            if (nativeBuildSystem == 'bazel' || nativeBuildSystem == 'makefile') {
	                // TensorFlow Java API sources.
	                java {
	                    srcDir '../../java/src/main/java'
	                    exclude '**/examples/**'			//备注掉  */
	                }
	
	                // Android TensorFlow wrappers, etc.
	                java {
	                    srcDir '../../contrib/android/java'
	                }
	            }
	            // Android demo app sources.
	            java {
	                srcDir 'src'
	            }
	
	            manifest.srcFile 'AndroidManifest.xml'
	            resources.srcDirs = ['src']
	            aidl.srcDirs = ['src']
	            renderscript.srcDirs = ['src']
	            res.srcDirs = ['res']
	            assets.srcDirs = [project.ext.ASSET_DIR]
	            jniLibs.srcDirs = ['libs']
	        }
	
	        debug.setRoot('build-types/debug')
	        release.setRoot('build-types/release')
	    }		
	







	
	 
????????????????????






































